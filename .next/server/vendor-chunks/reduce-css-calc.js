/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/reduce-css-calc";
exports.ids = ["vendor-chunks/reduce-css-calc"];
exports.modules = {

/***/ "(ssr)/./node_modules/reduce-css-calc/dist/index.js":
/*!****************************************************!*\
  !*** ./node_modules/reduce-css-calc/dist/index.js ***!
  \****************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _postcssValueParser = __webpack_require__(/*! postcss-value-parser */ \"(ssr)/./node_modules/reduce-css-calc/node_modules/postcss-value-parser/lib/index.js\");\nvar _postcssValueParser2 = _interopRequireDefault(_postcssValueParser);\nvar _parser = __webpack_require__(/*! ./parser */ \"(ssr)/./node_modules/reduce-css-calc/dist/parser.js\");\nvar _reducer = __webpack_require__(/*! ./lib/reducer */ \"(ssr)/./node_modules/reduce-css-calc/dist/lib/reducer.js\");\nvar _reducer2 = _interopRequireDefault(_reducer);\nvar _stringifier = __webpack_require__(/*! ./lib/stringifier */ \"(ssr)/./node_modules/reduce-css-calc/dist/lib/stringifier.js\");\nvar _stringifier2 = _interopRequireDefault(_stringifier);\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\n// eslint-disable-line\nvar MATCH_CALC = /((?:\\-[a-z]+\\-)?calc)/;\nexports[\"default\"] = function(value) {\n    var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;\n    return (0, _postcssValueParser2.default)(value).walk(function(node) {\n        // skip anything which isn't a calc() function\n        if (node.type !== \"function\" || !MATCH_CALC.test(node.value)) return;\n        // stringify calc expression and produce an AST\n        var contents = _postcssValueParser2.default.stringify(node.nodes);\n        // skip constant() and env()\n        if (contents.indexOf(\"constant\") >= 0 || contents.indexOf(\"env\") >= 0) return;\n        var ast = _parser.parser.parse(contents);\n        // reduce AST to its simplest form, that is, either to a single value\n        // or a simplified calc expression\n        var reducedAst = (0, _reducer2.default)(ast, precision);\n        // stringify AST and write it back\n        node.type = \"word\";\n        node.value = (0, _stringifier2.default)(node.value, reducedAst, precision);\n    }, true).toString();\n};\nmodule.exports = exports[\"default\"];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVkdWNlLWNzcy1jYWxjL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQUEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBRUYsSUFBSUMsc0JBQXNCQyxtQkFBT0EsQ0FBQztBQUVsQyxJQUFJQyx1QkFBdUJDLHVCQUF1Qkg7QUFFbEQsSUFBSUksVUFBVUgsbUJBQU9BLENBQUM7QUFFdEIsSUFBSUksV0FBV0osbUJBQU9BLENBQUM7QUFFdkIsSUFBSUssWUFBWUgsdUJBQXVCRTtBQUV2QyxJQUFJRSxlQUFlTixtQkFBT0EsQ0FBQztBQUUzQixJQUFJTyxnQkFBZ0JMLHVCQUF1Qkk7QUFFM0MsU0FBU0osdUJBQXVCTSxHQUFHO0lBQUksT0FBT0EsT0FBT0EsSUFBSUMsVUFBVSxHQUFHRCxNQUFNO1FBQUVFLFNBQVNGO0lBQUk7QUFBRztBQUU5RixzQkFBc0I7QUFDdEIsSUFBSUcsYUFBYTtBQUVqQmQsa0JBQWUsR0FBRyxTQUFVQyxLQUFLO0lBQy9CLElBQUljLFlBQVlDLFVBQVVDLE1BQU0sR0FBRyxLQUFLRCxTQUFTLENBQUMsRUFBRSxLQUFLRSxZQUFZRixTQUFTLENBQUMsRUFBRSxHQUFHO0lBRXBGLE9BQU8sQ0FBQyxHQUFHWixxQkFBcUJTLE9BQU8sRUFBRVosT0FBT2tCLElBQUksQ0FBQyxTQUFVQyxJQUFJO1FBQ2pFLDhDQUE4QztRQUM5QyxJQUFJQSxLQUFLQyxJQUFJLEtBQUssY0FBYyxDQUFDUCxXQUFXUSxJQUFJLENBQUNGLEtBQUtuQixLQUFLLEdBQUc7UUFFOUQsK0NBQStDO1FBQy9DLElBQUlzQixXQUFXbkIscUJBQXFCUyxPQUFPLENBQUNXLFNBQVMsQ0FBQ0osS0FBS0ssS0FBSztRQUVoRSw0QkFBNEI7UUFDNUIsSUFBSUYsU0FBU0csT0FBTyxDQUFDLGVBQWUsS0FBS0gsU0FBU0csT0FBTyxDQUFDLFVBQVUsR0FBRztRQUV2RSxJQUFJQyxNQUFNckIsUUFBUXNCLE1BQU0sQ0FBQ0MsS0FBSyxDQUFDTjtRQUUvQixxRUFBcUU7UUFDckUsa0NBQWtDO1FBQ2xDLElBQUlPLGFBQWEsQ0FBQyxHQUFHdEIsVUFBVUssT0FBTyxFQUFFYyxLQUFLWjtRQUU3QyxrQ0FBa0M7UUFDbENLLEtBQUtDLElBQUksR0FBRztRQUNaRCxLQUFLbkIsS0FBSyxHQUFHLENBQUMsR0FBR1MsY0FBY0csT0FBTyxFQUFFTyxLQUFLbkIsS0FBSyxFQUFFNkIsWUFBWWY7SUFDbEUsR0FBRyxNQUFNZ0IsUUFBUTtBQUNuQjtBQUVBQyxPQUFPaEMsT0FBTyxHQUFHQSxPQUFPLENBQUMsVUFBVSIsInNvdXJjZXMiOlsid2VicGFjazovL2luY29tZS1leHBlbnNlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL3JlZHVjZS1jc3MtY2FsYy9kaXN0L2luZGV4LmpzPzViMmYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3Bvc3Rjc3NWYWx1ZVBhcnNlciA9IHJlcXVpcmUoJ3Bvc3Rjc3MtdmFsdWUtcGFyc2VyJyk7XG5cbnZhciBfcG9zdGNzc1ZhbHVlUGFyc2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3Rjc3NWYWx1ZVBhcnNlcik7XG5cbnZhciBfcGFyc2VyID0gcmVxdWlyZSgnLi9wYXJzZXInKTtcblxudmFyIF9yZWR1Y2VyID0gcmVxdWlyZSgnLi9saWIvcmVkdWNlcicpO1xuXG52YXIgX3JlZHVjZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVkdWNlcik7XG5cbnZhciBfc3RyaW5naWZpZXIgPSByZXF1aXJlKCcuL2xpYi9zdHJpbmdpZmllcicpO1xuXG52YXIgX3N0cmluZ2lmaWVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N0cmluZ2lmaWVyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLy8gZXNsaW50LWRpc2FibGUtbGluZVxudmFyIE1BVENIX0NBTEMgPSAvKCg/OlxcLVthLXpdK1xcLSk/Y2FsYykvO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdmFyIHByZWNpc2lvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogNTtcblxuICByZXR1cm4gKDAsIF9wb3N0Y3NzVmFsdWVQYXJzZXIyLmRlZmF1bHQpKHZhbHVlKS53YWxrKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgLy8gc2tpcCBhbnl0aGluZyB3aGljaCBpc24ndCBhIGNhbGMoKSBmdW5jdGlvblxuICAgIGlmIChub2RlLnR5cGUgIT09ICdmdW5jdGlvbicgfHwgIU1BVENIX0NBTEMudGVzdChub2RlLnZhbHVlKSkgcmV0dXJuO1xuXG4gICAgLy8gc3RyaW5naWZ5IGNhbGMgZXhwcmVzc2lvbiBhbmQgcHJvZHVjZSBhbiBBU1RcbiAgICB2YXIgY29udGVudHMgPSBfcG9zdGNzc1ZhbHVlUGFyc2VyMi5kZWZhdWx0LnN0cmluZ2lmeShub2RlLm5vZGVzKTtcblxuICAgIC8vIHNraXAgY29uc3RhbnQoKSBhbmQgZW52KClcbiAgICBpZiAoY29udGVudHMuaW5kZXhPZignY29uc3RhbnQnKSA+PSAwIHx8IGNvbnRlbnRzLmluZGV4T2YoJ2VudicpID49IDApIHJldHVybjtcblxuICAgIHZhciBhc3QgPSBfcGFyc2VyLnBhcnNlci5wYXJzZShjb250ZW50cyk7XG5cbiAgICAvLyByZWR1Y2UgQVNUIHRvIGl0cyBzaW1wbGVzdCBmb3JtLCB0aGF0IGlzLCBlaXRoZXIgdG8gYSBzaW5nbGUgdmFsdWVcbiAgICAvLyBvciBhIHNpbXBsaWZpZWQgY2FsYyBleHByZXNzaW9uXG4gICAgdmFyIHJlZHVjZWRBc3QgPSAoMCwgX3JlZHVjZXIyLmRlZmF1bHQpKGFzdCwgcHJlY2lzaW9uKTtcblxuICAgIC8vIHN0cmluZ2lmeSBBU1QgYW5kIHdyaXRlIGl0IGJhY2tcbiAgICBub2RlLnR5cGUgPSAnd29yZCc7XG4gICAgbm9kZS52YWx1ZSA9ICgwLCBfc3RyaW5naWZpZXIyLmRlZmF1bHQpKG5vZGUudmFsdWUsIHJlZHVjZWRBc3QsIHByZWNpc2lvbik7XG4gIH0sIHRydWUpLnRvU3RyaW5nKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJfcG9zdGNzc1ZhbHVlUGFyc2VyIiwicmVxdWlyZSIsIl9wb3N0Y3NzVmFsdWVQYXJzZXIyIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIl9wYXJzZXIiLCJfcmVkdWNlciIsIl9yZWR1Y2VyMiIsIl9zdHJpbmdpZmllciIsIl9zdHJpbmdpZmllcjIiLCJvYmoiLCJfX2VzTW9kdWxlIiwiZGVmYXVsdCIsIk1BVENIX0NBTEMiLCJwcmVjaXNpb24iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJ3YWxrIiwibm9kZSIsInR5cGUiLCJ0ZXN0IiwiY29udGVudHMiLCJzdHJpbmdpZnkiLCJub2RlcyIsImluZGV4T2YiLCJhc3QiLCJwYXJzZXIiLCJwYXJzZSIsInJlZHVjZWRBc3QiLCJ0b1N0cmluZyIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/reduce-css-calc/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/reduce-css-calc/dist/lib/convert.js":
/*!**********************************************************!*\
  !*** ./node_modules/reduce-css-calc/dist/lib/convert.js ***!
  \**********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _cssUnitConverter = __webpack_require__(/*! css-unit-converter */ \"(ssr)/./node_modules/css-unit-converter/index.js\");\nvar _cssUnitConverter2 = _interopRequireDefault(_cssUnitConverter);\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction convertNodes(left, right, precision) {\n    switch(left.type){\n        case \"LengthValue\":\n        case \"AngleValue\":\n        case \"TimeValue\":\n        case \"FrequencyValue\":\n        case \"ResolutionValue\":\n            return convertAbsoluteLength(left, right, precision);\n        default:\n            return {\n                left: left,\n                right: right\n            };\n    }\n}\nfunction convertAbsoluteLength(left, right, precision) {\n    if (right.type === left.type) {\n        right = {\n            type: left.type,\n            value: (0, _cssUnitConverter2.default)(right.value, right.unit, left.unit, precision),\n            unit: left.unit\n        };\n    }\n    return {\n        left: left,\n        right: right\n    };\n}\nexports[\"default\"] = convertNodes;\nmodule.exports = exports[\"default\"];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVkdWNlLWNzcy1jYWxjL2Rpc3QvbGliL2NvbnZlcnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQUEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBRUYsSUFBSUMsb0JBQW9CQyxtQkFBT0EsQ0FBQztBQUVoQyxJQUFJQyxxQkFBcUJDLHVCQUF1Qkg7QUFFaEQsU0FBU0csdUJBQXVCQyxHQUFHO0lBQUksT0FBT0EsT0FBT0EsSUFBSUMsVUFBVSxHQUFHRCxNQUFNO1FBQUVFLFNBQVNGO0lBQUk7QUFBRztBQUU5RixTQUFTRyxhQUFhQyxJQUFJLEVBQUVDLEtBQUssRUFBRUMsU0FBUztJQUMxQyxPQUFRRixLQUFLRyxJQUFJO1FBQ2YsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPQyxzQkFBc0JKLE1BQU1DLE9BQU9DO1FBQzVDO1lBQ0UsT0FBTztnQkFBRUYsTUFBTUE7Z0JBQU1DLE9BQU9BO1lBQU07SUFDdEM7QUFDRjtBQUVBLFNBQVNHLHNCQUFzQkosSUFBSSxFQUFFQyxLQUFLLEVBQUVDLFNBQVM7SUFDbkQsSUFBSUQsTUFBTUUsSUFBSSxLQUFLSCxLQUFLRyxJQUFJLEVBQUU7UUFDNUJGLFFBQVE7WUFDTkUsTUFBTUgsS0FBS0csSUFBSTtZQUNmWixPQUFPLENBQUMsR0FBR0csbUJBQW1CSSxPQUFPLEVBQUVHLE1BQU1WLEtBQUssRUFBRVUsTUFBTUksSUFBSSxFQUFFTCxLQUFLSyxJQUFJLEVBQUVIO1lBQzNFRyxNQUFNTCxLQUFLSyxJQUFJO1FBQ2pCO0lBQ0Y7SUFDQSxPQUFPO1FBQUVMLE1BQU1BO1FBQU1DLE9BQU9BO0lBQU07QUFDcEM7QUFFQVgsa0JBQWUsR0FBR1M7QUFDbEJPLE9BQU9oQixPQUFPLEdBQUdBLE9BQU8sQ0FBQyxVQUFVIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5jb21lLWV4cGVuc2UtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvcmVkdWNlLWNzcy1jYWxjL2Rpc3QvbGliL2NvbnZlcnQuanM/MTk1NiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3NzVW5pdENvbnZlcnRlciA9IHJlcXVpcmUoJ2Nzcy11bml0LWNvbnZlcnRlcicpO1xuXG52YXIgX2Nzc1VuaXRDb252ZXJ0ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3NzVW5pdENvbnZlcnRlcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGNvbnZlcnROb2RlcyhsZWZ0LCByaWdodCwgcHJlY2lzaW9uKSB7XG4gIHN3aXRjaCAobGVmdC50eXBlKSB7XG4gICAgY2FzZSAnTGVuZ3RoVmFsdWUnOlxuICAgIGNhc2UgJ0FuZ2xlVmFsdWUnOlxuICAgIGNhc2UgJ1RpbWVWYWx1ZSc6XG4gICAgY2FzZSAnRnJlcXVlbmN5VmFsdWUnOlxuICAgIGNhc2UgJ1Jlc29sdXRpb25WYWx1ZSc6XG4gICAgICByZXR1cm4gY29udmVydEFic29sdXRlTGVuZ3RoKGxlZnQsIHJpZ2h0LCBwcmVjaXNpb24pO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4geyBsZWZ0OiBsZWZ0LCByaWdodDogcmlnaHQgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb252ZXJ0QWJzb2x1dGVMZW5ndGgobGVmdCwgcmlnaHQsIHByZWNpc2lvbikge1xuICBpZiAocmlnaHQudHlwZSA9PT0gbGVmdC50eXBlKSB7XG4gICAgcmlnaHQgPSB7XG4gICAgICB0eXBlOiBsZWZ0LnR5cGUsXG4gICAgICB2YWx1ZTogKDAsIF9jc3NVbml0Q29udmVydGVyMi5kZWZhdWx0KShyaWdodC52YWx1ZSwgcmlnaHQudW5pdCwgbGVmdC51bml0LCBwcmVjaXNpb24pLFxuICAgICAgdW5pdDogbGVmdC51bml0XG4gICAgfTtcbiAgfVxuICByZXR1cm4geyBsZWZ0OiBsZWZ0LCByaWdodDogcmlnaHQgfTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gY29udmVydE5vZGVzO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiX2Nzc1VuaXRDb252ZXJ0ZXIiLCJyZXF1aXJlIiwiX2Nzc1VuaXRDb252ZXJ0ZXIyIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIm9iaiIsIl9fZXNNb2R1bGUiLCJkZWZhdWx0IiwiY29udmVydE5vZGVzIiwibGVmdCIsInJpZ2h0IiwicHJlY2lzaW9uIiwidHlwZSIsImNvbnZlcnRBYnNvbHV0ZUxlbmd0aCIsInVuaXQiLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/reduce-css-calc/dist/lib/convert.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/reduce-css-calc/dist/lib/reducer.js":
/*!**********************************************************!*\
  !*** ./node_modules/reduce-css-calc/dist/lib/reducer.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.flip = flip;\nvar _convert = __webpack_require__(/*! ./convert */ \"(ssr)/./node_modules/reduce-css-calc/dist/lib/convert.js\");\nvar _convert2 = _interopRequireDefault(_convert);\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction reduce(node, precision) {\n    if (node.type === \"MathExpression\") return reduceMathExpression(node, precision);\n    if (node.type === \"Calc\") return reduce(node.value, precision);\n    return node;\n}\nfunction isEqual(left, right) {\n    return left.type === right.type && left.value === right.value;\n}\nfunction isValueType(type) {\n    switch(type){\n        case \"LengthValue\":\n        case \"AngleValue\":\n        case \"TimeValue\":\n        case \"FrequencyValue\":\n        case \"ResolutionValue\":\n        case \"EmValue\":\n        case \"ExValue\":\n        case \"ChValue\":\n        case \"RemValue\":\n        case \"VhValue\":\n        case \"VwValue\":\n        case \"VminValue\":\n        case \"VmaxValue\":\n        case \"PercentageValue\":\n        case \"Value\":\n            return true;\n    }\n    return false;\n}\nfunction convertMathExpression(node, precision) {\n    var nodes = (0, _convert2.default)(node.left, node.right, precision);\n    var left = reduce(nodes.left, precision);\n    var right = reduce(nodes.right, precision);\n    if (left.type === \"MathExpression\" && right.type === \"MathExpression\") {\n        if (left.operator === \"/\" && right.operator === \"*\" || left.operator === \"-\" && right.operator === \"+\" || left.operator === \"*\" && right.operator === \"/\" || left.operator === \"+\" && right.operator === \"-\") {\n            if (isEqual(left.right, right.right)) nodes = (0, _convert2.default)(left.left, right.left, precision);\n            else if (isEqual(left.right, right.left)) nodes = (0, _convert2.default)(left.left, right.right, precision);\n            left = reduce(nodes.left, precision);\n            right = reduce(nodes.right, precision);\n        }\n    }\n    node.left = left;\n    node.right = right;\n    return node;\n}\nfunction flip(operator) {\n    return operator === \"+\" ? \"-\" : \"+\";\n}\nfunction flipValue(node) {\n    if (isValueType(node.type)) node.value = -node.value;\n    else if (node.type == \"MathExpression\") {\n        node.left = flipValue(node.left);\n        node.right = flipValue(node.right);\n    }\n    return node;\n}\nfunction reduceAddSubExpression(node, precision) {\n    var _node = node, left = _node.left, right = _node.right, op = _node.operator;\n    if (left.type === \"CssVariable\" || right.type === \"CssVariable\") return node;\n    // something + 0 => something\n    // something - 0 => something\n    if (right.value === 0) return left;\n    // 0 + something => something\n    if (left.value === 0 && op === \"+\") return right;\n    // 0 - something => -something\n    if (left.value === 0 && op === \"-\") return flipValue(right);\n    // value + value\n    // value - value\n    if (left.type === right.type && isValueType(left.type)) {\n        node = Object.assign({}, left);\n        if (op === \"+\") node.value = left.value + right.value;\n        else node.value = left.value - right.value;\n    }\n    // value <op> (expr)\n    if (isValueType(left.type) && (right.operator === \"+\" || right.operator === \"-\") && right.type === \"MathExpression\") {\n        // value + (value + something) => (value + value) + something\n        // value + (value - something) => (value + value) - something\n        // value - (value + something) => (value - value) - something\n        // value - (value - something) => (value - value) + something\n        if (left.type === right.left.type) {\n            node = Object.assign({}, node);\n            node.left = reduce({\n                type: \"MathExpression\",\n                operator: op,\n                left: left,\n                right: right.left\n            }, precision);\n            node.right = right.right;\n            node.operator = op === \"-\" ? flip(right.operator) : right.operator;\n            return reduce(node, precision);\n        } else if (left.type === right.right.type) {\n            node = Object.assign({}, node);\n            node.left = reduce({\n                type: \"MathExpression\",\n                operator: op === \"-\" ? flip(right.operator) : right.operator,\n                left: left,\n                right: right.right\n            }, precision);\n            node.right = right.left;\n            return reduce(node, precision);\n        }\n    }\n    // (expr) <op> value\n    if (left.type === \"MathExpression\" && (left.operator === \"+\" || left.operator === \"-\") && isValueType(right.type)) {\n        // (value + something) + value => (value + value) + something\n        // (value - something) + value => (value + value) - something\n        // (value + something) - value => (value - value) + something\n        // (value - something) - value => (value - value) - something\n        if (right.type === left.left.type) {\n            node = Object.assign({}, left);\n            node.left = reduce({\n                type: \"MathExpression\",\n                operator: op,\n                left: left.left,\n                right: right\n            }, precision);\n            return reduce(node, precision);\n        } else if (right.type === left.right.type) {\n            node = Object.assign({}, left);\n            if (left.operator === \"-\") {\n                node.right = reduce({\n                    type: \"MathExpression\",\n                    operator: op === \"-\" ? \"+\" : \"-\",\n                    left: right,\n                    right: left.right\n                }, precision);\n                node.operator = op === \"-\" ? \"-\" : \"+\";\n            } else {\n                node.right = reduce({\n                    type: \"MathExpression\",\n                    operator: op,\n                    left: left.right,\n                    right: right\n                }, precision);\n            }\n            if (node.right.value < 0) {\n                node.right.value *= -1;\n                node.operator = node.operator === \"-\" ? \"+\" : \"-\";\n            }\n            return reduce(node, precision);\n        }\n    }\n    return node;\n}\nfunction reduceDivisionExpression(node, precision) {\n    if (!isValueType(node.right.type)) return node;\n    if (node.right.type !== \"Value\") throw new Error('Cannot divide by \"' + node.right.unit + '\", number expected');\n    if (node.right.value === 0) throw new Error(\"Cannot divide by zero\");\n    // (expr) / value\n    if (node.left.type === \"MathExpression\") {\n        if (isValueType(node.left.left.type) && isValueType(node.left.right.type)) {\n            node.left.left.value /= node.right.value;\n            node.left.right.value /= node.right.value;\n            return reduce(node.left, precision);\n        }\n        return node;\n    } else if (isValueType(node.left.type)) {\n        node.left.value /= node.right.value;\n        return node.left;\n    }\n    return node;\n}\nfunction reduceMultiplicationExpression(node) {\n    // (expr) * value\n    if (node.left.type === \"MathExpression\" && node.right.type === \"Value\") {\n        if (isValueType(node.left.left.type) && isValueType(node.left.right.type)) {\n            node.left.left.value *= node.right.value;\n            node.left.right.value *= node.right.value;\n            return node.left;\n        }\n    } else if (isValueType(node.left.type) && node.right.type === \"Value\") {\n        node.left.value *= node.right.value;\n        return node.left;\n    } else if (node.left.type === \"Value\" && node.right.type === \"MathExpression\") {\n        if (isValueType(node.right.left.type) && isValueType(node.right.right.type)) {\n            node.right.left.value *= node.left.value;\n            node.right.right.value *= node.left.value;\n            return node.right;\n        }\n    } else if (node.left.type === \"Value\" && isValueType(node.right.type)) {\n        node.right.value *= node.left.value;\n        return node.right;\n    }\n    return node;\n}\nfunction reduceMathExpression(node, precision) {\n    node = convertMathExpression(node, precision);\n    switch(node.operator){\n        case \"+\":\n        case \"-\":\n            return reduceAddSubExpression(node, precision);\n        case \"/\":\n            return reduceDivisionExpression(node, precision);\n        case \"*\":\n            return reduceMultiplicationExpression(node);\n    }\n    return node;\n}\nexports[\"default\"] = reduce;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVkdWNlLWNzcy1jYWxjL2Rpc3QvbGliL3JlZHVjZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELFlBQVksR0FBR0U7QUFFZixJQUFJQyxXQUFXQyxtQkFBT0EsQ0FBQywyRUFBVztBQUVsQyxJQUFJQyxZQUFZQyx1QkFBdUJIO0FBRXZDLFNBQVNHLHVCQUF1QkMsR0FBRztJQUFJLE9BQU9BLE9BQU9BLElBQUlDLFVBQVUsR0FBR0QsTUFBTTtRQUFFRSxTQUFTRjtJQUFJO0FBQUc7QUFFOUYsU0FBU0csT0FBT0MsSUFBSSxFQUFFQyxTQUFTO0lBQzdCLElBQUlELEtBQUtFLElBQUksS0FBSyxrQkFBa0IsT0FBT0MscUJBQXFCSCxNQUFNQztJQUN0RSxJQUFJRCxLQUFLRSxJQUFJLEtBQUssUUFBUSxPQUFPSCxPQUFPQyxLQUFLVixLQUFLLEVBQUVXO0lBRXBELE9BQU9EO0FBQ1Q7QUFFQSxTQUFTSSxRQUFRQyxJQUFJLEVBQUVDLEtBQUs7SUFDMUIsT0FBT0QsS0FBS0gsSUFBSSxLQUFLSSxNQUFNSixJQUFJLElBQUlHLEtBQUtmLEtBQUssS0FBS2dCLE1BQU1oQixLQUFLO0FBQy9EO0FBRUEsU0FBU2lCLFlBQVlMLElBQUk7SUFDdkIsT0FBUUE7UUFDTixLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO0lBQ1g7SUFDQSxPQUFPO0FBQ1Q7QUFFQSxTQUFTTSxzQkFBc0JSLElBQUksRUFBRUMsU0FBUztJQUM1QyxJQUFJUSxRQUFRLENBQUMsR0FBR2YsVUFBVUksT0FBTyxFQUFFRSxLQUFLSyxJQUFJLEVBQUVMLEtBQUtN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O0lBRW5DLE9BQVFELEtBQUtVLFFBQVE7UUFDbkIsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPRSx1QkFBdUJaLE1BQU1DO1FBQ3RDLEtBQUs7WUFDSCxPQUFPZSx5QkFBeUJoQixNQUFNQztRQUN4QyxLQUFLO1lBQ0gsT0FBT2tCLCtCQUErQm5CO0lBQzFDO0lBQ0EsT0FBT0E7QUFDVDtBQUVBWCxrQkFBZSxHQUFHVSIsInNvdXJjZXMiOlsid2VicGFjazovL2luY29tZS1leHBlbnNlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL3JlZHVjZS1jc3MtY2FsYy9kaXN0L2xpYi9yZWR1Y2VyLmpzPzNkM2MiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmZsaXAgPSBmbGlwO1xuXG52YXIgX2NvbnZlcnQgPSByZXF1aXJlKFwiLi9jb252ZXJ0XCIpO1xuXG52YXIgX2NvbnZlcnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29udmVydCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIHJlZHVjZShub2RlLCBwcmVjaXNpb24pIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gXCJNYXRoRXhwcmVzc2lvblwiKSByZXR1cm4gcmVkdWNlTWF0aEV4cHJlc3Npb24obm9kZSwgcHJlY2lzaW9uKTtcbiAgaWYgKG5vZGUudHlwZSA9PT0gXCJDYWxjXCIpIHJldHVybiByZWR1Y2Uobm9kZS52YWx1ZSwgcHJlY2lzaW9uKTtcblxuICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gaXNFcXVhbChsZWZ0LCByaWdodCkge1xuICByZXR1cm4gbGVmdC50eXBlID09PSByaWdodC50eXBlICYmIGxlZnQudmFsdWUgPT09IHJpZ2h0LnZhbHVlO1xufVxuXG5mdW5jdGlvbiBpc1ZhbHVlVHlwZSh0eXBlKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ0xlbmd0aFZhbHVlJzpcbiAgICBjYXNlICdBbmdsZVZhbHVlJzpcbiAgICBjYXNlICdUaW1lVmFsdWUnOlxuICAgIGNhc2UgJ0ZyZXF1ZW5jeVZhbHVlJzpcbiAgICBjYXNlICdSZXNvbHV0aW9uVmFsdWUnOlxuICAgIGNhc2UgJ0VtVmFsdWUnOlxuICAgIGNhc2UgJ0V4VmFsdWUnOlxuICAgIGNhc2UgJ0NoVmFsdWUnOlxuICAgIGNhc2UgJ1JlbVZhbHVlJzpcbiAgICBjYXNlICdWaFZhbHVlJzpcbiAgICBjYXNlICdWd1ZhbHVlJzpcbiAgICBjYXNlICdWbWluVmFsdWUnOlxuICAgIGNhc2UgJ1ZtYXhWYWx1ZSc6XG4gICAgY2FzZSAnUGVyY2VudGFnZVZhbHVlJzpcbiAgICBjYXNlICdWYWx1ZSc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRNYXRoRXhwcmVzc2lvbihub2RlLCBwcmVjaXNpb24pIHtcbiAgdmFyIG5vZGVzID0gKDAsIF9jb252ZXJ0Mi5kZWZhdWx0KShub2RlLmxlZnQsIG5vZGUucmlnaHQsIHByZWNpc2lvbik7XG4gIHZhciBsZWZ0ID0gcmVkdWNlKG5vZGVzLmxlZnQsIHByZWNpc2lvbik7XG4gIHZhciByaWdodCA9IHJlZHVjZShub2Rlcy5yaWdodCwgcHJlY2lzaW9uKTtcblxuICBpZiAobGVmdC50eXBlID09PSBcIk1hdGhFeHByZXNzaW9uXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJNYXRoRXhwcmVzc2lvblwiKSB7XG5cbiAgICBpZiAobGVmdC5vcGVyYXRvciA9PT0gJy8nICYmIHJpZ2h0Lm9wZXJhdG9yID09PSAnKicgfHwgbGVmdC5vcGVyYXRvciA9PT0gJy0nICYmIHJpZ2h0Lm9wZXJhdG9yID09PSAnKycgfHwgbGVmdC5vcGVyYXRvciA9PT0gJyonICYmIHJpZ2h0Lm9wZXJhdG9yID09PSAnLycgfHwgbGVmdC5vcGVyYXRvciA9PT0gJysnICYmIHJpZ2h0Lm9wZXJhdG9yID09PSAnLScpIHtcblxuICAgICAgaWYgKGlzRXF1YWwobGVmdC5yaWdodCwgcmlnaHQucmlnaHQpKSBub2RlcyA9ICgwLCBfY29udmVydDIuZGVmYXVsdCkobGVmdC5sZWZ0LCByaWdodC5sZWZ0LCBwcmVjaXNpb24pO2Vsc2UgaWYgKGlzRXF1YWwobGVmdC5yaWdodCwgcmlnaHQubGVmdCkpIG5vZGVzID0gKDAsIF9jb252ZXJ0Mi5kZWZhdWx0KShsZWZ0LmxlZnQsIHJpZ2h0LnJpZ2h0LCBwcmVjaXNpb24pO1xuXG4gICAgICBsZWZ0ID0gcmVkdWNlKG5vZGVzLmxlZnQsIHByZWNpc2lvbik7XG4gICAgICByaWdodCA9IHJlZHVjZShub2Rlcy5yaWdodCwgcHJlY2lzaW9uKTtcbiAgICB9XG4gIH1cblxuICBub2RlLmxlZnQgPSBsZWZ0O1xuICBub2RlLnJpZ2h0ID0gcmlnaHQ7XG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBmbGlwKG9wZXJhdG9yKSB7XG4gIHJldHVybiBvcGVyYXRvciA9PT0gJysnID8gJy0nIDogJysnO1xufVxuXG5mdW5jdGlvbiBmbGlwVmFsdWUobm9kZSkge1xuICBpZiAoaXNWYWx1ZVR5cGUobm9kZS50eXBlKSkgbm9kZS52YWx1ZSA9IC1ub2RlLnZhbHVlO2Vsc2UgaWYgKG5vZGUudHlwZSA9PSAnTWF0aEV4cHJlc3Npb24nKSB7XG4gICAgbm9kZS5sZWZ0ID0gZmxpcFZhbHVlKG5vZGUubGVmdCk7XG4gICAgbm9kZS5yaWdodCA9IGZsaXBWYWx1ZShub2RlLnJpZ2h0KTtcbiAgfVxuICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gcmVkdWNlQWRkU3ViRXhwcmVzc2lvbihub2RlLCBwcmVjaXNpb24pIHtcbiAgdmFyIF9ub2RlID0gbm9kZSxcbiAgICAgIGxlZnQgPSBfbm9kZS5sZWZ0LFxuICAgICAgcmlnaHQgPSBfbm9kZS5yaWdodCxcbiAgICAgIG9wID0gX25vZGUub3BlcmF0b3I7XG5cblxuICBpZiAobGVmdC50eXBlID09PSAnQ3NzVmFyaWFibGUnIHx8IHJpZ2h0LnR5cGUgPT09ICdDc3NWYXJpYWJsZScpIHJldHVybiBub2RlO1xuXG4gIC8vIHNvbWV0aGluZyArIDAgPT4gc29tZXRoaW5nXG4gIC8vIHNvbWV0aGluZyAtIDAgPT4gc29tZXRoaW5nXG4gIGlmIChyaWdodC52YWx1ZSA9PT0gMCkgcmV0dXJuIGxlZnQ7XG5cbiAgLy8gMCArIHNvbWV0aGluZyA9PiBzb21ldGhpbmdcbiAgaWYgKGxlZnQudmFsdWUgPT09IDAgJiYgb3AgPT09IFwiK1wiKSByZXR1cm4gcmlnaHQ7XG5cbiAgLy8gMCAtIHNvbWV0aGluZyA9PiAtc29tZXRoaW5nXG4gIGlmIChsZWZ0LnZhbHVlID09PSAwICYmIG9wID09PSBcIi1cIikgcmV0dXJuIGZsaXBWYWx1ZShyaWdodCk7XG5cbiAgLy8gdmFsdWUgKyB2YWx1ZVxuICAvLyB2YWx1ZSAtIHZhbHVlXG4gIGlmIChsZWZ0LnR5cGUgPT09IHJpZ2h0LnR5cGUgJiYgaXNWYWx1ZVR5cGUobGVmdC50eXBlKSkge1xuICAgIG5vZGUgPSBPYmplY3QuYXNzaWduKHt9LCBsZWZ0KTtcbiAgICBpZiAob3AgPT09IFwiK1wiKSBub2RlLnZhbHVlID0gbGVmdC52YWx1ZSArIHJpZ2h0LnZhbHVlO2Vsc2Ugbm9kZS52YWx1ZSA9IGxlZnQudmFsdWUgLSByaWdodC52YWx1ZTtcbiAgfVxuXG4gIC8vIHZhbHVlIDxvcD4gKGV4cHIpXG4gIGlmIChpc1ZhbHVlVHlwZShsZWZ0LnR5cGUpICYmIChyaWdodC5vcGVyYXRvciA9PT0gJysnIHx8IHJpZ2h0Lm9wZXJhdG9yID09PSAnLScpICYmIHJpZ2h0LnR5cGUgPT09ICdNYXRoRXhwcmVzc2lvbicpIHtcbiAgICAvLyB2YWx1ZSArICh2YWx1ZSArIHNvbWV0aGluZykgPT4gKHZhbHVlICsgdmFsdWUpICsgc29tZXRoaW5nXG4gICAgLy8gdmFsdWUgKyAodmFsdWUgLSBzb21ldGhpbmcpID0+ICh2YWx1ZSArIHZhbHVlKSAtIHNvbWV0aGluZ1xuICAgIC8vIHZhbHVlIC0gKHZhbHVlICsgc29tZXRoaW5nKSA9PiAodmFsdWUgLSB2YWx1ZSkgLSBzb21ldGhpbmdcbiAgICAvLyB2YWx1ZSAtICh2YWx1ZSAtIHNvbWV0aGluZykgPT4gKHZhbHVlIC0gdmFsdWUpICsgc29tZXRoaW5nXG4gICAgaWYgKGxlZnQudHlwZSA9PT0gcmlnaHQubGVmdC50eXBlKSB7XG4gICAgICBub2RlID0gT2JqZWN0LmFzc2lnbih7fSwgbm9kZSk7XG4gICAgICBub2RlLmxlZnQgPSByZWR1Y2Uoe1xuICAgICAgICB0eXBlOiAnTWF0aEV4cHJlc3Npb24nLFxuICAgICAgICBvcGVyYXRvcjogb3AsXG4gICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgIHJpZ2h0OiByaWdodC5sZWZ0XG4gICAgICB9LCBwcmVjaXNpb24pO1xuICAgICAgbm9kZS5yaWdodCA9IHJpZ2h0LnJpZ2h0O1xuICAgICAgbm9kZS5vcGVyYXRvciA9IG9wID09PSAnLScgPyBmbGlwKHJpZ2h0Lm9wZXJhdG9yKSA6IHJpZ2h0Lm9wZXJhdG9yO1xuICAgICAgcmV0dXJuIHJlZHVjZShub2RlLCBwcmVjaXNpb24pO1xuICAgIH1cbiAgICAvLyB2YWx1ZSArIChzb21ldGhpbmcgKyB2YWx1ZSkgPT4gKHZhbHVlICsgdmFsdWUpICsgc29tZXRoaW5nXG4gICAgLy8gdmFsdWUgKyAoc29tZXRoaW5nIC0gdmFsdWUpID0+ICh2YWx1ZSAtIHZhbHVlKSArIHNvbWV0aGluZ1xuICAgIC8vIHZhbHVlIC0gKHNvbWV0aGluZyArIHZhbHVlKSA9PiAodmFsdWUgLSB2YWx1ZSkgLSBzb21ldGhpbmdcbiAgICAvLyB2YWx1ZSAtIChzb21ldGhpbmcgLSB2YWx1ZSkgPT4gKHZhbHVlICsgdmFsdWUpIC0gc29tZXRoaW5nXG4gICAgZWxzZSBpZiAobGVmdC50eXBlID09PSByaWdodC5yaWdodC50eXBlKSB7XG4gICAgICAgIG5vZGUgPSBPYmplY3QuYXNzaWduKHt9LCBub2RlKTtcbiAgICAgICAgbm9kZS5sZWZ0ID0gcmVkdWNlKHtcbiAgICAgICAgICB0eXBlOiAnTWF0aEV4cHJlc3Npb24nLFxuICAgICAgICAgIG9wZXJhdG9yOiBvcCA9PT0gJy0nID8gZmxpcChyaWdodC5vcGVyYXRvcikgOiByaWdodC5vcGVyYXRvcixcbiAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgIHJpZ2h0OiByaWdodC5yaWdodFxuICAgICAgICB9LCBwcmVjaXNpb24pO1xuICAgICAgICBub2RlLnJpZ2h0ID0gcmlnaHQubGVmdDtcbiAgICAgICAgcmV0dXJuIHJlZHVjZShub2RlLCBwcmVjaXNpb24pO1xuICAgICAgfVxuICB9XG5cbiAgLy8gKGV4cHIpIDxvcD4gdmFsdWVcbiAgaWYgKGxlZnQudHlwZSA9PT0gJ01hdGhFeHByZXNzaW9uJyAmJiAobGVmdC5vcGVyYXRvciA9PT0gJysnIHx8IGxlZnQub3BlcmF0b3IgPT09ICctJykgJiYgaXNWYWx1ZVR5cGUocmlnaHQudHlwZSkpIHtcbiAgICAvLyAodmFsdWUgKyBzb21ldGhpbmcpICsgdmFsdWUgPT4gKHZhbHVlICsgdmFsdWUpICsgc29tZXRoaW5nXG4gICAgLy8gKHZhbHVlIC0gc29tZXRoaW5nKSArIHZhbHVlID0+ICh2YWx1ZSArIHZhbHVlKSAtIHNvbWV0aGluZ1xuICAgIC8vICh2YWx1ZSArIHNvbWV0aGluZykgLSB2YWx1ZSA9PiAodmFsdWUgLSB2YWx1ZSkgKyBzb21ldGhpbmdcbiAgICAvLyAodmFsdWUgLSBzb21ldGhpbmcpIC0gdmFsdWUgPT4gKHZhbHVlIC0gdmFsdWUpIC0gc29tZXRoaW5nXG4gICAgaWYgKHJpZ2h0LnR5cGUgPT09IGxlZnQubGVmdC50eXBlKSB7XG4gICAgICBub2RlID0gT2JqZWN0LmFzc2lnbih7fSwgbGVmdCk7XG4gICAgICBub2RlLmxlZnQgPSByZWR1Y2Uoe1xuICAgICAgICB0eXBlOiAnTWF0aEV4cHJlc3Npb24nLFxuICAgICAgICBvcGVyYXRvcjogb3AsXG4gICAgICAgIGxlZnQ6IGxlZnQubGVmdCxcbiAgICAgICAgcmlnaHQ6IHJpZ2h0XG4gICAgICB9LCBwcmVjaXNpb24pO1xuICAgICAgcmV0dXJuIHJlZHVjZShub2RlLCBwcmVjaXNpb24pO1xuICAgIH1cbiAgICAvLyAoc29tZXRoaW5nICsgdmFsdWUpICsgdmFsdWUgPT4gc29tZXRoaW5nICsgKHZhbHVlICsgdmFsdWUpXG4gICAgLy8gKHNvbWV0aGluZyAtIHZhbHVlMSkgKyB2YWx1ZTIgPT4gc29tZXRoaW5nIC0gKHZhbHVlMiAtIHZhbHVlMSlcbiAgICAvLyAoc29tZXRoaW5nICsgdmFsdWUpIC0gdmFsdWUgPT4gc29tZXRoaW5nICsgKHZhbHVlIC0gdmFsdWUpXG4gICAgLy8gKHNvbWV0aGluZyAtIHZhbHVlKSAtIHZhbHVlID0+IHNvbWV0aGluZyAtICh2YWx1ZSArIHZhbHVlKVxuICAgIGVsc2UgaWYgKHJpZ2h0LnR5cGUgPT09IGxlZnQucmlnaHQudHlwZSkge1xuICAgICAgICBub2RlID0gT2JqZWN0LmFzc2lnbih7fSwgbGVmdCk7XG4gICAgICAgIGlmIChsZWZ0Lm9wZXJhdG9yID09PSAnLScpIHtcbiAgICAgICAgICBub2RlLnJpZ2h0ID0gcmVkdWNlKHtcbiAgICAgICAgICAgIHR5cGU6ICdNYXRoRXhwcmVzc2lvbicsXG4gICAgICAgICAgICBvcGVyYXRvcjogb3AgPT09ICctJyA/ICcrJyA6ICctJyxcbiAgICAgICAgICAgIGxlZnQ6IHJpZ2h0LFxuICAgICAgICAgICAgcmlnaHQ6IGxlZnQucmlnaHRcbiAgICAgICAgICB9LCBwcmVjaXNpb24pO1xuICAgICAgICAgIG5vZGUub3BlcmF0b3IgPSBvcCA9PT0gJy0nID8gJy0nIDogJysnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUucmlnaHQgPSByZWR1Y2Uoe1xuICAgICAgICAgICAgdHlwZTogJ01hdGhFeHByZXNzaW9uJyxcbiAgICAgICAgICAgIG9wZXJhdG9yOiBvcCxcbiAgICAgICAgICAgIGxlZnQ6IGxlZnQucmlnaHQsXG4gICAgICAgICAgICByaWdodDogcmlnaHRcbiAgICAgICAgICB9LCBwcmVjaXNpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLnJpZ2h0LnZhbHVlIDwgMCkge1xuICAgICAgICAgIG5vZGUucmlnaHQudmFsdWUgKj0gLTE7XG4gICAgICAgICAgbm9kZS5vcGVyYXRvciA9IG5vZGUub3BlcmF0b3IgPT09ICctJyA/ICcrJyA6ICctJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVkdWNlKG5vZGUsIHByZWNpc2lvbik7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIHJlZHVjZURpdmlzaW9uRXhwcmVzc2lvbihub2RlLCBwcmVjaXNpb24pIHtcbiAgaWYgKCFpc1ZhbHVlVHlwZShub2RlLnJpZ2h0LnR5cGUpKSByZXR1cm4gbm9kZTtcblxuICBpZiAobm9kZS5yaWdodC50eXBlICE9PSAnVmFsdWUnKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZGl2aWRlIGJ5IFxcXCJcIiArIG5vZGUucmlnaHQudW5pdCArIFwiXFxcIiwgbnVtYmVyIGV4cGVjdGVkXCIpO1xuXG4gIGlmIChub2RlLnJpZ2h0LnZhbHVlID09PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBkaXZpZGUgYnkgemVybycpO1xuXG4gIC8vIChleHByKSAvIHZhbHVlXG4gIGlmIChub2RlLmxlZnQudHlwZSA9PT0gJ01hdGhFeHByZXNzaW9uJykge1xuICAgIGlmIChpc1ZhbHVlVHlwZShub2RlLmxlZnQubGVmdC50eXBlKSAmJiBpc1ZhbHVlVHlwZShub2RlLmxlZnQucmlnaHQudHlwZSkpIHtcbiAgICAgIG5vZGUubGVmdC5sZWZ0LnZhbHVlIC89IG5vZGUucmlnaHQudmFsdWU7XG4gICAgICBub2RlLmxlZnQucmlnaHQudmFsdWUgLz0gbm9kZS5yaWdodC52YWx1ZTtcbiAgICAgIHJldHVybiByZWR1Y2Uobm9kZS5sZWZ0LCBwcmVjaXNpb24pO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICAvLyBzb21ldGhpbmcgLyB2YWx1ZVxuICBlbHNlIGlmIChpc1ZhbHVlVHlwZShub2RlLmxlZnQudHlwZSkpIHtcbiAgICAgIG5vZGUubGVmdC52YWx1ZSAvPSBub2RlLnJpZ2h0LnZhbHVlO1xuICAgICAgcmV0dXJuIG5vZGUubGVmdDtcbiAgICB9XG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiByZWR1Y2VNdWx0aXBsaWNhdGlvbkV4cHJlc3Npb24obm9kZSkge1xuICAvLyAoZXhwcikgKiB2YWx1ZVxuICBpZiAobm9kZS5sZWZ0LnR5cGUgPT09ICdNYXRoRXhwcmVzc2lvbicgJiYgbm9kZS5yaWdodC50eXBlID09PSAnVmFsdWUnKSB7XG4gICAgaWYgKGlzVmFsdWVUeXBlKG5vZGUubGVmdC5sZWZ0LnR5cGUpICYmIGlzVmFsdWVUeXBlKG5vZGUubGVmdC5yaWdodC50eXBlKSkge1xuICAgICAgbm9kZS5sZWZ0LmxlZnQudmFsdWUgKj0gbm9kZS5yaWdodC52YWx1ZTtcbiAgICAgIG5vZGUubGVmdC5yaWdodC52YWx1ZSAqPSBub2RlLnJpZ2h0LnZhbHVlO1xuICAgICAgcmV0dXJuIG5vZGUubGVmdDtcbiAgICB9XG4gIH1cbiAgLy8gc29tZXRoaW5nICogdmFsdWVcbiAgZWxzZSBpZiAoaXNWYWx1ZVR5cGUobm9kZS5sZWZ0LnR5cGUpICYmIG5vZGUucmlnaHQudHlwZSA9PT0gJ1ZhbHVlJykge1xuICAgICAgbm9kZS5sZWZ0LnZhbHVlICo9IG5vZGUucmlnaHQudmFsdWU7XG4gICAgICByZXR1cm4gbm9kZS5sZWZ0O1xuICAgIH1cbiAgICAvLyB2YWx1ZSAqIChleHByKVxuICAgIGVsc2UgaWYgKG5vZGUubGVmdC50eXBlID09PSAnVmFsdWUnICYmIG5vZGUucmlnaHQudHlwZSA9PT0gJ01hdGhFeHByZXNzaW9uJykge1xuICAgICAgICBpZiAoaXNWYWx1ZVR5cGUobm9kZS5yaWdodC5sZWZ0LnR5cGUpICYmIGlzVmFsdWVUeXBlKG5vZGUucmlnaHQucmlnaHQudHlwZSkpIHtcbiAgICAgICAgICBub2RlLnJpZ2h0LmxlZnQudmFsdWUgKj0gbm9kZS5sZWZ0LnZhbHVlO1xuICAgICAgICAgIG5vZGUucmlnaHQucmlnaHQudmFsdWUgKj0gbm9kZS5sZWZ0LnZhbHVlO1xuICAgICAgICAgIHJldHVybiBub2RlLnJpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyB2YWx1ZSAqIHNvbWV0aGluZ1xuICAgICAgZWxzZSBpZiAobm9kZS5sZWZ0LnR5cGUgPT09ICdWYWx1ZScgJiYgaXNWYWx1ZVR5cGUobm9kZS5yaWdodC50eXBlKSkge1xuICAgICAgICAgIG5vZGUucmlnaHQudmFsdWUgKj0gbm9kZS5sZWZ0LnZhbHVlO1xuICAgICAgICAgIHJldHVybiBub2RlLnJpZ2h0O1xuICAgICAgICB9XG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiByZWR1Y2VNYXRoRXhwcmVzc2lvbihub2RlLCBwcmVjaXNpb24pIHtcbiAgbm9kZSA9IGNvbnZlcnRNYXRoRXhwcmVzc2lvbihub2RlLCBwcmVjaXNpb24pO1xuXG4gIHN3aXRjaCAobm9kZS5vcGVyYXRvcikge1xuICAgIGNhc2UgXCIrXCI6XG4gICAgY2FzZSBcIi1cIjpcbiAgICAgIHJldHVybiByZWR1Y2VBZGRTdWJFeHByZXNzaW9uKG5vZGUsIHByZWNpc2lvbik7XG4gICAgY2FzZSBcIi9cIjpcbiAgICAgIHJldHVybiByZWR1Y2VEaXZpc2lvbkV4cHJlc3Npb24obm9kZSwgcHJlY2lzaW9uKTtcbiAgICBjYXNlIFwiKlwiOlxuICAgICAgcmV0dXJuIHJlZHVjZU11bHRpcGxpY2F0aW9uRXhwcmVzc2lvbihub2RlKTtcbiAgfVxuICByZXR1cm4gbm9kZTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gcmVkdWNlOyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImZsaXAiLCJfY29udmVydCIsInJlcXVpcmUiLCJfY29udmVydDIiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0Iiwib2JqIiwiX19lc01vZHVsZSIsImRlZmF1bHQiLCJyZWR1Y2UiLCJub2RlIiwicHJlY2lzaW9uIiwidHlwZSIsInJlZHVjZU1hdGhFeHByZXNzaW9uIiwiaXNFcXVhbCIsImxlZnQiLCJyaWdodCIsImlzVmFsdWVUeXBlIiwiY29udmVydE1hdGhFeHByZXNzaW9uIiwibm9kZXMiLCJvcGVyYXRvciIsImZsaXBWYWx1ZSIsInJlZHVjZUFkZFN1YkV4cHJlc3Npb24iLCJfbm9kZSIsIm9wIiwiYXNzaWduIiwicmVkdWNlRGl2aXNpb25FeHByZXNzaW9uIiwiRXJyb3IiLCJ1bml0IiwicmVkdWNlTXVsdGlwbGljYXRpb25FeHByZXNzaW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/reduce-css-calc/dist/lib/reducer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/reduce-css-calc/dist/lib/stringifier.js":
/*!**************************************************************!*\
  !*** ./node_modules/reduce-css-calc/dist/lib/stringifier.js ***!
  \**************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = function(calc, node, precision) {\n    var str = stringify(node, precision);\n    if (node.type === \"MathExpression\") {\n        // if calc expression couldn't be resolved to a single value, re-wrap it as\n        // a calc()\n        str = calc + \"(\" + str + \")\";\n    }\n    return str;\n};\nvar _reducer = __webpack_require__(/*! ./reducer */ \"(ssr)/./node_modules/reduce-css-calc/dist/lib/reducer.js\");\nvar order = {\n    \"*\": 0,\n    \"/\": 0,\n    \"+\": 1,\n    \"-\": 1\n};\nfunction round(value, prec) {\n    if (prec !== false) {\n        var precision = Math.pow(10, prec);\n        return Math.round(value * precision) / precision;\n    }\n    return value;\n}\nfunction stringify(node, prec) {\n    switch(node.type){\n        case \"MathExpression\":\n            {\n                var left = node.left, right = node.right, op = node.operator;\n                var str = \"\";\n                if (left.type === \"MathExpression\" && order[op] < order[left.operator]) str += \"(\" + stringify(left, prec) + \")\";\n                else str += stringify(left, prec);\n                str += \" \" + node.operator + \" \";\n                if (right.type === \"MathExpression\" && order[op] < order[right.operator]) {\n                    str += \"(\" + stringify(right, prec) + \")\";\n                } else if (right.type === \"MathExpression\" && op === \"-\" && [\n                    \"+\",\n                    \"-\"\n                ].includes(right.operator)) {\n                    // fix #52 : a-(b+c) = a-b-c\n                    right.operator = (0, _reducer.flip)(right.operator);\n                    str += stringify(right, prec);\n                } else {\n                    str += stringify(right, prec);\n                }\n                return str;\n            }\n        case \"Value\":\n            return round(node.value, prec);\n        case \"CssVariable\":\n            if (node.fallback) {\n                return \"var(\" + node.value + \", \" + stringify(node.fallback, prec, true) + \")\";\n            }\n            return \"var(\" + node.value + \")\";\n        case \"Calc\":\n            if (node.prefix) {\n                return \"-\" + node.prefix + \"-calc(\" + stringify(node.value, prec) + \")\";\n            }\n            return \"calc(\" + stringify(node.value, prec) + \")\";\n        default:\n            return round(node.value, prec) + node.unit;\n    }\n}\nmodule.exports = exports[\"default\"];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVkdWNlLWNzcy1jYWxjL2Rpc3QvbGliL3N0cmluZ2lmaWVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUVGRCxrQkFBZSxHQUFHLFNBQVVHLElBQUksRUFBRUMsSUFBSSxFQUFFQyxTQUFTO0lBQy9DLElBQUlDLE1BQU1DLFVBQVVILE1BQU1DO0lBRTFCLElBQUlELEtBQUtJLElBQUksS0FBSyxrQkFBa0I7UUFDbEMsMkVBQTJFO1FBQzNFLFdBQVc7UUFDWEYsTUFBTUgsT0FBTyxNQUFNRyxNQUFNO0lBQzNCO0lBQ0EsT0FBT0E7QUFDVDtBQUVBLElBQUlHLFdBQVdDLG1CQUFPQSxDQUFDLDJFQUFXO0FBRWxDLElBQUlDLFFBQVE7SUFDVixLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0FBQ1A7QUFFQSxTQUFTQyxNQUFNWCxLQUFLLEVBQUVZLElBQUk7SUFDeEIsSUFBSUEsU0FBUyxPQUFPO1FBQ2xCLElBQUlSLFlBQVlTLEtBQUtDLEdBQUcsQ0FBQyxJQUFJRjtRQUM3QixPQUFPQyxLQUFLRixLQUFLLENBQUNYLFFBQVFJLGFBQWFBO0lBQ3pDO0lBQ0EsT0FBT0o7QUFDVDtBQUVBLFNBQVNNLFVBQVVILElBQUksRUFBRVMsSUFBSTtJQUMzQixPQUFRVCxLQUFLSSxJQUFJO1FBQ2YsS0FBSztZQUNIO2dCQUNFLElBQUlRLE9BQU9aLEtBQUtZLElBQUksRUFDaEJDLFFBQVFiLEtBQUthLEtBQUssRUFDbEJDLEtBQUtkLEtBQUtlLFFBQVE7Z0JBRXRCLElBQUliLE1BQU07Z0JBRVYsSUFBSVUsS0FBS1IsSUFBSSxLQUFLLG9CQUFvQkcsS0FBSyxDQUFDTyxHQUFHLEdBQUdQLEtBQUssQ0FBQ0ssS0FBS0csUUFBUSxDQUFDLEVBQUViLE9BQU8sTUFBTUMsVUFBVVMsTUFBTUgsUUFBUTtxQkFBU1AsT0FBT0MsVUFBVVMsTUFBTUg7Z0JBRTdJUCxPQUFPLE1BQU1GLEtBQUtlLFFBQVEsR0FBRztnQkFFN0IsSUFBSUYsTUFBTVQsSUFBSSxLQUFLLG9CQUFvQkcsS0FBSyxDQUFDTyxHQUFHLEdBQUdQLEtBQUssQ0FBQ00sTUFBTUUsUUFBUSxDQUFDLEVBQUU7b0JBQ3hFYixPQUFPLE1BQU1DLFVBQVVVLE9BQU9KLFFBQVE7Z0JBQ3hDLE9BQU8sSUFBSUksTUFBTVQsSUFBSSxLQUFLLG9CQUFvQlUsT0FBTyxPQUFPO29CQUFDO29CQUFLO2lCQUFJLENBQUNFLFFBQVEsQ0FBQ0gsTUFBTUUsUUFBUSxHQUFHO29CQUMvRiw0QkFBNEI7b0JBQzVCRixNQUFNRSxRQUFRLEdBQUcsQ0FBQyxHQUFHVixTQUFTWSxJQUFJLEVBQUVKLE1BQU1FLFFBQVE7b0JBQ2xEYixPQUFPQyxVQUFVVSxPQUFPSjtnQkFDMUIsT0FBTztvQkFDTFAsT0FBT0MsVUFBVVUsT0FBT0o7Z0JBQzFCO2dCQUVBLE9BQU9QO1lBQ1Q7UUFDRixLQUFLO1lBQ0gsT0FBT00sTUFBTVIsS0FBS0gsS0FBSyxFQUFFWTtRQUMzQixLQUFLO1lBQ0gsSUFBSVQsS0FBS2tCLFFBQVEsRUFBRTtnQkFDakIsT0FBTyxTQUFTbEIsS0FBS0gsS0FBSyxHQUFHLE9BQU9NLFVBQVVILEtBQUtrQixRQUFRLEVBQUVULE1BQU0sUUFBUTtZQUM3RTtZQUNBLE9BQU8sU0FBU1QsS0FBS0gsS0FBSyxHQUFHO1FBQy9CLEtBQUs7WUFDSCxJQUFJRyxLQUFLbUIsTUFBTSxFQUFFO2dCQUNmLE9BQU8sTUFBTW5CLEtBQUttQixNQUFNLEdBQUcsV0FBV2hCLFVBQVVILEtBQUtILEtBQUssRUFBRVksUUFBUTtZQUN0RTtZQUNBLE9BQU8sVUFBVU4sVUFBVUgsS0FBS0gsS0FBSyxFQUFFWSxRQUFRO1FBQ2pEO1lBQ0UsT0FBT0QsTUFBTVIsS0FBS0gsS0FBSyxFQUFFWSxRQUFRVCxLQUFLb0IsSUFBSTtJQUM5QztBQUNGO0FBRUFDLE9BQU96QixPQUFPLEdBQUdBLE9BQU8sQ0FBQyxVQUFVIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5jb21lLWV4cGVuc2UtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvcmVkdWNlLWNzcy1jYWxjL2Rpc3QvbGliL3N0cmluZ2lmaWVyLmpzP2NmNmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChjYWxjLCBub2RlLCBwcmVjaXNpb24pIHtcbiAgdmFyIHN0ciA9IHN0cmluZ2lmeShub2RlLCBwcmVjaXNpb24pO1xuXG4gIGlmIChub2RlLnR5cGUgPT09IFwiTWF0aEV4cHJlc3Npb25cIikge1xuICAgIC8vIGlmIGNhbGMgZXhwcmVzc2lvbiBjb3VsZG4ndCBiZSByZXNvbHZlZCB0byBhIHNpbmdsZSB2YWx1ZSwgcmUtd3JhcCBpdCBhc1xuICAgIC8vIGEgY2FsYygpXG4gICAgc3RyID0gY2FsYyArIFwiKFwiICsgc3RyICsgXCIpXCI7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cbnZhciBfcmVkdWNlciA9IHJlcXVpcmUoXCIuL3JlZHVjZXJcIik7XG5cbnZhciBvcmRlciA9IHtcbiAgXCIqXCI6IDAsXG4gIFwiL1wiOiAwLFxuICBcIitcIjogMSxcbiAgXCItXCI6IDFcbn07XG5cbmZ1bmN0aW9uIHJvdW5kKHZhbHVlLCBwcmVjKSB7XG4gIGlmIChwcmVjICE9PSBmYWxzZSkge1xuICAgIHZhciBwcmVjaXNpb24gPSBNYXRoLnBvdygxMCwgcHJlYyk7XG4gICAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5KG5vZGUsIHByZWMpIHtcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIFwiTWF0aEV4cHJlc3Npb25cIjpcbiAgICAgIHtcbiAgICAgICAgdmFyIGxlZnQgPSBub2RlLmxlZnQsXG4gICAgICAgICAgICByaWdodCA9IG5vZGUucmlnaHQsXG4gICAgICAgICAgICBvcCA9IG5vZGUub3BlcmF0b3I7XG5cbiAgICAgICAgdmFyIHN0ciA9IFwiXCI7XG5cbiAgICAgICAgaWYgKGxlZnQudHlwZSA9PT0gJ01hdGhFeHByZXNzaW9uJyAmJiBvcmRlcltvcF0gPCBvcmRlcltsZWZ0Lm9wZXJhdG9yXSkgc3RyICs9IFwiKFwiICsgc3RyaW5naWZ5KGxlZnQsIHByZWMpICsgXCIpXCI7ZWxzZSBzdHIgKz0gc3RyaW5naWZ5KGxlZnQsIHByZWMpO1xuXG4gICAgICAgIHN0ciArPSBcIiBcIiArIG5vZGUub3BlcmF0b3IgKyBcIiBcIjtcblxuICAgICAgICBpZiAocmlnaHQudHlwZSA9PT0gJ01hdGhFeHByZXNzaW9uJyAmJiBvcmRlcltvcF0gPCBvcmRlcltyaWdodC5vcGVyYXRvcl0pIHtcbiAgICAgICAgICBzdHIgKz0gXCIoXCIgKyBzdHJpbmdpZnkocmlnaHQsIHByZWMpICsgXCIpXCI7XG4gICAgICAgIH0gZWxzZSBpZiAocmlnaHQudHlwZSA9PT0gJ01hdGhFeHByZXNzaW9uJyAmJiBvcCA9PT0gXCItXCIgJiYgW1wiK1wiLCBcIi1cIl0uaW5jbHVkZXMocmlnaHQub3BlcmF0b3IpKSB7XG4gICAgICAgICAgLy8gZml4ICM1MiA6IGEtKGIrYykgPSBhLWItY1xuICAgICAgICAgIHJpZ2h0Lm9wZXJhdG9yID0gKDAsIF9yZWR1Y2VyLmZsaXApKHJpZ2h0Lm9wZXJhdG9yKTtcbiAgICAgICAgICBzdHIgKz0gc3RyaW5naWZ5KHJpZ2h0LCBwcmVjKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgKz0gc3RyaW5naWZ5KHJpZ2h0LCBwcmVjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9XG4gICAgY2FzZSBcIlZhbHVlXCI6XG4gICAgICByZXR1cm4gcm91bmQobm9kZS52YWx1ZSwgcHJlYyk7XG4gICAgY2FzZSAnQ3NzVmFyaWFibGUnOlxuICAgICAgaWYgKG5vZGUuZmFsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIFwidmFyKFwiICsgbm9kZS52YWx1ZSArIFwiLCBcIiArIHN0cmluZ2lmeShub2RlLmZhbGxiYWNrLCBwcmVjLCB0cnVlKSArIFwiKVwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwidmFyKFwiICsgbm9kZS52YWx1ZSArIFwiKVwiO1xuICAgIGNhc2UgJ0NhbGMnOlxuICAgICAgaWYgKG5vZGUucHJlZml4KSB7XG4gICAgICAgIHJldHVybiBcIi1cIiArIG5vZGUucHJlZml4ICsgXCItY2FsYyhcIiArIHN0cmluZ2lmeShub2RlLnZhbHVlLCBwcmVjKSArIFwiKVwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwiY2FsYyhcIiArIHN0cmluZ2lmeShub2RlLnZhbHVlLCBwcmVjKSArIFwiKVwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gcm91bmQobm9kZS52YWx1ZSwgcHJlYykgKyBub2RlLnVuaXQ7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWZhdWx0IiwiY2FsYyIsIm5vZGUiLCJwcmVjaXNpb24iLCJzdHIiLCJzdHJpbmdpZnkiLCJ0eXBlIiwiX3JlZHVjZXIiLCJyZXF1aXJlIiwib3JkZXIiLCJyb3VuZCIsInByZWMiLCJNYXRoIiwicG93IiwibGVmdCIsInJpZ2h0Iiwib3AiLCJvcGVyYXRvciIsImluY2x1ZGVzIiwiZmxpcCIsImZhbGxiYWNrIiwicHJlZml4IiwidW5pdCIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/reduce-css-calc/dist/lib/stringifier.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/reduce-css-calc/dist/parser.js":
/*!*****************************************************!*\
  !*** ./node_modules/reduce-css-calc/dist/parser.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/* parser generated by jison 0.6.1-215 */ /*\n * Returns a Parser object of the following structure:\n *\n *  Parser: {\n *    yy: {}     The so-called \"shared state\" or rather the *source* of it;\n *               the real \"shared state\" `yy` passed around to\n *               the rule actions, etc. is a derivative/copy of this one,\n *               not a direct reference!\n *  }\n *\n *  Parser.prototype: {\n *    yy: {},\n *    EOF: 1,\n *    TERROR: 2,\n *\n *    trace: function(errorMessage, ...),\n *\n *    JisonParserError: function(msg, hash),\n *\n *    quoteName: function(name),\n *               Helper function which can be overridden by user code later on: put suitable\n *               quotes around literal IDs in a description string.\n *\n *    originalQuoteName: function(name),\n *               The basic quoteName handler provided by JISON.\n *               `cleanupAfterParse()` will clean up and reset `quoteName()` to reference this function\n *               at the end of the `parse()`.\n *\n *    describeSymbol: function(symbol),\n *               Return a more-or-less human-readable description of the given symbol, when\n *               available, or the symbol itself, serving as its own 'description' for lack\n *               of something better to serve up.\n *\n *               Return NULL when the symbol is unknown to the parser.\n *\n *    symbols_: {associative list: name ==> number},\n *    terminals_: {associative list: number ==> name},\n *    nonterminals: {associative list: rule-name ==> {associative list: number ==> rule-alt}},\n *    terminal_descriptions_: (if there are any) {associative list: number ==> description},\n *    productions_: [...],\n *\n *    performAction: function parser__performAction(yytext, yyleng, yylineno, yyloc, yystate, yysp, yyvstack, yylstack, yystack, yysstack),\n *\n *               The function parameters and `this` have the following value/meaning:\n *               - `this`    : reference to the `yyval` internal object, which has members (`$` and `_$`)\n *                             to store/reference the rule value `$$` and location info `@$`.\n *\n *                 One important thing to note about `this` a.k.a. `yyval`: every *reduce* action gets\n *                 to see the same object via the `this` reference, i.e. if you wish to carry custom\n *                 data from one reduce action through to the next within a single parse run, then you\n *                 may get nasty and use `yyval` a.k.a. `this` for storing you own semi-permanent data.\n *\n *                 `this.yy` is a direct reference to the `yy` shared state object.\n *\n *                 `%parse-param`-specified additional `parse()` arguments have been added to this `yy`\n *                 object at `parse()` start and are therefore available to the action code via the\n *                 same named `yy.xxxx` attributes (where `xxxx` represents a identifier name from\n *                 the %parse-param` list.\n *\n *               - `yytext`  : reference to the lexer value which belongs to the last lexer token used\n *                             to match this rule. This is *not* the look-ahead token, but the last token\n *                             that's actually part of this rule.\n *\n *                 Formulated another way, `yytext` is the value of the token immediately preceeding\n *                 the current look-ahead token.\n *                 Caveats apply for rules which don't require look-ahead, such as epsilon rules.\n *\n *               - `yyleng`  : ditto as `yytext`, only now for the lexer.yyleng value.\n *\n *               - `yylineno`: ditto as `yytext`, only now for the lexer.yylineno value.\n *\n *               - `yyloc`   : ditto as `yytext`, only now for the lexer.yylloc lexer token location info.\n *\n *                               WARNING: since jison 0.4.18-186 this entry may be NULL/UNDEFINED instead\n *                               of an empty object when no suitable location info can be provided.\n *\n *               - `yystate` : the current parser state number, used internally for dispatching and\n *                               executing the action code chunk matching the rule currently being reduced.\n *\n *               - `yysp`    : the current state stack position (a.k.a. 'stack pointer')\n *\n *                 This one comes in handy when you are going to do advanced things to the parser\n *                 stacks, all of which are accessible from your action code (see the next entries below).\n *\n *                 Also note that you can access this and other stack index values using the new double-hash\n *                 syntax, i.e. `##$ === ##0 === yysp`, while `##1` is the stack index for all things\n *                 related to the first rule term, just like you have `$1`, `@1` and `#1`.\n *                 This is made available to write very advanced grammar action rules, e.g. when you want\n *                 to investigate the parse state stack in your action code, which would, for example,\n *                 be relevant when you wish to implement error diagnostics and reporting schemes similar\n *                 to the work described here:\n *\n *                 + Pottier, F., 2016. Reachability and error diagnosis in LR(1) automata.\n *                   In Journes Francophones des Languages Applicatifs.\n *\n *                 + Jeffery, C.L., 2003. Generating LR syntax error messages from examples.\n *                   ACM Transactions on Programming Languages and Systems (TOPLAS), 25(5), pp.631640.\n *\n *               - `yyrulelength`: the current rule's term count, i.e. the number of entries occupied on the stack.\n *\n *                 This one comes in handy when you are going to do advanced things to the parser\n *                 stacks, all of which are accessible from your action code (see the next entries below).\n *\n *               - `yyvstack`: reference to the parser value stack. Also accessed via the `$1` etc.\n *                             constructs.\n *\n *               - `yylstack`: reference to the parser token location stack. Also accessed via\n *                             the `@1` etc. constructs.\n *\n *                             WARNING: since jison 0.4.18-186 this array MAY contain slots which are\n *                             UNDEFINED rather than an empty (location) object, when the lexer/parser\n *                             action code did not provide a suitable location info object when such a\n *                             slot was filled!\n *\n *               - `yystack` : reference to the parser token id stack. Also accessed via the\n *                             `#1` etc. constructs.\n *\n *                 Note: this is a bit of a **white lie** as we can statically decode any `#n` reference to\n *                 its numeric token id value, hence that code wouldn't need the `yystack` but *you* might\n *                 want access this array for your own purposes, such as error analysis as mentioned above!\n *\n *                 Note that this stack stores the current stack of *tokens*, that is the sequence of\n *                 already parsed=reduced *nonterminals* (tokens representing rules) and *terminals*\n *                 (lexer tokens *shifted* onto the stack until the rule they belong to is found and\n *                 *reduced*.\n *\n *               - `yysstack`: reference to the parser state stack. This one carries the internal parser\n *                             *states* such as the one in `yystate`, which are used to represent\n *                             the parser state machine in the *parse table*. *Very* *internal* stuff,\n *                             what can I say? If you access this one, you're clearly doing wicked things\n *\n *               - `...`     : the extra arguments you specified in the `%parse-param` statement in your\n *                             grammar definition file.\n *\n *    table: [...],\n *               State transition table\n *               ----------------------\n *\n *               index levels are:\n *               - `state`  --> hash table\n *               - `symbol` --> action (number or array)\n *\n *                 If the `action` is an array, these are the elements' meaning:\n *                 - index [0]: 1 = shift, 2 = reduce, 3 = accept\n *                 - index [1]: GOTO `state`\n *\n *                 If the `action` is a number, it is the GOTO `state`\n *\n *    defaultActions: {...},\n *\n *    parseError: function(str, hash, ExceptionClass),\n *    yyError: function(str, ...),\n *    yyRecovering: function(),\n *    yyErrOk: function(),\n *    yyClearIn: function(),\n *\n *    constructParseErrorInfo: function(error_message, exception_object, expected_token_set, is_recoverable),\n *               Helper function **which will be set up during the first invocation of the `parse()` method**.\n *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.\n *               See it's use in this parser kernel in many places; example usage:\n *\n *                   var infoObj = parser.constructParseErrorInfo('fail!', null,\n *                                     parser.collect_expected_token_set(state), true);\n *                   var retVal = parser.parseError(infoObj.errStr, infoObj, parser.JisonParserError);\n *\n *    originalParseError: function(str, hash, ExceptionClass),\n *               The basic `parseError` handler provided by JISON.\n *               `cleanupAfterParse()` will clean up and reset `parseError()` to reference this function\n *               at the end of the `parse()`.\n *\n *    options: { ... parser %options ... },\n *\n *    parse: function(input[, args...]),\n *               Parse the given `input` and return the parsed value (or `true` when none was provided by\n *               the root action, in which case the parser is acting as a *matcher*).\n *               You MAY use the additional `args...` parameters as per `%parse-param` spec of this grammar:\n *               these extra `args...` are added verbatim to the `yy` object reference as member variables.\n *\n *               WARNING:\n *               Parser's additional `args...` parameters (via `%parse-param`) MAY conflict with\n *               any attributes already added to `yy` by the jison run-time;\n *               when such a collision is detected an exception is thrown to prevent the generated run-time\n *               from silently accepting this confusing and potentially hazardous situation!\n *\n *               The lexer MAY add its own set of additional parameters (via the `%parse-param` line in\n *               the lexer section of the grammar spec): these will be inserted in the `yy` shared state\n *               object and any collision with those will be reported by the lexer via a thrown exception.\n *\n *    cleanupAfterParse: function(resultValue, invoke_post_methods, do_not_nuke_errorinfos),\n *               Helper function **which will be set up during the first invocation of the `parse()` method**.\n *               This helper API is invoked at the end of the `parse()` call, unless an exception was thrown\n *               and `%options no-try-catch` has been defined for this grammar: in that case this helper MAY\n *               be invoked by calling user code to ensure the `post_parse` callbacks are invoked and\n *               the internal parser gets properly garbage collected under these particular circumstances.\n *\n *    yyMergeLocationInfo: function(first_index, last_index, first_yylloc, last_yylloc, dont_look_back),\n *               Helper function **which will be set up during the first invocation of the `parse()` method**.\n *               This helper API can be invoked to calculate a spanning `yylloc` location info object.\n *\n *               Note: %epsilon rules MAY specify no `first_index` and `first_yylloc`, in which case\n *               this function will attempt to obtain a suitable location marker by inspecting the location stack\n *               backwards.\n *\n *               For more info see the documentation comment further below, immediately above this function's\n *               implementation.\n *\n *    lexer: {\n *        yy: {...},           A reference to the so-called \"shared state\" `yy` once\n *                             received via a call to the `.setInput(input, yy)` lexer API.\n *        EOF: 1,\n *        ERROR: 2,\n *        JisonLexerError: function(msg, hash),\n *        parseError: function(str, hash, ExceptionClass),\n *        setInput: function(input, [yy]),\n *        input: function(),\n *        unput: function(str),\n *        more: function(),\n *        reject: function(),\n *        less: function(n),\n *        pastInput: function(n),\n *        upcomingInput: function(n),\n *        showPosition: function(),\n *        test_match: function(regex_match_array, rule_index, ...),\n *        next: function(...),\n *        lex: function(...),\n *        begin: function(condition),\n *        pushState: function(condition),\n *        popState: function(),\n *        topState: function(),\n *        _currentRules: function(),\n *        stateStackSize: function(),\n *        cleanupAfterLex: function()\n *\n *        options: { ... lexer %options ... },\n *\n *        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START, ...),\n *        rules: [...],\n *        conditions: {associative list: name ==> set},\n *    }\n *  }\n *\n *\n *  token location info (@$, _$, etc.): {\n *    first_line: n,\n *    last_line: n,\n *    first_column: n,\n *    last_column: n,\n *    range: [start_number, end_number]\n *               (where the numbers are indexes into the input string, zero-based)\n *  }\n *\n * ---\n *\n * The `parseError` function receives a 'hash' object with these members for lexer and\n * parser errors:\n *\n *  {\n *    text:        (matched text)\n *    token:       (the produced terminal token, if any)\n *    token_id:    (the produced terminal token numeric ID, if any)\n *    line:        (yylineno)\n *    loc:         (yylloc)\n *  }\n *\n * parser (grammar) errors will also provide these additional members:\n *\n *  {\n *    expected:    (array describing the set of expected tokens;\n *                  may be UNDEFINED when we cannot easily produce such a set)\n *    state:       (integer (or array when the table includes grammar collisions);\n *                  represents the current internal state of the parser kernel.\n *                  can, for example, be used to pass to the `collect_expected_token_set()`\n *                  API to obtain the expected token set)\n *    action:      (integer; represents the current internal action which will be executed)\n *    new_state:   (integer; represents the next/planned internal state, once the current\n *                  action has executed)\n *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule\n *                  available for this particular error)\n *    state_stack: (array: the current parser LALR/LR internal state stack; this can be used,\n *                  for instance, for advanced error analysis and reporting)\n *    value_stack: (array: the current parser LALR/LR internal `$$` value stack; this can be used,\n *                  for instance, for advanced error analysis and reporting)\n *    location_stack: (array: the current parser LALR/LR internal location stack; this can be used,\n *                  for instance, for advanced error analysis and reporting)\n *    yy:          (object: the current parser internal \"shared state\" `yy`\n *                  as is also available in the rule actions; this can be used,\n *                  for instance, for advanced error analysis and reporting)\n *    lexer:       (reference to the current lexer instance used by the parser)\n *    parser:      (reference to the current parser instance)\n *  }\n *\n * while `this` will reference the current parser instance.\n *\n * When `parseError` is invoked by the lexer, `this` will still reference the related *parser*\n * instance, while these additional `hash` fields will also be provided:\n *\n *  {\n *    lexer:       (reference to the current lexer instance which reported the error)\n *  }\n *\n * When `parseError` is invoked by the parser due to a **JavaScript exception** being fired\n * from either the parser or lexer, `this` will still reference the related *parser*\n * instance, while these additional `hash` fields will also be provided:\n *\n *  {\n *    exception:   (reference to the exception thrown)\n *  }\n *\n * Please do note that in the latter situation, the `expected` field will be omitted as\n * this type of failure is assumed not to be due to *parse errors* but rather due to user\n * action code in either parser or lexer failing unexpectedly.\n *\n * ---\n *\n * You can specify parser options by setting / modifying the `.yy` object of your Parser instance.\n * These options are available:\n *\n * ### options which are global for all parser instances\n *\n *  Parser.pre_parse: function(yy)\n *                 optional: you can specify a pre_parse() function in the chunk following\n *                 the grammar, i.e. after the last `%%`.\n *  Parser.post_parse: function(yy, retval, parseInfo) { return retval; }\n *                 optional: you can specify a post_parse() function in the chunk following\n *                 the grammar, i.e. after the last `%%`. When it does not return any value,\n *                 the parser will return the original `retval`.\n *\n * ### options which can be set up per parser instance\n *\n *  yy: {\n *      pre_parse:  function(yy)\n *                 optional: is invoked before the parse cycle starts (and before the first\n *                 invocation of `lex()`) but immediately after the invocation of\n *                 `parser.pre_parse()`).\n *      post_parse: function(yy, retval, parseInfo) { return retval; }\n *                 optional: is invoked when the parse terminates due to success ('accept')\n *                 or failure (even when exceptions are thrown).\n *                 `retval` contains the return value to be produced by `Parser.parse()`;\n *                 this function can override the return value by returning another.\n *                 When it does not return any value, the parser will return the original\n *                 `retval`.\n *                 This function is invoked immediately before `parser.post_parse()`.\n *\n *      parseError: function(str, hash, ExceptionClass)\n *                 optional: overrides the default `parseError` function.\n *      quoteName: function(name),\n *                 optional: overrides the default `quoteName` function.\n *  }\n *\n *  parser.lexer.options: {\n *      pre_lex:  function()\n *                 optional: is invoked before the lexer is invoked to produce another token.\n *                 `this` refers to the Lexer object.\n *      post_lex: function(token) { return token; }\n *                 optional: is invoked when the lexer has produced a token `token`;\n *                 this function can override the returned token value by returning another.\n *                 When it does not return any (truthy) value, the lexer will return\n *                 the original `token`.\n *                 `this` refers to the Lexer object.\n *\n *      ranges: boolean\n *                 optional: `true` ==> token location info will include a .range[] member.\n *      flex: boolean\n *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested\n *                 exhaustively to find the longest match.\n *      backtrack_lexer: boolean\n *                 optional: `true` ==> lexer regexes are tested in order and for invoked;\n *                 the lexer terminates the scan when a token is returned by the action code.\n *      xregexp: boolean\n *                 optional: `true` ==> lexer rule regexes are \"extended regex format\" requiring the\n *                 `XRegExp` library. When this `%option` has not been specified at compile time, all lexer\n *                 rule regexes have been written as standard JavaScript RegExp expressions.\n *  }\n */ var parser = function() {\n    // See also:\n    // http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508\n    // but we keep the prototype.constructor and prototype.name assignment lines too for compatibility\n    // with userland code which might access the derived class in a 'classic' way.\n    function JisonParserError(msg, hash) {\n        Object.defineProperty(this, \"name\", {\n            enumerable: false,\n            writable: false,\n            value: \"JisonParserError\"\n        });\n        if (msg == null) msg = \"???\";\n        Object.defineProperty(this, \"message\", {\n            enumerable: false,\n            writable: true,\n            value: msg\n        });\n        this.hash = hash;\n        var stacktrace;\n        if (hash && hash.exception instanceof Error) {\n            var ex2 = hash.exception;\n            this.message = ex2.message || msg;\n            stacktrace = ex2.stack;\n        }\n        if (!stacktrace) {\n            if (Error.hasOwnProperty(\"captureStackTrace\")) {\n                Error.captureStackTrace(this, this.constructor);\n            } else {\n                stacktrace = new Error(msg).stack;\n            }\n        }\n        if (stacktrace) {\n            Object.defineProperty(this, \"stack\", {\n                enumerable: false,\n                writable: false,\n                value: stacktrace\n            });\n        }\n    }\n    if (typeof Object.setPrototypeOf === \"function\") {\n        Object.setPrototypeOf(JisonParserError.prototype, Error.prototype);\n    } else {\n        JisonParserError.prototype = Object.create(Error.prototype);\n    }\n    JisonParserError.prototype.constructor = JisonParserError;\n    JisonParserError.prototype.name = \"JisonParserError\";\n    // helper: reconstruct the productions[] table\n    function bp(s) {\n        var rv = [];\n        var p = s.pop;\n        var r = s.rule;\n        for(var i = 0, l = p.length; i < l; i++){\n            rv.push([\n                p[i],\n                r[i]\n            ]);\n        }\n        return rv;\n    }\n    // helper: reconstruct the defaultActions[] table\n    function bda(s) {\n        var rv = {};\n        var d = s.idx;\n        var g = s.goto;\n        for(var i = 0, l = d.length; i < l; i++){\n            var j = d[i];\n            rv[j] = g[i];\n        }\n        return rv;\n    }\n    // helper: reconstruct the 'goto' table\n    function bt(s) {\n        var rv = [];\n        var d = s.len;\n        var y = s.symbol;\n        var t = s.type;\n        var a = s.state;\n        var m = s.mode;\n        var g = s.goto;\n        for(var i = 0, l = d.length; i < l; i++){\n            var n = d[i];\n            var q = {};\n            for(var j = 0; j < n; j++){\n                var z = y.shift();\n                switch(t.shift()){\n                    case 2:\n                        q[z] = [\n                            m.shift(),\n                            g.shift()\n                        ];\n                        break;\n                    case 0:\n                        q[z] = a.shift();\n                        break;\n                    default:\n                        // type === 1: accept\n                        q[z] = [\n                            3\n                        ];\n                }\n            }\n            rv.push(q);\n        }\n        return rv;\n    }\n    // helper: runlength encoding with increment step: code, length: step (default step = 0)\n    // `this` references an array\n    function s(c, l, a) {\n        a = a || 0;\n        for(var i = 0; i < l; i++){\n            this.push(c);\n            c += a;\n        }\n    }\n    // helper: duplicate sequence from *relative* offset and length.\n    // `this` references an array\n    function c(i, l) {\n        i = this.length - i;\n        for(l += i; i < l; i++){\n            this.push(this[i]);\n        }\n    }\n    // helper: unpack an array using helpers and data, all passed in an array argument 'a'.\n    function u(a) {\n        var rv = [];\n        for(var i = 0, l = a.length; i < l; i++){\n            var e = a[i];\n            // Is this entry a helper function?\n            if (typeof e === \"function\") {\n                i++;\n                e.apply(rv, a[i]);\n            } else {\n                rv.push(e);\n            }\n        }\n        return rv;\n    }\n    var parser = {\n        // Code Generator Information Report\n        // ---------------------------------\n        //\n        // Options:\n        //\n        //   default action mode: ............. [\"classic\",\"merge\"]\n        //   test-compile action mode: ........ \"parser:*,lexer:*\"\n        //   try..catch: ...................... true\n        //   default resolve on conflict: ..... true\n        //   on-demand look-ahead: ............ false\n        //   error recovery token skip maximum: 3\n        //   yyerror in parse actions is: ..... NOT recoverable,\n        //   yyerror in lexer actions and other non-fatal lexer are:\n        //   .................................. NOT recoverable,\n        //   debug grammar/output: ............ false\n        //   has partial LR conflict upgrade:   true\n        //   rudimentary token-stack support:   false\n        //   parser table compression mode: ... 2\n        //   export debug tables: ............. false\n        //   export *all* tables: ............. false\n        //   module type: ..................... commonjs\n        //   parser engine type: .............. lalr\n        //   output main() in the module: ..... true\n        //   has user-specified main(): ....... false\n        //   has user-specified require()/import modules for main():\n        //   .................................. false\n        //   number of expected conflicts: .... 0\n        //\n        //\n        // Parser Analysis flags:\n        //\n        //   no significant actions (parser is a language matcher only):\n        //   .................................. false\n        //   uses yyleng: ..................... false\n        //   uses yylineno: ................... false\n        //   uses yytext: ..................... false\n        //   uses yylloc: ..................... false\n        //   uses ParseError API: ............. false\n        //   uses YYERROR: .................... false\n        //   uses YYRECOVERING: ............... false\n        //   uses YYERROK: .................... false\n        //   uses YYCLEARIN: .................. false\n        //   tracks rule values: .............. true\n        //   assigns rule values: ............. true\n        //   uses location tracking: .......... false\n        //   assigns location: ................ false\n        //   uses yystack: .................... false\n        //   uses yysstack: ................... false\n        //   uses yysp: ....................... true\n        //   uses yyrulelength: ............... false\n        //   uses yyMergeLocationInfo API: .... false\n        //   has error recovery: .............. false\n        //   has error reporting: ............. false\n        //\n        // --------- END OF REPORT -----------\n        trace: function no_op_trace() {},\n        JisonParserError: JisonParserError,\n        yy: {},\n        options: {\n            type: \"lalr\",\n            hasPartialLrUpgradeOnConflict: true,\n            errorRecoveryTokenDiscardCount: 3\n        },\n        symbols_: {\n            \"$accept\": 0,\n            \"$end\": 1,\n            \"ADD\": 3,\n            \"ANGLE\": 16,\n            \"CHS\": 22,\n            \"COMMA\": 14,\n            \"CSS_CPROP\": 13,\n            \"CSS_VAR\": 12,\n            \"DIV\": 6,\n            \"EMS\": 20,\n            \"EOF\": 1,\n            \"EXS\": 21,\n            \"FREQ\": 18,\n            \"LENGTH\": 15,\n            \"LPAREN\": 7,\n            \"MUL\": 5,\n            \"NESTED_CALC\": 9,\n            \"NUMBER\": 11,\n            \"PERCENTAGE\": 28,\n            \"PREFIX\": 10,\n            \"REMS\": 23,\n            \"RES\": 19,\n            \"RPAREN\": 8,\n            \"SUB\": 4,\n            \"TIME\": 17,\n            \"VHS\": 24,\n            \"VMAXS\": 27,\n            \"VMINS\": 26,\n            \"VWS\": 25,\n            \"css_value\": 33,\n            \"css_variable\": 32,\n            \"error\": 2,\n            \"expression\": 29,\n            \"math_expression\": 30,\n            \"value\": 31\n        },\n        terminals_: {\n            1: \"EOF\",\n            2: \"error\",\n            3: \"ADD\",\n            4: \"SUB\",\n            5: \"MUL\",\n            6: \"DIV\",\n            7: \"LPAREN\",\n            8: \"RPAREN\",\n            9: \"NESTED_CALC\",\n            10: \"PREFIX\",\n            11: \"NUMBER\",\n            12: \"CSS_VAR\",\n            13: \"CSS_CPROP\",\n            14: \"COMMA\",\n            15: \"LENGTH\",\n            16: \"ANGLE\",\n            17: \"TIME\",\n            18: \"FREQ\",\n            19: \"RES\",\n            20: \"EMS\",\n            21: \"EXS\",\n            22: \"CHS\",\n            23: \"REMS\",\n            24: \"VHS\",\n            25: \"VWS\",\n            26: \"VMINS\",\n            27: \"VMAXS\",\n            28: \"PERCENTAGE\"\n        },\n        TERROR: 2,\n        EOF: 1,\n        // internals: defined here so the object *structure* doesn't get modified by parse() et al,\n        // thus helping JIT compilers like Chrome V8.\n        originalQuoteName: null,\n        originalParseError: null,\n        cleanupAfterParse: null,\n        constructParseErrorInfo: null,\n        yyMergeLocationInfo: null,\n        __reentrant_call_depth: 0,\n        __error_infos: [],\n        __error_recovery_infos: [],\n        // APIs which will be set up depending on user action code analysis:\n        //yyRecovering: 0,\n        //yyErrOk: 0,\n        //yyClearIn: 0,\n        // Helper APIs\n        // -----------\n        // Helper function which can be overridden by user code later on: put suitable quotes around\n        // literal IDs in a description string.\n        quoteName: function parser_quoteName(id_str) {\n            return '\"' + id_str + '\"';\n        },\n        // Return the name of the given symbol (terminal or non-terminal) as a string, when available.\n        //\n        // Return NULL when the symbol is unknown to the parser.\n        getSymbolName: function parser_getSymbolName(symbol) {\n            if (this.terminals_[symbol]) {\n                return this.terminals_[symbol];\n            }\n            // Otherwise... this might refer to a RULE token i.e. a non-terminal: see if we can dig that one up.\n            //\n            // An example of this may be where a rule's action code contains a call like this:\n            //\n            //      parser.getSymbolName(#$)\n            //\n            // to obtain a human-readable name of the current grammar rule.\n            var s = this.symbols_;\n            for(var key in s){\n                if (s[key] === symbol) {\n                    return key;\n                }\n            }\n            return null;\n        },\n        // Return a more-or-less human-readable description of the given symbol, when available,\n        // or the symbol itself, serving as its own 'description' for lack of something better to serve up.\n        //\n        // Return NULL when the symbol is unknown to the parser.\n        describeSymbol: function parser_describeSymbol(symbol) {\n            if (symbol !== this.EOF && this.terminal_descriptions_ && this.terminal_descriptions_[symbol]) {\n                return this.terminal_descriptions_[symbol];\n            } else if (symbol === this.EOF) {\n                return \"end of input\";\n            }\n            var id = this.getSymbolName(symbol);\n            if (id) {\n                return this.quoteName(id);\n            }\n            return null;\n        },\n        // Produce a (more or less) human-readable list of expected tokens at the point of failure.\n        //\n        // The produced list may contain token or token set descriptions instead of the tokens\n        // themselves to help turning this output into something that easier to read by humans\n        // unless `do_not_describe` parameter is set, in which case a list of the raw, *numeric*,\n        // expected terminals and nonterminals is produced.\n        //\n        // The returned list (array) will not contain any duplicate entries.\n        collect_expected_token_set: function parser_collect_expected_token_set(state, do_not_describe) {\n            var TERROR = this.TERROR;\n            var tokenset = [];\n            var check = {};\n            // Has this (error?) state been outfitted with a custom expectations description text for human consumption?\n            // If so, use that one instead of the less palatable token set.\n            if (!do_not_describe && this.state_descriptions_ && this.state_descriptions_[state]) {\n                return [\n                    this.state_descriptions_[state]\n                ];\n            }\n            for(var p in this.table[state]){\n                p = +p;\n                if (p !== TERROR) {\n                    var d = do_not_describe ? p : this.describeSymbol(p);\n                    if (d && !check[d]) {\n                        tokenset.push(d);\n                        check[d] = true; // Mark this token description as already mentioned to prevent outputting duplicate entries.\n                    }\n                }\n            }\n            return tokenset;\n        },\n        productions_: bp({\n            pop: u([\n                29,\n                s,\n                [\n                    30,\n                    10\n                ],\n                31,\n                31,\n                32,\n                32,\n                s,\n                [\n                    33,\n                    15\n                ]\n            ]),\n            rule: u([\n                2,\n                s,\n                [\n                    3,\n                    5\n                ],\n                4,\n                7,\n                s,\n                [\n                    1,\n                    4\n                ],\n                2,\n                4,\n                6,\n                s,\n                [\n                    1,\n                    14\n                ],\n                2\n            ])\n        }),\n        performAction: function parser__PerformAction(yystate /* action[1] */ , yysp, yyvstack) {\n            /* this == yyval */ // the JS engine itself can go and remove these statements when `yy` turns out to be unused in any action code!\n            var yy = this.yy;\n            var yyparser = yy.parser;\n            var yylexer = yy.lexer;\n            switch(yystate){\n                case 0:\n                    /*! Production::    $accept : expression $end */ // default action (generated by JISON mode classic/merge :: 1,VT,VA,-,-,-,-,-,-):\n                    this.$ = yyvstack[yysp - 1];\n                    break;\n                case 1:\n                    /*! Production::    expression : math_expression EOF */ // default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,-,-,-,-):\n                    this.$ = yyvstack[yysp - 1];\n                    // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,-,-,-,-)\n                    return yyvstack[yysp - 1];\n                    break;\n                case 2:\n                /*! Production::    math_expression : math_expression ADD math_expression */ case 3:\n                /*! Production::    math_expression : math_expression SUB math_expression */ case 4:\n                /*! Production::    math_expression : math_expression MUL math_expression */ case 5:\n                    /*! Production::    math_expression : math_expression DIV math_expression */ this.$ = {\n                        type: \"MathExpression\",\n                        operator: yyvstack[yysp - 1],\n                        left: yyvstack[yysp - 2],\n                        right: yyvstack[yysp]\n                    };\n                    break;\n                case 6:\n                    /*! Production::    math_expression : LPAREN math_expression RPAREN */ this.$ = yyvstack[yysp - 1];\n                    break;\n                case 7:\n                    /*! Production::    math_expression : NESTED_CALC LPAREN math_expression RPAREN */ this.$ = {\n                        type: \"Calc\",\n                        value: yyvstack[yysp - 1]\n                    };\n                    break;\n                case 8:\n                    /*! Production::    math_expression : SUB PREFIX SUB NESTED_CALC LPAREN math_expression RPAREN */ this.$ = {\n                        type: \"Calc\",\n                        value: yyvstack[yysp - 1],\n                        prefix: yyvstack[yysp - 5]\n                    };\n                    break;\n                case 9:\n                /*! Production::    math_expression : css_variable */ case 10:\n                /*! Production::    math_expression : css_value */ case 11:\n                    /*! Production::    math_expression : value */ this.$ = yyvstack[yysp];\n                    break;\n                case 12:\n                    /*! Production::    value : NUMBER */ this.$ = {\n                        type: \"Value\",\n                        value: parseFloat(yyvstack[yysp])\n                    };\n                    break;\n                case 13:\n                    /*! Production::    value : SUB NUMBER */ this.$ = {\n                        type: \"Value\",\n                        value: parseFloat(yyvstack[yysp]) * -1\n                    };\n                    break;\n                case 14:\n                    /*! Production::    css_variable : CSS_VAR LPAREN CSS_CPROP RPAREN */ this.$ = {\n                        type: \"CssVariable\",\n                        value: yyvstack[yysp - 1]\n                    };\n                    break;\n                case 15:\n                    /*! Production::    css_variable : CSS_VAR LPAREN CSS_CPROP COMMA math_expression RPAREN */ this.$ = {\n                        type: \"CssVariable\",\n                        value: yyvstack[yysp - 3],\n                        fallback: yyvstack[yysp - 1]\n                    };\n                    break;\n                case 16:\n                    /*! Production::    css_value : LENGTH */ this.$ = {\n                        type: \"LengthValue\",\n                        value: parseFloat(yyvstack[yysp]),\n                        unit: /[a-z]+/.exec(yyvstack[yysp])[0]\n                    };\n                    break;\n                case 17:\n                    /*! Production::    css_value : ANGLE */ this.$ = {\n                        type: \"AngleValue\",\n                        value: parseFloat(yyvstack[yysp]),\n                        unit: /[a-z]+/.exec(yyvstack[yysp])[0]\n                    };\n                    break;\n                case 18:\n                    /*! Production::    css_value : TIME */ this.$ = {\n                        type: \"TimeValue\",\n                        value: parseFloat(yyvstack[yysp]),\n                        unit: /[a-z]+/.exec(yyvstack[yysp])[0]\n                    };\n                    break;\n                case 19:\n                    /*! Production::    css_value : FREQ */ this.$ = {\n                        type: \"FrequencyValue\",\n                        value: parseFloat(yyvstack[yysp]),\n                        unit: /[a-z]+/.exec(yyvstack[yysp])[0]\n                    };\n                    break;\n                case 20:\n                    /*! Production::    css_value : RES */ this.$ = {\n                        type: \"ResolutionValue\",\n                        value: parseFloat(yyvstack[yysp]),\n                        unit: /[a-z]+/.exec(yyvstack[yysp])[0]\n                    };\n                    break;\n                case 21:\n                    /*! Production::    css_value : EMS */ this.$ = {\n                        type: \"EmValue\",\n                        value: parseFloat(yyvstack[yysp]),\n                        unit: \"em\"\n                    };\n                    break;\n                case 22:\n                    /*! Production::    css_value : EXS */ this.$ = {\n                        type: \"ExValue\",\n                        value: parseFloat(yyvstack[yysp]),\n                        unit: \"ex\"\n                    };\n                    break;\n                case 23:\n                    /*! Production::    css_value : CHS */ this.$ = {\n                        type: \"ChValue\",\n                        value: parseFloat(yyvstack[yysp]),\n                        unit: \"ch\"\n                    };\n                    break;\n                case 24:\n                    /*! Production::    css_value : REMS */ this.$ = {\n                        type: \"RemValue\",\n                        value: parseFloat(yyvstack[yysp]),\n                        unit: \"rem\"\n                    };\n                    break;\n                case 25:\n                    /*! Production::    css_value : VHS */ this.$ = {\n                        type: \"VhValue\",\n                        value: parseFloat(yyvstack[yysp]),\n                        unit: \"vh\"\n                    };\n                    break;\n                case 26:\n                    /*! Production::    css_value : VWS */ this.$ = {\n                        type: \"VwValue\",\n                        value: parseFloat(yyvstack[yysp]),\n                        unit: \"vw\"\n                    };\n                    break;\n                case 27:\n                    /*! Production::    css_value : VMINS */ this.$ = {\n                        type: \"VminValue\",\n                        value: parseFloat(yyvstack[yysp]),\n                        unit: \"vmin\"\n                    };\n                    break;\n                case 28:\n                    /*! Production::    css_value : VMAXS */ this.$ = {\n                        type: \"VmaxValue\",\n                        value: parseFloat(yyvstack[yysp]),\n                        unit: \"vmax\"\n                    };\n                    break;\n                case 29:\n                    /*! Production::    css_value : PERCENTAGE */ this.$ = {\n                        type: \"PercentageValue\",\n                        value: parseFloat(yyvstack[yysp]),\n                        unit: \"%\"\n                    };\n                    break;\n                case 30:\n                    /*! Production::    css_value : SUB css_value */ var prev = yyvstack[yysp];\n                    prev.value *= -1;\n                    this.$ = prev;\n                    break;\n            }\n        },\n        table: bt({\n            len: u([\n                24,\n                1,\n                5,\n                23,\n                1,\n                18,\n                s,\n                [\n                    0,\n                    3\n                ],\n                1,\n                s,\n                [\n                    0,\n                    16\n                ],\n                s,\n                [\n                    23,\n                    4\n                ],\n                c,\n                [\n                    28,\n                    3\n                ],\n                0,\n                0,\n                16,\n                1,\n                6,\n                6,\n                s,\n                [\n                    0,\n                    3\n                ],\n                5,\n                1,\n                2,\n                c,\n                [\n                    37,\n                    3\n                ],\n                c,\n                [\n                    20,\n                    3\n                ],\n                5,\n                0,\n                0\n            ]),\n            symbol: u([\n                4,\n                7,\n                9,\n                11,\n                12,\n                s,\n                [\n                    15,\n                    19,\n                    1\n                ],\n                1,\n                1,\n                s,\n                [\n                    3,\n                    4,\n                    1\n                ],\n                c,\n                [\n                    30,\n                    19\n                ],\n                c,\n                [\n                    29,\n                    4\n                ],\n                7,\n                4,\n                10,\n                11,\n                c,\n                [\n                    22,\n                    14\n                ],\n                c,\n                [\n                    19,\n                    3\n                ],\n                c,\n                [\n                    43,\n                    22\n                ],\n                c,\n                [\n                    23,\n                    69\n                ],\n                c,\n                [\n                    139,\n                    4\n                ],\n                8,\n                c,\n                [\n                    51,\n                    24\n                ],\n                4,\n                c,\n                [\n                    138,\n                    15\n                ],\n                13,\n                c,\n                [\n                    186,\n                    5\n                ],\n                8,\n                c,\n                [\n                    6,\n                    6\n                ],\n                c,\n                [\n                    5,\n                    5\n                ],\n                9,\n                8,\n                14,\n                c,\n                [\n                    159,\n                    47\n                ],\n                c,\n                [\n                    60,\n                    10\n                ]\n            ]),\n            type: u([\n                s,\n                [\n                    2,\n                    19\n                ],\n                s,\n                [\n                    0,\n                    5\n                ],\n                1,\n                s,\n                [\n                    2,\n                    24\n                ],\n                s,\n                [\n                    0,\n                    4\n                ],\n                c,\n                [\n                    22,\n                    19\n                ],\n                c,\n                [\n                    43,\n                    42\n                ],\n                c,\n                [\n                    23,\n                    70\n                ],\n                c,\n                [\n                    28,\n                    25\n                ],\n                c,\n                [\n                    45,\n                    25\n                ],\n                c,\n                [\n                    113,\n                    54\n                ]\n            ]),\n            state: u([\n                1,\n                2,\n                8,\n                6,\n                7,\n                30,\n                c,\n                [\n                    4,\n                    3\n                ],\n                33,\n                37,\n                c,\n                [\n                    5,\n                    3\n                ],\n                38,\n                c,\n                [\n                    4,\n                    3\n                ],\n                39,\n                c,\n                [\n                    4,\n                    3\n                ],\n                40,\n                c,\n                [\n                    4,\n                    3\n                ],\n                42,\n                c,\n                [\n                    21,\n                    4\n                ],\n                50,\n                c,\n                [\n                    5,\n                    3\n                ],\n                51,\n                c,\n                [\n                    4,\n                    3\n                ]\n            ]),\n            mode: u([\n                s,\n                [\n                    1,\n                    179\n                ],\n                s,\n                [\n                    2,\n                    3\n                ],\n                c,\n                [\n                    5,\n                    5\n                ],\n                c,\n                [\n                    6,\n                    4\n                ],\n                s,\n                [\n                    1,\n                    57\n                ]\n            ]),\n            goto: u([\n                5,\n                3,\n                4,\n                24,\n                s,\n                [\n                    9,\n                    15,\n                    1\n                ],\n                s,\n                [\n                    25,\n                    5,\n                    1\n                ],\n                c,\n                [\n                    24,\n                    19\n                ],\n                31,\n                35,\n                32,\n                34,\n                c,\n                [\n                    18,\n                    14\n                ],\n                36,\n                c,\n                [\n                    38,\n                    19\n                ],\n                c,\n                [\n                    19,\n                    57\n                ],\n                c,\n                [\n                    118,\n                    4\n                ],\n                41,\n                c,\n                [\n                    24,\n                    19\n                ],\n                43,\n                35,\n                c,\n                [\n                    16,\n                    14\n                ],\n                44,\n                s,\n                [\n                    2,\n                    3\n                ],\n                28,\n                29,\n                2,\n                s,\n                [\n                    3,\n                    3\n                ],\n                28,\n                29,\n                3,\n                c,\n                [\n                    53,\n                    4\n                ],\n                s,\n                [\n                    45,\n                    5,\n                    1\n                ],\n                c,\n                [\n                    100,\n                    42\n                ],\n                52,\n                c,\n                [\n                    5,\n                    4\n                ],\n                53\n            ])\n        }),\n        defaultActions: bda({\n            idx: u([\n                6,\n                7,\n                8,\n                s,\n                [\n                    10,\n                    16,\n                    1\n                ],\n                33,\n                34,\n                39,\n                40,\n                41,\n                45,\n                47,\n                52,\n                53\n            ]),\n            goto: u([\n                9,\n                10,\n                11,\n                s,\n                [\n                    16,\n                    14,\n                    1\n                ],\n                12,\n                1,\n                30,\n                13,\n                s,\n                [\n                    4,\n                    4,\n                    1\n                ],\n                14,\n                15,\n                8\n            ])\n        }),\n        parseError: function parseError(str, hash, ExceptionClass) {\n            if (hash.recoverable) {\n                if (typeof this.trace === \"function\") {\n                    this.trace(str);\n                }\n                hash.destroy(); // destroy... well, *almost*!\n            } else {\n                if (typeof this.trace === \"function\") {\n                    this.trace(str);\n                }\n                if (!ExceptionClass) {\n                    ExceptionClass = this.JisonParserError;\n                }\n                throw new ExceptionClass(str, hash);\n            }\n        },\n        parse: function parse(input) {\n            var self = this;\n            var stack = new Array(128); // token stack: stores token which leads to state at the same index (column storage)\n            var sstack = new Array(128); // state stack: stores states (column storage)\n            var vstack = new Array(128); // semantic value stack\n            var table = this.table;\n            var sp = 0; // 'stack pointer': index into the stacks\n            var symbol = 0;\n            var TERROR = this.TERROR;\n            var EOF = this.EOF;\n            var ERROR_RECOVERY_TOKEN_DISCARD_COUNT = this.options.errorRecoveryTokenDiscardCount | 0 || 3;\n            var NO_ACTION = [\n                0,\n                54 /* === table.length :: ensures that anyone using this new state will fail dramatically! */ \n            ];\n            var lexer;\n            if (this.__lexer__) {\n                lexer = this.__lexer__;\n            } else {\n                lexer = this.__lexer__ = Object.create(this.lexer);\n            }\n            var sharedState_yy = {\n                parseError: undefined,\n                quoteName: undefined,\n                lexer: undefined,\n                parser: undefined,\n                pre_parse: undefined,\n                post_parse: undefined,\n                pre_lex: undefined,\n                post_lex: undefined // WARNING: must be written this way for the code expanders to work correctly in both ES5 and ES6 modes!\n            };\n            var ASSERT;\n            if (typeof assert !== \"function\") {\n                ASSERT = function JisonAssert(cond, msg) {\n                    if (!cond) {\n                        throw new Error(\"assertion failed: \" + (msg || \"***\"));\n                    }\n                };\n            } else {\n                ASSERT = assert;\n            }\n            this.yyGetSharedState = function yyGetSharedState() {\n                return sharedState_yy;\n            };\n            function shallow_copy_noclobber(dst, src) {\n                for(var k in src){\n                    if (typeof dst[k] === \"undefined\" && Object.prototype.hasOwnProperty.call(src, k)) {\n                        dst[k] = src[k];\n                    }\n                }\n            }\n            // copy state\n            shallow_copy_noclobber(sharedState_yy, this.yy);\n            sharedState_yy.lexer = lexer;\n            sharedState_yy.parser = this;\n            // Does the shared state override the default `parseError` that already comes with this instance?\n            if (typeof sharedState_yy.parseError === \"function\") {\n                this.parseError = function parseErrorAlt(str, hash, ExceptionClass) {\n                    if (!ExceptionClass) {\n                        ExceptionClass = this.JisonParserError;\n                    }\n                    return sharedState_yy.parseError.call(this, str, hash, ExceptionClass);\n                };\n            } else {\n                this.parseError = this.originalParseError;\n            }\n            // Does the shared state override the default `quoteName` that already comes with this instance?\n            if (typeof sharedState_yy.quoteName === \"function\") {\n                this.quoteName = function quoteNameAlt(id_str) {\n                    return sharedState_yy.quoteName.call(this, id_str);\n                };\n            } else {\n                this.quoteName = this.originalQuoteName;\n            }\n            // set up the cleanup function; make it an API so that external code can re-use this one in case of\n            // calamities or when the `%options no-try-catch` option has been specified for the grammar, in which\n            // case this parse() API method doesn't come with a `finally { ... }` block any more!\n            //\n            // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,\n            //       or else your `sharedState`, etc. references will be *wrong*!\n            this.cleanupAfterParse = function parser_cleanupAfterParse(resultValue, invoke_post_methods, do_not_nuke_errorinfos) {\n                var rv;\n                if (invoke_post_methods) {\n                    var hash;\n                    if (sharedState_yy.post_parse || this.post_parse) {\n                        // create an error hash info instance: we re-use this API in a **non-error situation**\n                        // as this one delivers all parser internals ready for access by userland code.\n                        hash = this.constructParseErrorInfo(null, null, null, false);\n                    }\n                    if (sharedState_yy.post_parse) {\n                        rv = sharedState_yy.post_parse.call(this, sharedState_yy, resultValue, hash);\n                        if (typeof rv !== \"undefined\") resultValue = rv;\n                    }\n                    if (this.post_parse) {\n                        rv = this.post_parse.call(this, sharedState_yy, resultValue, hash);\n                        if (typeof rv !== \"undefined\") resultValue = rv;\n                    }\n                    // cleanup:\n                    if (hash && hash.destroy) {\n                        hash.destroy();\n                    }\n                }\n                if (this.__reentrant_call_depth > 1) return resultValue; // do not (yet) kill the sharedState when this is a reentrant run.\n                // clean up the lingering lexer structures as well:\n                if (lexer.cleanupAfterLex) {\n                    lexer.cleanupAfterLex(do_not_nuke_errorinfos);\n                }\n                // prevent lingering circular references from causing memory leaks:\n                if (sharedState_yy) {\n                    sharedState_yy.lexer = undefined;\n                    sharedState_yy.parser = undefined;\n                    if (lexer.yy === sharedState_yy) {\n                        lexer.yy = undefined;\n                    }\n                }\n                sharedState_yy = undefined;\n                this.parseError = this.originalParseError;\n                this.quoteName = this.originalQuoteName;\n                // nuke the vstack[] array at least as that one will still reference obsoleted user values.\n                // To be safe, we nuke the other internal stack columns as well...\n                stack.length = 0; // fastest way to nuke an array without overly bothering the GC\n                sstack.length = 0;\n                vstack.length = 0;\n                sp = 0;\n                // nuke the error hash info instances created during this run.\n                // Userland code must COPY any data/references\n                // in the error hash instance(s) it is more permanently interested in.\n                if (!do_not_nuke_errorinfos) {\n                    for(var i = this.__error_infos.length - 1; i >= 0; i--){\n                        var el = this.__error_infos[i];\n                        if (el && typeof el.destroy === \"function\") {\n                            el.destroy();\n                        }\n                    }\n                    this.__error_infos.length = 0;\n                }\n                return resultValue;\n            };\n            // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,\n            //       or else your `lexer`, `sharedState`, etc. references will be *wrong*!\n            this.constructParseErrorInfo = function parser_constructParseErrorInfo(msg, ex, expected, recoverable) {\n                var pei = {\n                    errStr: msg,\n                    exception: ex,\n                    text: lexer.match,\n                    value: lexer.yytext,\n                    token: this.describeSymbol(symbol) || symbol,\n                    token_id: symbol,\n                    line: lexer.yylineno,\n                    expected: expected,\n                    recoverable: recoverable,\n                    state: state,\n                    action: action,\n                    new_state: newState,\n                    symbol_stack: stack,\n                    state_stack: sstack,\n                    value_stack: vstack,\n                    stack_pointer: sp,\n                    yy: sharedState_yy,\n                    lexer: lexer,\n                    parser: this,\n                    // and make sure the error info doesn't stay due to potential\n                    // ref cycle via userland code manipulations.\n                    // These would otherwise all be memory leak opportunities!\n                    //\n                    // Note that only array and object references are nuked as those\n                    // constitute the set of elements which can produce a cyclic ref.\n                    // The rest of the members is kept intact as they are harmless.\n                    destroy: function destructParseErrorInfo() {\n                        // remove cyclic references added to error info:\n                        // info.yy = null;\n                        // info.lexer = null;\n                        // info.value = null;\n                        // info.value_stack = null;\n                        // ...\n                        var rec = !!this.recoverable;\n                        for(var key in this){\n                            if (this.hasOwnProperty(key) && typeof key === \"object\") {\n                                this[key] = undefined;\n                            }\n                        }\n                        this.recoverable = rec;\n                    }\n                };\n                // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!\n                this.__error_infos.push(pei);\n                return pei;\n            };\n            function getNonTerminalFromCode(symbol) {\n                var tokenName = self.getSymbolName(symbol);\n                if (!tokenName) {\n                    tokenName = symbol;\n                }\n                return tokenName;\n            }\n            function stdLex() {\n                var token = lexer.lex();\n                // if token isn't its numeric value, convert\n                if (typeof token !== \"number\") {\n                    token = self.symbols_[token] || token;\n                }\n                return token || EOF;\n            }\n            function fastLex() {\n                var token = lexer.fastLex();\n                // if token isn't its numeric value, convert\n                if (typeof token !== \"number\") {\n                    token = self.symbols_[token] || token;\n                }\n                return token || EOF;\n            }\n            var lex = stdLex;\n            var state, action, r, t;\n            var yyval = {\n                $: true,\n                _$: undefined,\n                yy: sharedState_yy\n            };\n            var p;\n            var yyrulelen;\n            var this_production;\n            var newState;\n            var retval = false;\n            try {\n                this.__reentrant_call_depth++;\n                lexer.setInput(input, sharedState_yy);\n                // NOTE: we *assume* no lexer pre/post handlers are set up *after* \n                // this initial `setInput()` call: hence we can now check and decide\n                // whether we'll go with the standard, slower, lex() API or the\n                // `fast_lex()` one:\n                if (typeof lexer.canIUse === \"function\") {\n                    var lexerInfo = lexer.canIUse();\n                    if (lexerInfo.fastLex && typeof fastLex === \"function\") {\n                        lex = fastLex;\n                    }\n                }\n                vstack[sp] = null;\n                sstack[sp] = 0;\n                stack[sp] = 0;\n                ++sp;\n                if (this.pre_parse) {\n                    this.pre_parse.call(this, sharedState_yy);\n                }\n                if (sharedState_yy.pre_parse) {\n                    sharedState_yy.pre_parse.call(this, sharedState_yy);\n                }\n                newState = sstack[sp - 1];\n                for(;;){\n                    // retrieve state number from top of stack\n                    state = newState; // sstack[sp - 1];\n                    // use default actions if available\n                    if (this.defaultActions[state]) {\n                        action = 2;\n                        newState = this.defaultActions[state];\n                    } else {\n                        // The single `==` condition below covers both these `===` comparisons in a single\n                        // operation:\n                        //\n                        //     if (symbol === null || typeof symbol === 'undefined') ...\n                        if (!symbol) {\n                            symbol = lex();\n                        }\n                        // read action for current state and first input\n                        t = table[state] && table[state][symbol] || NO_ACTION;\n                        newState = t[1];\n                        action = t[0];\n                        // handle parse error\n                        if (!action) {\n                            var errStr;\n                            var errSymbolDescr = this.describeSymbol(symbol) || symbol;\n                            var expected = this.collect_expected_token_set(state);\n                            // Report error\n                            if (typeof lexer.yylineno === \"number\") {\n                                errStr = \"Parse error on line \" + (lexer.yylineno + 1) + \": \";\n                            } else {\n                                errStr = \"Parse error: \";\n                            }\n                            if (typeof lexer.showPosition === \"function\") {\n                                errStr += \"\\n\" + lexer.showPosition(79 - 10, 10) + \"\\n\";\n                            }\n                            if (expected.length) {\n                                errStr += \"Expecting \" + expected.join(\", \") + \", got unexpected \" + errSymbolDescr;\n                            } else {\n                                errStr += \"Unexpected \" + errSymbolDescr;\n                            }\n                            // we cannot recover from the error!\n                            p = this.constructParseErrorInfo(errStr, null, expected, false);\n                            r = this.parseError(p.errStr, p, this.JisonParserError);\n                            if (typeof r !== \"undefined\") {\n                                retval = r;\n                            }\n                            break;\n                        }\n                    }\n                    switch(action){\n                        // catch misc. parse failures:\n                        default:\n                            // this shouldn't happen, unless resolve defaults are off\n                            if (action instanceof Array) {\n                                p = this.constructParseErrorInfo(\"Parse Error: multiple actions possible at state: \" + state + \", token: \" + symbol, null, null, false);\n                                r = this.parseError(p.errStr, p, this.JisonParserError);\n                                if (typeof r !== \"undefined\") {\n                                    retval = r;\n                                }\n                                break;\n                            }\n                            // Another case of better safe than sorry: in case state transitions come out of another error recovery process\n                            // or a buggy LUT (LookUp Table):\n                            p = this.constructParseErrorInfo(\"Parsing halted. No viable error recovery approach available due to internal system failure.\", null, null, false);\n                            r = this.parseError(p.errStr, p, this.JisonParserError);\n                            if (typeof r !== \"undefined\") {\n                                retval = r;\n                            }\n                            break;\n                        // shift:\n                        case 1:\n                            stack[sp] = symbol;\n                            vstack[sp] = lexer.yytext;\n                            sstack[sp] = newState; // push state\n                            ++sp;\n                            symbol = 0;\n                            continue;\n                        // reduce:\n                        case 2:\n                            this_production = this.productions_[newState - 1]; // `this.productions_[]` is zero-based indexed while states start from 1 upwards...\n                            yyrulelen = this_production[1];\n                            r = this.performAction.call(yyval, newState, sp - 1, vstack);\n                            if (typeof r !== \"undefined\") {\n                                retval = r;\n                                break;\n                            }\n                            // pop off stack\n                            sp -= yyrulelen;\n                            // don't overwrite the `symbol` variable: use a local var to speed things up:\n                            var ntsymbol = this_production[0]; // push nonterminal (reduce)\n                            stack[sp] = ntsymbol;\n                            vstack[sp] = yyval.$;\n                            // goto new state = table[STATE][NONTERMINAL]\n                            newState = table[sstack[sp - 1]][ntsymbol];\n                            sstack[sp] = newState;\n                            ++sp;\n                            continue;\n                        // accept:\n                        case 3:\n                            if (sp !== -2) {\n                                retval = true;\n                                // Return the `$accept` rule's `$$` result, if available.\n                                //\n                                // Also note that JISON always adds this top-most `$accept` rule (with implicit,\n                                // default, action):\n                                //\n                                //     $accept: <startSymbol> $end\n                                //                  %{ $$ = $1; @$ = @1; %}\n                                //\n                                // which, combined with the parse kernel's `$accept` state behaviour coded below,\n                                // will produce the `$$` value output of the <startSymbol> rule as the parse result,\n                                // IFF that result is *not* `undefined`. (See also the parser kernel code.)\n                                //\n                                // In code:\n                                //\n                                //                  %{\n                                //                      @$ = @1;            // if location tracking support is included\n                                //                      if (typeof $1 !== 'undefined')\n                                //                          return $1;\n                                //                      else\n                                //                          return true;           // the default parse result if the rule actions don't produce anything\n                                //                  %}\n                                sp--;\n                                if (typeof vstack[sp] !== \"undefined\") {\n                                    retval = vstack[sp];\n                                }\n                            }\n                            break;\n                    }\n                    break;\n                }\n            } catch (ex) {\n                // report exceptions through the parseError callback too, but keep the exception intact\n                // if it is a known parser or lexer error which has been thrown by parseError() already:\n                if (ex instanceof this.JisonParserError) {\n                    throw ex;\n                } else if (lexer && typeof lexer.JisonLexerError === \"function\" && ex instanceof lexer.JisonLexerError) {\n                    throw ex;\n                }\n                p = this.constructParseErrorInfo(\"Parsing aborted due to exception.\", ex, null, false);\n                retval = false;\n                r = this.parseError(p.errStr, p, this.JisonParserError);\n                if (typeof r !== \"undefined\") {\n                    retval = r;\n                }\n            } finally{\n                retval = this.cleanupAfterParse(retval, true, true);\n                this.__reentrant_call_depth--;\n            } // /finally\n            return retval;\n        }\n    };\n    parser.originalParseError = parser.parseError;\n    parser.originalQuoteName = parser.quoteName;\n    /* lexer generated by jison-lex 0.6.1-215 */ /*\n * Returns a Lexer object of the following structure:\n *\n *  Lexer: {\n *    yy: {}     The so-called \"shared state\" or rather the *source* of it;\n *               the real \"shared state\" `yy` passed around to\n *               the rule actions, etc. is a direct reference!\n *\n *               This \"shared context\" object was passed to the lexer by way of \n *               the `lexer.setInput(str, yy)` API before you may use it.\n *\n *               This \"shared context\" object is passed to the lexer action code in `performAction()`\n *               so userland code in the lexer actions may communicate with the outside world \n *               and/or other lexer rules' actions in more or less complex ways.\n *\n *  }\n *\n *  Lexer.prototype: {\n *    EOF: 1,\n *    ERROR: 2,\n *\n *    yy:        The overall \"shared context\" object reference.\n *\n *    JisonLexerError: function(msg, hash),\n *\n *    performAction: function lexer__performAction(yy, yyrulenumber, YY_START),\n *\n *               The function parameters and `this` have the following value/meaning:\n *               - `this`    : reference to the `lexer` instance. \n *                               `yy_` is an alias for `this` lexer instance reference used internally.\n *\n *               - `yy`      : a reference to the `yy` \"shared state\" object which was passed to the lexer\n *                             by way of the `lexer.setInput(str, yy)` API before.\n *\n *                             Note:\n *                             The extra arguments you specified in the `%parse-param` statement in your\n *                             **parser** grammar definition file are passed to the lexer via this object\n *                             reference as member variables.\n *\n *               - `yyrulenumber`   : index of the matched lexer rule (regex), used internally.\n *\n *               - `YY_START`: the current lexer \"start condition\" state.\n *\n *    parseError: function(str, hash, ExceptionClass),\n *\n *    constructLexErrorInfo: function(error_message, is_recoverable),\n *               Helper function.\n *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.\n *               See it's use in this lexer kernel in many places; example usage:\n *\n *                   var infoObj = lexer.constructParseErrorInfo('fail!', true);\n *                   var retVal = lexer.parseError(infoObj.errStr, infoObj, lexer.JisonLexerError);\n *\n *    options: { ... lexer %options ... },\n *\n *    lex: function(),\n *               Produce one token of lexed input, which was passed in earlier via the `lexer.setInput()` API.\n *               You MAY use the additional `args...` parameters as per `%parse-param` spec of the **lexer** grammar:\n *               these extra `args...` are added verbatim to the `yy` object reference as member variables.\n *\n *               WARNING:\n *               Lexer's additional `args...` parameters (via lexer's `%parse-param`) MAY conflict with\n *               any attributes already added to `yy` by the **parser** or the jison run-time; \n *               when such a collision is detected an exception is thrown to prevent the generated run-time \n *               from silently accepting this confusing and potentially hazardous situation! \n *\n *    cleanupAfterLex: function(do_not_nuke_errorinfos),\n *               Helper function.\n *\n *               This helper API is invoked when the **parse process** has completed: it is the responsibility\n *               of the **parser** (or the calling userland code) to invoke this method once cleanup is desired. \n *\n *               This helper may be invoked by user code to ensure the internal lexer gets properly garbage collected.\n *\n *    setInput: function(input, [yy]),\n *\n *\n *    input: function(),\n *\n *\n *    unput: function(str),\n *\n *\n *    more: function(),\n *\n *\n *    reject: function(),\n *\n *\n *    less: function(n),\n *\n *\n *    pastInput: function(n),\n *\n *\n *    upcomingInput: function(n),\n *\n *\n *    showPosition: function(),\n *\n *\n *    test_match: function(regex_match_array, rule_index),\n *\n *\n *    next: function(),\n *\n *\n *    begin: function(condition),\n *\n *\n *    pushState: function(condition),\n *\n *\n *    popState: function(),\n *\n *\n *    topState: function(),\n *\n *\n *    _currentRules: function(),\n *\n *\n *    stateStackSize: function(),\n *\n *\n *    performAction: function(yy, yy_, yyrulenumber, YY_START),\n *\n *\n *    rules: [...],\n *\n *\n *    conditions: {associative list: name ==> set},\n *  }\n *\n *\n *  token location info (`yylloc`): {\n *    first_line: n,\n *    last_line: n,\n *    first_column: n,\n *    last_column: n,\n *    range: [start_number, end_number]\n *               (where the numbers are indexes into the input string, zero-based)\n *  }\n *\n * ---\n *\n * The `parseError` function receives a 'hash' object with these members for lexer errors:\n *\n *  {\n *    text:        (matched text)\n *    token:       (the produced terminal token, if any)\n *    token_id:    (the produced terminal token numeric ID, if any)\n *    line:        (yylineno)\n *    loc:         (yylloc)\n *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule\n *                  available for this particular error)\n *    yy:          (object: the current parser internal \"shared state\" `yy`\n *                  as is also available in the rule actions; this can be used,\n *                  for instance, for advanced error analysis and reporting)\n *    lexer:       (reference to the current lexer instance used by the parser)\n *  }\n *\n * while `this` will reference the current lexer instance.\n *\n * When `parseError` is invoked by the lexer, the default implementation will\n * attempt to invoke `yy.parser.parseError()`; when this callback is not provided\n * it will try to invoke `yy.parseError()` instead. When that callback is also not\n * provided, a `JisonLexerError` exception will be thrown containing the error\n * message and `hash`, as constructed by the `constructLexErrorInfo()` API.\n *\n * Note that the lexer's `JisonLexerError` error class is passed via the\n * `ExceptionClass` argument, which is invoked to construct the exception\n * instance to be thrown, so technically `parseError` will throw the object\n * produced by the `new ExceptionClass(str, hash)` JavaScript expression.\n *\n * ---\n *\n * You can specify lexer options by setting / modifying the `.options` object of your Lexer instance.\n * These options are available:\n *\n * (Options are permanent.)\n *  \n *  yy: {\n *      parseError: function(str, hash, ExceptionClass)\n *                 optional: overrides the default `parseError` function.\n *  }\n *\n *  lexer.options: {\n *      pre_lex:  function()\n *                 optional: is invoked before the lexer is invoked to produce another token.\n *                 `this` refers to the Lexer object.\n *      post_lex: function(token) { return token; }\n *                 optional: is invoked when the lexer has produced a token `token`;\n *                 this function can override the returned token value by returning another.\n *                 When it does not return any (truthy) value, the lexer will return\n *                 the original `token`.\n *                 `this` refers to the Lexer object.\n *\n * WARNING: the next set of options are not meant to be changed. They echo the abilities of\n * the lexer as per when it was compiled!\n *\n *      ranges: boolean\n *                 optional: `true` ==> token location info will include a .range[] member.\n *      flex: boolean\n *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested\n *                 exhaustively to find the longest match.\n *      backtrack_lexer: boolean\n *                 optional: `true` ==> lexer regexes are tested in order and for invoked;\n *                 the lexer terminates the scan when a token is returned by the action code.\n *      xregexp: boolean\n *                 optional: `true` ==> lexer rule regexes are \"extended regex format\" requiring the\n *                 `XRegExp` library. When this %option has not been specified at compile time, all lexer\n *                 rule regexes have been written as standard JavaScript RegExp expressions.\n *  }\n */ var lexer = function() {\n        /**\n   * See also:\n   * http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508\n   * but we keep the prototype.constructor and prototype.name assignment lines too for compatibility\n   * with userland code which might access the derived class in a 'classic' way.\n   *\n   * @public\n   * @constructor\n   * @nocollapse\n   */ function JisonLexerError(msg, hash) {\n            Object.defineProperty(this, \"name\", {\n                enumerable: false,\n                writable: false,\n                value: \"JisonLexerError\"\n            });\n            if (msg == null) msg = \"???\";\n            Object.defineProperty(this, \"message\", {\n                enumerable: false,\n                writable: true,\n                value: msg\n            });\n            this.hash = hash;\n            var stacktrace;\n            if (hash && hash.exception instanceof Error) {\n                var ex2 = hash.exception;\n                this.message = ex2.message || msg;\n                stacktrace = ex2.stack;\n            }\n            if (!stacktrace) {\n                if (Error.hasOwnProperty(\"captureStackTrace\")) {\n                    // V8\n                    Error.captureStackTrace(this, this.constructor);\n                } else {\n                    stacktrace = new Error(msg).stack;\n                }\n            }\n            if (stacktrace) {\n                Object.defineProperty(this, \"stack\", {\n                    enumerable: false,\n                    writable: false,\n                    value: stacktrace\n                });\n            }\n        }\n        if (typeof Object.setPrototypeOf === \"function\") {\n            Object.setPrototypeOf(JisonLexerError.prototype, Error.prototype);\n        } else {\n            JisonLexerError.prototype = Object.create(Error.prototype);\n        }\n        JisonLexerError.prototype.constructor = JisonLexerError;\n        JisonLexerError.prototype.name = \"JisonLexerError\";\n        var lexer = {\n            // Code Generator Information Report\n            // ---------------------------------\n            //\n            // Options:\n            //\n            //   backtracking: .................... false\n            //   location.ranges: ................. false\n            //   location line+column tracking: ... true\n            //\n            //\n            // Forwarded Parser Analysis flags:\n            //\n            //   uses yyleng: ..................... false\n            //   uses yylineno: ................... false\n            //   uses yytext: ..................... false\n            //   uses yylloc: ..................... false\n            //   uses lexer values: ............... true / true\n            //   location tracking: ............... false\n            //   location assignment: ............. false\n            //\n            //\n            // Lexer Analysis flags:\n            //\n            //   uses yyleng: ..................... ???\n            //   uses yylineno: ................... ???\n            //   uses yytext: ..................... ???\n            //   uses yylloc: ..................... ???\n            //   uses ParseError API: ............. ???\n            //   uses yyerror: .................... ???\n            //   uses location tracking & editing:  ???\n            //   uses more() API: ................. ???\n            //   uses unput() API: ................ ???\n            //   uses reject() API: ............... ???\n            //   uses less() API: ................. ???\n            //   uses display APIs pastInput(), upcomingInput(), showPosition():\n            //        ............................. ???\n            //   uses describeYYLLOC() API: ....... ???\n            //\n            // --------- END OF REPORT -----------\n            EOF: 1,\n            ERROR: 2,\n            // JisonLexerError: JisonLexerError,        /// <-- injected by the code generator\n            // options: {},                             /// <-- injected by the code generator\n            // yy: ...,                                 /// <-- injected by setInput()\n            __currentRuleSet__: null,\n            __error_infos: [],\n            __decompressed: false,\n            done: false,\n            _backtrack: false,\n            _input: \"\",\n            _more: false,\n            _signaled_error_token: false,\n            conditionStack: [],\n            match: \"\",\n            matched: \"\",\n            matches: false,\n            yytext: \"\",\n            offset: 0,\n            yyleng: 0,\n            yylineno: 0,\n            yylloc: null,\n            /**\n     * INTERNAL USE: construct a suitable error info hash object instance for `parseError`.\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ constructLexErrorInfo: function lexer_constructLexErrorInfo(msg, recoverable, show_input_position) {\n                msg = \"\" + msg;\n                // heuristic to determine if the error message already contains a (partial) source code dump\n                // as produced by either `showPosition()` or `prettyPrintRange()`:\n                if (show_input_position == undefined) {\n                    show_input_position = !(msg.indexOf(\"\\n\") > 0 && msg.indexOf(\"^\") > 0);\n                }\n                if (this.yylloc && show_input_position) {\n                    if (typeof this.prettyPrintRange === \"function\") {\n                        var pretty_src = this.prettyPrintRange(this.yylloc);\n                        if (!/\\n\\s*$/.test(msg)) {\n                            msg += \"\\n\";\n                        }\n                        msg += \"\\n  Erroneous area:\\n\" + this.prettyPrintRange(this.yylloc);\n                    } else if (typeof this.showPosition === \"function\") {\n                        var pos_str = this.showPosition();\n                        if (pos_str) {\n                            if (msg.length && msg[msg.length - 1] !== \"\\n\" && pos_str[0] !== \"\\n\") {\n                                msg += \"\\n\" + pos_str;\n                            } else {\n                                msg += pos_str;\n                            }\n                        }\n                    }\n                }\n                /** @constructor */ var pei = {\n                    errStr: msg,\n                    recoverable: !!recoverable,\n                    text: this.match,\n                    token: null,\n                    line: this.yylineno,\n                    loc: this.yylloc,\n                    yy: this.yy,\n                    lexer: this,\n                    /**\n         * and make sure the error info doesn't stay due to potential\n         * ref cycle via userland code manipulations.\n         * These would otherwise all be memory leak opportunities!\n         * \n         * Note that only array and object references are nuked as those\n         * constitute the set of elements which can produce a cyclic ref.\n         * The rest of the members is kept intact as they are harmless.\n         * \n         * @public\n         * @this {LexErrorInfo}\n         */ destroy: function destructLexErrorInfo() {\n                        // remove cyclic references added to error info:\n                        // info.yy = null;\n                        // info.lexer = null;\n                        // ...\n                        var rec = !!this.recoverable;\n                        for(var key in this){\n                            if (this.hasOwnProperty(key) && typeof key === \"object\") {\n                                this[key] = undefined;\n                            }\n                        }\n                        this.recoverable = rec;\n                    }\n                };\n                // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!\n                this.__error_infos.push(pei);\n                return pei;\n            },\n            /**\n     * handler which is invoked when a lexer error occurs.\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ parseError: function lexer_parseError(str, hash, ExceptionClass) {\n                if (!ExceptionClass) {\n                    ExceptionClass = this.JisonLexerError;\n                }\n                if (this.yy) {\n                    if (this.yy.parser && typeof this.yy.parser.parseError === \"function\") {\n                        return this.yy.parser.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;\n                    } else if (typeof this.yy.parseError === \"function\") {\n                        return this.yy.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;\n                    }\n                }\n                throw new ExceptionClass(str, hash);\n            },\n            /**\n     * method which implements `yyerror(str, ...args)` functionality for use inside lexer actions.\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ yyerror: function yyError(str /*, ...args */ ) {\n                var lineno_msg = \"\";\n                if (this.yylloc) {\n                    lineno_msg = \" on line \" + (this.yylineno + 1);\n                }\n                var p = this.constructLexErrorInfo(\"Lexical error\" + lineno_msg + \": \" + str, this.options.lexerErrorsAreRecoverable);\n                // Add any extra args to the hash under the name `extra_error_attributes`:\n                var args = Array.prototype.slice.call(arguments, 1);\n                if (args.length) {\n                    p.extra_error_attributes = args;\n                }\n                return this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;\n            },\n            /**\n     * final cleanup function for when we have completed lexing the input;\n     * make it an API so that external code can use this one once userland\n     * code has decided it's time to destroy any lingering lexer error\n     * hash object instances and the like: this function helps to clean\n     * up these constructs, which *may* carry cyclic references which would\n     * otherwise prevent the instances from being properly and timely\n     * garbage-collected, i.e. this function helps prevent memory leaks!\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ cleanupAfterLex: function lexer_cleanupAfterLex(do_not_nuke_errorinfos) {\n                // prevent lingering circular references from causing memory leaks:\n                this.setInput(\"\", {});\n                // nuke the error hash info instances created during this run.\n                // Userland code must COPY any data/references\n                // in the error hash instance(s) it is more permanently interested in.\n                if (!do_not_nuke_errorinfos) {\n                    for(var i = this.__error_infos.length - 1; i >= 0; i--){\n                        var el = this.__error_infos[i];\n                        if (el && typeof el.destroy === \"function\") {\n                            el.destroy();\n                        }\n                    }\n                    this.__error_infos.length = 0;\n                }\n                return this;\n            },\n            /**\n     * clear the lexer token context; intended for internal use only\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ clear: function lexer_clear() {\n                this.yytext = \"\";\n                this.yyleng = 0;\n                this.match = \"\";\n                // - DO NOT reset `this.matched`\n                this.matches = false;\n                this._more = false;\n                this._backtrack = false;\n                var col = this.yylloc ? this.yylloc.last_column : 0;\n                this.yylloc = {\n                    first_line: this.yylineno + 1,\n                    first_column: col,\n                    last_line: this.yylineno + 1,\n                    last_column: col,\n                    range: [\n                        this.offset,\n                        this.offset\n                    ]\n                };\n            },\n            /**\n     * resets the lexer, sets new input\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ setInput: function lexer_setInput(input, yy) {\n                this.yy = yy || this.yy || {};\n                // also check if we've fully initialized the lexer instance,\n                // including expansion work to be done to go from a loaded\n                // lexer to a usable lexer:\n                if (!this.__decompressed) {\n                    // step 1: decompress the regex list:\n                    var rules = this.rules;\n                    for(var i = 0, len = rules.length; i < len; i++){\n                        var rule_re = rules[i];\n                        // compression: is the RE an xref to another RE slot in the rules[] table?\n                        if (typeof rule_re === \"number\") {\n                            rules[i] = rules[rule_re];\n                        }\n                    }\n                    // step 2: unfold the conditions[] set to make these ready for use:\n                    var conditions = this.conditions;\n                    for(var k in conditions){\n                        var spec = conditions[k];\n                        var rule_ids = spec.rules;\n                        var len = rule_ids.length;\n                        var rule_regexes = new Array(len + 1); // slot 0 is unused; we use a 1-based index approach here to keep the hottest code in `lexer_next()` fast and simple! \n                        var rule_new_ids = new Array(len + 1);\n                        for(var i = 0; i < len; i++){\n                            var idx = rule_ids[i];\n                            var rule_re = rules[idx];\n                            rule_regexes[i + 1] = rule_re;\n                            rule_new_ids[i + 1] = idx;\n                        }\n                        spec.rules = rule_new_ids;\n                        spec.__rule_regexes = rule_regexes;\n                        spec.__rule_count = len;\n                    }\n                    this.__decompressed = true;\n                }\n                this._input = input || \"\";\n                this.clear();\n                this._signaled_error_token = false;\n                this.done = false;\n                this.yylineno = 0;\n                this.matched = \"\";\n                this.conditionStack = [\n                    \"INITIAL\"\n                ];\n                this.__currentRuleSet__ = null;\n                this.yylloc = {\n                    first_line: 1,\n                    first_column: 0,\n                    last_line: 1,\n                    last_column: 0,\n                    range: [\n                        0,\n                        0\n                    ]\n                };\n                this.offset = 0;\n                return this;\n            },\n            /**\n     * edit the remaining input via user-specified callback.\n     * This can be used to forward-adjust the input-to-parse, \n     * e.g. inserting macro expansions and alike in the\n     * input which has yet to be lexed.\n     * The behaviour of this API contrasts the `unput()` et al\n     * APIs as those act on the *consumed* input, while this\n     * one allows one to manipulate the future, without impacting\n     * the current `yyloc` cursor location or any history. \n     * \n     * Use this API to help implement C-preprocessor-like\n     * `#include` statements, etc.\n     * \n     * The provided callback must be synchronous and is\n     * expected to return the edited input (string).\n     *\n     * The `cpsArg` argument value is passed to the callback\n     * as-is.\n     *\n     * `callback` interface: \n     * `function callback(input, cpsArg)`\n     * \n     * - `input` will carry the remaining-input-to-lex string\n     *   from the lexer.\n     * - `cpsArg` is `cpsArg` passed into this API.\n     * \n     * The `this` reference for the callback will be set to\n     * reference this lexer instance so that userland code\n     * in the callback can easily and quickly access any lexer\n     * API. \n     *\n     * When the callback returns a non-string-type falsey value,\n     * we assume the callback did not edit the input and we\n     * will using the input as-is.\n     *\n     * When the callback returns a non-string-type value, it\n     * is converted to a string for lexing via the `\"\" + retval`\n     * operation. (See also why: http://2ality.com/2012/03/converting-to-string.html \n     * -- that way any returned object's `toValue()` and `toString()`\n     * methods will be invoked in a proper/desirable order.)\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ editRemainingInput: function lexer_editRemainingInput(callback, cpsArg) {\n                var rv = callback.call(this, this._input, cpsArg);\n                if (typeof rv !== \"string\") {\n                    if (rv) {\n                        this._input = \"\" + rv;\n                    }\n                // else: keep `this._input` as is.  \n                } else {\n                    this._input = rv;\n                }\n                return this;\n            },\n            /**\n     * consumes and returns one char from the input\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ input: function lexer_input() {\n                if (!this._input) {\n                    //this.done = true;    -- don't set `done` as we want the lex()/next() API to be able to produce one custom EOF token match after this anyhow. (lexer can match special <<EOF>> tokens and perform user action code for a <<EOF>> match, but only does so *once*)\n                    return null;\n                }\n                var ch = this._input[0];\n                this.yytext += ch;\n                this.yyleng++;\n                this.offset++;\n                this.match += ch;\n                this.matched += ch;\n                // Count the linenumber up when we hit the LF (or a stand-alone CR).\n                // On CRLF, the linenumber is incremented when you fetch the CR or the CRLF combo\n                // and we advance immediately past the LF as well, returning both together as if\n                // it was all a single 'character' only.\n                var slice_len = 1;\n                var lines = false;\n                if (ch === \"\\n\") {\n                    lines = true;\n                } else if (ch === \"\\r\") {\n                    lines = true;\n                    var ch2 = this._input[1];\n                    if (ch2 === \"\\n\") {\n                        slice_len++;\n                        ch += ch2;\n                        this.yytext += ch2;\n                        this.yyleng++;\n                        this.offset++;\n                        this.match += ch2;\n                        this.matched += ch2;\n                        this.yylloc.range[1]++;\n                    }\n                }\n                if (lines) {\n                    this.yylineno++;\n                    this.yylloc.last_line++;\n                    this.yylloc.last_column = 0;\n                } else {\n                    this.yylloc.last_column++;\n                }\n                this.yylloc.range[1]++;\n                this._input = this._input.slice(slice_len);\n                return ch;\n            },\n            /**\n     * unshifts one char (or an entire string) into the input\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ unput: function lexer_unput(ch) {\n                var len = ch.length;\n                var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n                this._input = ch + this._input;\n                this.yytext = this.yytext.substr(0, this.yytext.length - len);\n                this.yyleng = this.yytext.length;\n                this.offset -= len;\n                this.match = this.match.substr(0, this.match.length - len);\n                this.matched = this.matched.substr(0, this.matched.length - len);\n                if (lines.length > 1) {\n                    this.yylineno -= lines.length - 1;\n                    this.yylloc.last_line = this.yylineno + 1;\n                    // Get last entirely matched line into the `pre_lines[]` array's\n                    // last index slot; we don't mind when other previously \n                    // matched lines end up in the array too. \n                    var pre = this.match;\n                    var pre_lines = pre.split(/(?:\\r\\n?|\\n)/g);\n                    if (pre_lines.length === 1) {\n                        pre = this.matched;\n                        pre_lines = pre.split(/(?:\\r\\n?|\\n)/g);\n                    }\n                    this.yylloc.last_column = pre_lines[pre_lines.length - 1].length;\n                } else {\n                    this.yylloc.last_column -= len;\n                }\n                this.yylloc.range[1] = this.yylloc.range[0] + this.yyleng;\n                this.done = false;\n                return this;\n            },\n            /**\n     * cache matched text and append it on next action\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ more: function lexer_more() {\n                this._more = true;\n                return this;\n            },\n            /**\n     * signal the lexer that this rule fails to match the input, so the\n     * next matching rule (regex) should be tested instead.\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ reject: function lexer_reject() {\n                if (this.options.backtrack_lexer) {\n                    this._backtrack = true;\n                } else {\n                    // when the `parseError()` call returns, we MUST ensure that the error is registered.\n                    // We accomplish this by signaling an 'error' token to be produced for the current\n                    // `.lex()` run.\n                    var lineno_msg = \"\";\n                    if (this.yylloc) {\n                        lineno_msg = \" on line \" + (this.yylineno + 1);\n                    }\n                    var p = this.constructLexErrorInfo(\"Lexical error\" + lineno_msg + \": You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\", false);\n                    this._signaled_error_token = this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;\n                }\n                return this;\n            },\n            /**\n     * retain first n characters of the match\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ less: function lexer_less(n) {\n                return this.unput(this.match.slice(n));\n            },\n            /**\n     * return (part of the) already matched input, i.e. for error\n     * messages.\n     * \n     * Limit the returned string length to `maxSize` (default: 20).\n     * \n     * Limit the returned string to the `maxLines` number of lines of\n     * input (default: 1).\n     * \n     * Negative limit values equal *unlimited*.\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ pastInput: function lexer_pastInput(maxSize, maxLines) {\n                var past = this.matched.substring(0, this.matched.length - this.match.length);\n                if (maxSize < 0) maxSize = past.length;\n                else if (!maxSize) maxSize = 20;\n                if (maxLines < 0) maxLines = past.length; // can't ever have more input lines than this! \n                else if (!maxLines) maxLines = 1;\n                // `substr` anticipation: treat \\r\\n as a single character and take a little\n                // more than necessary so that we can still properly check against maxSize\n                // after we've transformed and limited the newLines in here:\n                past = past.substr(-maxSize * 2 - 2);\n                // now that we have a significantly reduced string to process, transform the newlines\n                // and chop them, then limit them:\n                var a = past.replace(/\\r\\n|\\r/g, \"\\n\").split(\"\\n\");\n                a = a.slice(-maxLines);\n                past = a.join(\"\\n\");\n                // When, after limiting to maxLines, we still have too much to return,\n                // do add an ellipsis prefix...\n                if (past.length > maxSize) {\n                    past = \"...\" + past.substr(-maxSize);\n                }\n                return past;\n            },\n            /**\n     * return (part of the) upcoming input, i.e. for error messages.\n     * \n     * Limit the returned string length to `maxSize` (default: 20).\n     * \n     * Limit the returned string to the `maxLines` number of lines of input (default: 1).\n     * \n     * Negative limit values equal *unlimited*.\n     *\n     * > ### NOTE ###\n     * >\n     * > *\"upcoming input\"* is defined as the whole of the both\n     * > the *currently lexed* input, together with any remaining input\n     * > following that. *\"currently lexed\"* input is the input \n     * > already recognized by the lexer but not yet returned with\n     * > the lexer token. This happens when you are invoking this API\n     * > from inside any lexer rule action code block. \n     * >\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ upcomingInput: function lexer_upcomingInput(maxSize, maxLines) {\n                var next = this.match;\n                if (maxSize < 0) maxSize = next.length + this._input.length;\n                else if (!maxSize) maxSize = 20;\n                if (maxLines < 0) maxLines = maxSize; // can't ever have more input lines than this! \n                else if (!maxLines) maxLines = 1;\n                // `substring` anticipation: treat \\r\\n as a single character and take a little\n                // more than necessary so that we can still properly check against maxSize\n                // after we've transformed and limited the newLines in here:\n                if (next.length < maxSize * 2 + 2) {\n                    next += this._input.substring(0, maxSize * 2 + 2); // substring is faster on Chrome/V8 \n                }\n                // now that we have a significantly reduced string to process, transform the newlines\n                // and chop them, then limit them:\n                var a = next.replace(/\\r\\n|\\r/g, \"\\n\").split(\"\\n\");\n                a = a.slice(0, maxLines);\n                next = a.join(\"\\n\");\n                // When, after limiting to maxLines, we still have too much to return,\n                // do add an ellipsis postfix...\n                if (next.length > maxSize) {\n                    next = next.substring(0, maxSize) + \"...\";\n                }\n                return next;\n            },\n            /**\n     * return a string which displays the character position where the\n     * lexing error occurred, i.e. for error messages\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ showPosition: function lexer_showPosition(maxPrefix, maxPostfix) {\n                var pre = this.pastInput(maxPrefix).replace(/\\s/g, \" \");\n                var c = new Array(pre.length + 1).join(\"-\");\n                return pre + this.upcomingInput(maxPostfix).replace(/\\s/g, \" \") + \"\\n\" + c + \"^\";\n            },\n            /**\n     * return an YYLLOC info object derived off the given context (actual, preceding, following, current).\n     * Use this method when the given `actual` location is not guaranteed to exist (i.e. when\n     * it MAY be NULL) and you MUST have a valid location info object anyway:\n     * then we take the given context of the `preceding` and `following` locations, IFF those are available,\n     * and reconstruct the `actual` location info from those.\n     * If this fails, the heuristic is to take the `current` location, IFF available.\n     * If this fails as well, we assume the sought location is at/around the current lexer position\n     * and then produce that one as a response. DO NOTE that these heuristic/derived location info\n     * values MAY be inaccurate!\n     *\n     * NOTE: `deriveLocationInfo()` ALWAYS produces a location info object *copy* of `actual`, not just\n     * a *reference* hence all input location objects can be assumed to be 'constant' (function has no side-effects).\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ deriveLocationInfo: function lexer_deriveYYLLOC(actual, preceding, following, current) {\n                var loc = {\n                    first_line: 1,\n                    first_column: 0,\n                    last_line: 1,\n                    last_column: 0,\n                    range: [\n                        0,\n                        0\n                    ]\n                };\n                if (actual) {\n                    loc.first_line = actual.first_line | 0;\n                    loc.last_line = actual.last_line | 0;\n                    loc.first_column = actual.first_column | 0;\n                    loc.last_column = actual.last_column | 0;\n                    if (actual.range) {\n                        loc.range[0] = actual.range[0] | 0;\n                        loc.range[1] = actual.range[1] | 0;\n                    }\n                }\n                if (loc.first_line <= 0 || loc.last_line < loc.first_line) {\n                    // plan B: heuristic using preceding and following:\n                    if (loc.first_line <= 0 && preceding) {\n                        loc.first_line = preceding.last_line | 0;\n                        loc.first_column = preceding.last_column | 0;\n                        if (preceding.range) {\n                            loc.range[0] = actual.range[1] | 0;\n                        }\n                    }\n                    if ((loc.last_line <= 0 || loc.last_line < loc.first_line) && following) {\n                        loc.last_line = following.first_line | 0;\n                        loc.last_column = following.first_column | 0;\n                        if (following.range) {\n                            loc.range[1] = actual.range[0] | 0;\n                        }\n                    }\n                    // plan C?: see if the 'current' location is useful/sane too:\n                    if (loc.first_line <= 0 && current && (loc.last_line <= 0 || current.last_line <= loc.last_line)) {\n                        loc.first_line = current.first_line | 0;\n                        loc.first_column = current.first_column | 0;\n                        if (current.range) {\n                            loc.range[0] = current.range[0] | 0;\n                        }\n                    }\n                    if (loc.last_line <= 0 && current && (loc.first_line <= 0 || current.first_line >= loc.first_line)) {\n                        loc.last_line = current.last_line | 0;\n                        loc.last_column = current.last_column | 0;\n                        if (current.range) {\n                            loc.range[1] = current.range[1] | 0;\n                        }\n                    }\n                }\n                // sanitize: fix last_line BEFORE we fix first_line as we use the 'raw' value of the latter\n                // or plan D heuristics to produce a 'sensible' last_line value:\n                if (loc.last_line <= 0) {\n                    if (loc.first_line <= 0) {\n                        loc.first_line = this.yylloc.first_line;\n                        loc.last_line = this.yylloc.last_line;\n                        loc.first_column = this.yylloc.first_column;\n                        loc.last_column = this.yylloc.last_column;\n                        loc.range[0] = this.yylloc.range[0];\n                        loc.range[1] = this.yylloc.range[1];\n                    } else {\n                        loc.last_line = this.yylloc.last_line;\n                        loc.last_column = this.yylloc.last_column;\n                        loc.range[1] = this.yylloc.range[1];\n                    }\n                }\n                if (loc.first_line <= 0) {\n                    loc.first_line = loc.last_line;\n                    loc.first_column = 0; // loc.last_column; \n                    loc.range[1] = loc.range[0];\n                }\n                if (loc.first_column < 0) {\n                    loc.first_column = 0;\n                }\n                if (loc.last_column < 0) {\n                    loc.last_column = loc.first_column > 0 ? loc.first_column : 80;\n                }\n                return loc;\n            },\n            /**\n     * return a string which displays the lines & columns of input which are referenced \n     * by the given location info range, plus a few lines of context.\n     * \n     * This function pretty-prints the indicated section of the input, with line numbers \n     * and everything!\n     * \n     * This function is very useful to provide highly readable error reports, while\n     * the location range may be specified in various flexible ways:\n     * \n     * - `loc` is the location info object which references the area which should be\n     *   displayed and 'marked up': these lines & columns of text are marked up by `^`\n     *   characters below each character in the entire input range.\n     * \n     * - `context_loc` is the *optional* location info object which instructs this\n     *   pretty-printer how much *leading* context should be displayed alongside\n     *   the area referenced by `loc`. This can help provide context for the displayed\n     *   error, etc.\n     * \n     *   When this location info is not provided, a default context of 3 lines is\n     *   used.\n     * \n     * - `context_loc2` is another *optional* location info object, which serves\n     *   a similar purpose to `context_loc`: it specifies the amount of *trailing*\n     *   context lines to display in the pretty-print output.\n     * \n     *   When this location info is not provided, a default context of 1 line only is\n     *   used.\n     * \n     * Special Notes:\n     * \n     * - when the `loc`-indicated range is very large (about 5 lines or more), then\n     *   only the first and last few lines of this block are printed while a\n     *   `...continued...` message will be printed between them.\n     * \n     *   This serves the purpose of not printing a huge amount of text when the `loc`\n     *   range happens to be huge: this way a manageable & readable output results\n     *   for arbitrary large ranges.\n     * \n     * - this function can display lines of input which whave not yet been lexed.\n     *   `prettyPrintRange()` can access the entire input!\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ prettyPrintRange: function lexer_prettyPrintRange(loc, context_loc, context_loc2) {\n                loc = this.deriveLocationInfo(loc, context_loc, context_loc2);\n                const CONTEXT = 3;\n                const CONTEXT_TAIL = 1;\n                const MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT = 2;\n                var input = this.matched + this._input;\n                var lines = input.split(\"\\n\");\n                var l0 = Math.max(1, context_loc ? context_loc.first_line : loc.first_line - CONTEXT);\n                var l1 = Math.max(1, context_loc2 ? context_loc2.last_line : loc.last_line + CONTEXT_TAIL);\n                var lineno_display_width = 1 + Math.log10(l1 | 1) | 0;\n                var ws_prefix = new Array(lineno_display_width).join(\" \");\n                var nonempty_line_indexes = [];\n                var rv = lines.slice(l0 - 1, l1 + 1).map(function injectLineNumber(line, index) {\n                    var lno = index + l0;\n                    var lno_pfx = (ws_prefix + lno).substr(-lineno_display_width);\n                    var rv = lno_pfx + \": \" + line;\n                    var errpfx = new Array(lineno_display_width + 1).join(\"^\");\n                    var offset = 2 + 1;\n                    var len = 0;\n                    if (lno === loc.first_line) {\n                        offset += loc.first_column;\n                        len = Math.max(2, (lno === loc.last_line ? loc.last_column : line.length) - loc.first_column + 1);\n                    } else if (lno === loc.last_line) {\n                        len = Math.max(2, loc.last_column + 1);\n                    } else if (lno > loc.first_line && lno < loc.last_line) {\n                        len = Math.max(2, line.length + 1);\n                    }\n                    if (len) {\n                        var lead = new Array(offset).join(\".\");\n                        var mark = new Array(len).join(\"^\");\n                        rv += \"\\n\" + errpfx + lead + mark;\n                        if (line.trim().length > 0) {\n                            nonempty_line_indexes.push(index);\n                        }\n                    }\n                    rv = rv.replace(/\\t/g, \" \");\n                    return rv;\n                });\n                // now make sure we don't print an overly large amount of error area: limit it \n                // to the top and bottom line count:\n                if (nonempty_line_indexes.length > 2 * MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT) {\n                    var clip_start = nonempty_line_indexes[MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT - 1] + 1;\n                    var clip_end = nonempty_line_indexes[nonempty_line_indexes.length - MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT] - 1;\n                    var intermediate_line = new Array(lineno_display_width + 1).join(\" \") + \"  (...continued...)\";\n                    intermediate_line += \"\\n\" + new Array(lineno_display_width + 1).join(\"-\") + \"  (---------------)\";\n                    rv.splice(clip_start, clip_end - clip_start + 1, intermediate_line);\n                }\n                return rv.join(\"\\n\");\n            },\n            /**\n     * helper function, used to produce a human readable description as a string, given\n     * the input `yylloc` location object.\n     * \n     * Set `display_range_too` to TRUE to include the string character index position(s)\n     * in the description if the `yylloc.range` is available.\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ describeYYLLOC: function lexer_describe_yylloc(yylloc, display_range_too) {\n                var l1 = yylloc.first_line;\n                var l2 = yylloc.last_line;\n                var c1 = yylloc.first_column;\n                var c2 = yylloc.last_column;\n                var dl = l2 - l1;\n                var dc = c2 - c1;\n                var rv;\n                if (dl === 0) {\n                    rv = \"line \" + l1 + \", \";\n                    if (dc <= 1) {\n                        rv += \"column \" + c1;\n                    } else {\n                        rv += \"columns \" + c1 + \" .. \" + c2;\n                    }\n                } else {\n                    rv = \"lines \" + l1 + \"(column \" + c1 + \") .. \" + l2 + \"(column \" + c2 + \")\";\n                }\n                if (yylloc.range && display_range_too) {\n                    var r1 = yylloc.range[0];\n                    var r2 = yylloc.range[1] - 1;\n                    if (r2 <= r1) {\n                        rv += \" {String Offset: \" + r1 + \"}\";\n                    } else {\n                        rv += \" {String Offset range: \" + r1 + \" .. \" + r2 + \"}\";\n                    }\n                }\n                return rv;\n            },\n            /**\n     * test the lexed token: return FALSE when not a match, otherwise return token.\n     * \n     * `match` is supposed to be an array coming out of a regex match, i.e. `match[0]`\n     * contains the actually matched text string.\n     * \n     * Also move the input cursor forward and update the match collectors:\n     * \n     * - `yytext`\n     * - `yyleng`\n     * - `match`\n     * - `matches`\n     * - `yylloc`\n     * - `offset`\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ test_match: function lexer_test_match(match, indexed_rule) {\n                var token, lines, backup, match_str, match_str_len;\n                if (this.options.backtrack_lexer) {\n                    // save context\n                    backup = {\n                        yylineno: this.yylineno,\n                        yylloc: {\n                            first_line: this.yylloc.first_line,\n                            last_line: this.yylloc.last_line,\n                            first_column: this.yylloc.first_column,\n                            last_column: this.yylloc.last_column,\n                            range: this.yylloc.range.slice(0)\n                        },\n                        yytext: this.yytext,\n                        match: this.match,\n                        matches: this.matches,\n                        matched: this.matched,\n                        yyleng: this.yyleng,\n                        offset: this.offset,\n                        _more: this._more,\n                        _input: this._input,\n                        //_signaled_error_token: this._signaled_error_token,\n                        yy: this.yy,\n                        conditionStack: this.conditionStack.slice(0),\n                        done: this.done\n                    };\n                }\n                match_str = match[0];\n                match_str_len = match_str.length;\n                // if (match_str.indexOf('\\n') !== -1 || match_str.indexOf('\\r') !== -1) {\n                lines = match_str.split(/(?:\\r\\n?|\\n)/g);\n                if (lines.length > 1) {\n                    this.yylineno += lines.length - 1;\n                    this.yylloc.last_line = this.yylineno + 1;\n                    this.yylloc.last_column = lines[lines.length - 1].length;\n                } else {\n                    this.yylloc.last_column += match_str_len;\n                }\n                // }\n                this.yytext += match_str;\n                this.match += match_str;\n                this.matched += match_str;\n                this.matches = match;\n                this.yyleng = this.yytext.length;\n                this.yylloc.range[1] += match_str_len;\n                // previous lex rules MAY have invoked the `more()` API rather than producing a token:\n                // those rules will already have moved this `offset` forward matching their match lengths,\n                // hence we must only add our own match length now:\n                this.offset += match_str_len;\n                this._more = false;\n                this._backtrack = false;\n                this._input = this._input.slice(match_str_len);\n                // calling this method:\n                //\n                //   function lexer__performAction(yy, yyrulenumber, YY_START) {...}\n                token = this.performAction.call(this, this.yy, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);\n                // otherwise, when the action codes are all simple return token statements:\n                //token = this.simpleCaseActionClusters[indexed_rule];\n                if (this.done && this._input) {\n                    this.done = false;\n                }\n                if (token) {\n                    return token;\n                } else if (this._backtrack) {\n                    // recover context\n                    for(var k in backup){\n                        this[k] = backup[k];\n                    }\n                    this.__currentRuleSet__ = null;\n                    return false; // rule action called reject() implying the next rule should be tested instead. \n                } else if (this._signaled_error_token) {\n                    // produce one 'error' token as `.parseError()` in `reject()`\n                    // did not guarantee a failure signal by throwing an exception!\n                    token = this._signaled_error_token;\n                    this._signaled_error_token = false;\n                    return token;\n                }\n                return false;\n            },\n            /**\n     * return next match in input\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ next: function lexer_next() {\n                if (this.done) {\n                    this.clear();\n                    return this.EOF;\n                }\n                if (!this._input) {\n                    this.done = true;\n                }\n                var token, match, tempMatch, index;\n                if (!this._more) {\n                    this.clear();\n                }\n                var spec = this.__currentRuleSet__;\n                if (!spec) {\n                    // Update the ruleset cache as we apparently encountered a state change or just started lexing.\n                    // The cache is set up for fast lookup -- we assume a lexer will switch states much less often than it will\n                    // invoke the `lex()` token-producing API and related APIs, hence caching the set for direct access helps\n                    // speed up those activities a tiny bit.\n                    spec = this.__currentRuleSet__ = this._currentRules();\n                    // Check whether a *sane* condition has been pushed before: this makes the lexer robust against\n                    // user-programmer bugs such as https://github.com/zaach/jison-lex/issues/19\n                    if (!spec || !spec.rules) {\n                        var lineno_msg = \"\";\n                        if (this.options.trackPosition) {\n                            lineno_msg = \" on line \" + (this.yylineno + 1);\n                        }\n                        var p = this.constructLexErrorInfo(\"Internal lexer engine error\" + lineno_msg + ': The lex grammar programmer pushed a non-existing condition name \"' + this.topState() + '\"; this is a fatal error and should be reported to the application programmer team!', false);\n                        // produce one 'error' token until this situation has been resolved, most probably by parse termination!\n                        return this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;\n                    }\n                }\n                var rule_ids = spec.rules;\n                var regexes = spec.__rule_regexes;\n                var len = spec.__rule_count;\n                // Note: the arrays are 1-based, while `len` itself is a valid index,\n                // hence the non-standard less-or-equal check in the next loop condition!\n                for(var i = 1; i <= len; i++){\n                    tempMatch = this._input.match(regexes[i]);\n                    if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n                        match = tempMatch;\n                        index = i;\n                        if (this.options.backtrack_lexer) {\n                            token = this.test_match(tempMatch, rule_ids[i]);\n                            if (token !== false) {\n                                return token;\n                            } else if (this._backtrack) {\n                                match = undefined;\n                                continue; // rule action called reject() implying a rule MISmatch. \n                            } else {\n                                // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n                                return false;\n                            }\n                        } else if (!this.options.flex) {\n                            break;\n                        }\n                    }\n                }\n                if (match) {\n                    token = this.test_match(match, rule_ids[index]);\n                    if (token !== false) {\n                        return token;\n                    }\n                    // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n                    return false;\n                }\n                if (!this._input) {\n                    this.done = true;\n                    this.clear();\n                    return this.EOF;\n                } else {\n                    var lineno_msg = \"\";\n                    if (this.options.trackPosition) {\n                        lineno_msg = \" on line \" + (this.yylineno + 1);\n                    }\n                    var p = this.constructLexErrorInfo(\"Lexical error\" + lineno_msg + \": Unrecognized text.\", this.options.lexerErrorsAreRecoverable);\n                    var pendingInput = this._input;\n                    var activeCondition = this.topState();\n                    var conditionStackDepth = this.conditionStack.length;\n                    token = this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;\n                    if (token === this.ERROR) {\n                        // we can try to recover from a lexer error that `parseError()` did not 'recover' for us\n                        // by moving forward at least one character at a time IFF the (user-specified?) `parseError()`\n                        // has not consumed/modified any pending input or changed state in the error handler:\n                        if (!this.matches && // and make sure the input has been modified/consumed ...\n                        pendingInput === this._input && // ...or the lexer state has been modified significantly enough\n                        // to merit a non-consuming error handling action right now.\n                        activeCondition === this.topState() && conditionStackDepth === this.conditionStack.length) {\n                            this.input();\n                        }\n                    }\n                    return token;\n                }\n            },\n            /**\n     * return next match that has a token\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ lex: function lexer_lex() {\n                var r;\n                // allow the PRE/POST handlers set/modify the return token for maximum flexibility of the generated lexer:\n                if (typeof this.pre_lex === \"function\") {\n                    r = this.pre_lex.call(this, 0);\n                }\n                if (typeof this.options.pre_lex === \"function\") {\n                    // (also account for a userdef function which does not return any value: keep the token as is)\n                    r = this.options.pre_lex.call(this, r) || r;\n                }\n                if (this.yy && typeof this.yy.pre_lex === \"function\") {\n                    // (also account for a userdef function which does not return any value: keep the token as is)\n                    r = this.yy.pre_lex.call(this, r) || r;\n                }\n                while(!r){\n                    r = this.next();\n                }\n                if (this.yy && typeof this.yy.post_lex === \"function\") {\n                    // (also account for a userdef function which does not return any value: keep the token as is)\n                    r = this.yy.post_lex.call(this, r) || r;\n                }\n                if (typeof this.options.post_lex === \"function\") {\n                    // (also account for a userdef function which does not return any value: keep the token as is)\n                    r = this.options.post_lex.call(this, r) || r;\n                }\n                if (typeof this.post_lex === \"function\") {\n                    // (also account for a userdef function which does not return any value: keep the token as is)\n                    r = this.post_lex.call(this, r) || r;\n                }\n                return r;\n            },\n            /**\n     * return next match that has a token. Identical to the `lex()` API but does not invoke any of the \n     * `pre_lex()` nor any of the `post_lex()` callbacks.\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ fastLex: function lexer_fastLex() {\n                var r;\n                while(!r){\n                    r = this.next();\n                }\n                return r;\n            },\n            /**\n     * return info about the lexer state that can help a parser or other lexer API user to use the\n     * most efficient means available. This API is provided to aid run-time performance for larger\n     * systems which employ this lexer.\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ canIUse: function lexer_canIUse() {\n                var rv = {\n                    fastLex: !(typeof this.pre_lex === \"function\" || typeof this.options.pre_lex === \"function\" || this.yy && typeof this.yy.pre_lex === \"function\" || this.yy && typeof this.yy.post_lex === \"function\" || typeof this.options.post_lex === \"function\" || typeof this.post_lex === \"function\") && typeof this.fastLex === \"function\"\n                };\n                return rv;\n            },\n            /**\n     * backwards compatible alias for `pushState()`;\n     * the latter is symmetrical with `popState()` and we advise to use\n     * those APIs in any modern lexer code, rather than `begin()`.\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ begin: function lexer_begin(condition) {\n                return this.pushState(condition);\n            },\n            /**\n     * activates a new lexer condition state (pushes the new lexer\n     * condition state onto the condition stack)\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ pushState: function lexer_pushState(condition) {\n                this.conditionStack.push(condition);\n                this.__currentRuleSet__ = null;\n                return this;\n            },\n            /**\n     * pop the previously active lexer condition state off the condition\n     * stack\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ popState: function lexer_popState() {\n                var n = this.conditionStack.length - 1;\n                if (n > 0) {\n                    this.__currentRuleSet__ = null;\n                    return this.conditionStack.pop();\n                } else {\n                    return this.conditionStack[0];\n                }\n            },\n            /**\n     * return the currently active lexer condition state; when an index\n     * argument is provided it produces the N-th previous condition state,\n     * if available\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ topState: function lexer_topState(n) {\n                n = this.conditionStack.length - 1 - Math.abs(n || 0);\n                if (n >= 0) {\n                    return this.conditionStack[n];\n                } else {\n                    return \"INITIAL\";\n                }\n            },\n            /**\n     * (internal) determine the lexer rule set which is active for the\n     * currently active lexer condition state\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ _currentRules: function lexer__currentRules() {\n                if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\n                    return this.conditions[this.conditionStack[this.conditionStack.length - 1]];\n                } else {\n                    return this.conditions[\"INITIAL\"];\n                }\n            },\n            /**\n     * return the number of states currently on the stack\n     * \n     * @public\n     * @this {RegExpLexer}\n     */ stateStackSize: function lexer_stateStackSize() {\n                return this.conditionStack.length;\n            },\n            options: {\n                trackPosition: true\n            },\n            JisonLexerError: JisonLexerError,\n            performAction: function lexer__performAction(yy, yyrulenumber, YY_START) {\n                var yy_ = this;\n                var YYSTATE = YY_START;\n                switch(yyrulenumber){\n                    case 1:\n                        break;\n                    default:\n                        return this.simpleCaseActionClusters[yyrulenumber];\n                }\n            },\n            simpleCaseActionClusters: {\n                /*! Conditions:: INITIAL */ /*! Rule::       (--[0-9a-z-A-Z-]*) */ 0: 13,\n                /*! Conditions:: INITIAL */ /*! Rule::       \\* */ 2: 5,\n                /*! Conditions:: INITIAL */ /*! Rule::       \\/ */ 3: 6,\n                /*! Conditions:: INITIAL */ /*! Rule::       \\+ */ 4: 3,\n                /*! Conditions:: INITIAL */ /*! Rule::       - */ 5: 4,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)px\\b */ 6: 15,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)cm\\b */ 7: 15,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)mm\\b */ 8: 15,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)in\\b */ 9: 15,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)pt\\b */ 10: 15,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)pc\\b */ 11: 15,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)deg\\b */ 12: 16,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)grad\\b */ 13: 16,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)rad\\b */ 14: 16,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)turn\\b */ 15: 16,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)s\\b */ 16: 17,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)ms\\b */ 17: 17,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)Hz\\b */ 18: 18,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)kHz\\b */ 19: 18,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)dpi\\b */ 20: 19,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)dpcm\\b */ 21: 19,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)dppx\\b */ 22: 19,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)em\\b */ 23: 20,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)ex\\b */ 24: 21,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)ch\\b */ 25: 22,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)rem\\b */ 26: 23,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)vw\\b */ 27: 25,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)vh\\b */ 28: 24,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)vmin\\b */ 29: 26,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)vmax\\b */ 30: 27,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)% */ 31: 28,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)\\b */ 32: 11,\n                /*! Conditions:: INITIAL */ /*! Rule::       (calc) */ 33: 9,\n                /*! Conditions:: INITIAL */ /*! Rule::       (var) */ 34: 12,\n                /*! Conditions:: INITIAL */ /*! Rule::       ([a-z]+) */ 35: 10,\n                /*! Conditions:: INITIAL */ /*! Rule::       \\( */ 36: 7,\n                /*! Conditions:: INITIAL */ /*! Rule::       \\) */ 37: 8,\n                /*! Conditions:: INITIAL */ /*! Rule::       , */ 38: 14,\n                /*! Conditions:: INITIAL */ /*! Rule::       $ */ 39: 1\n            },\n            rules: [\n                /*  0: */ /^(?:(--[\\d\\-A-Za-z]*))/,\n                /*  1: */ /^(?:\\s+)/,\n                /*  2: */ /^(?:\\*)/,\n                /*  3: */ /^(?:\\/)/,\n                /*  4: */ /^(?:\\+)/,\n                /*  5: */ /^(?:-)/,\n                /*  6: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)px\\b)/,\n                /*  7: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)cm\\b)/,\n                /*  8: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)mm\\b)/,\n                /*  9: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)in\\b)/,\n                /* 10: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)pt\\b)/,\n                /* 11: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)pc\\b)/,\n                /* 12: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)deg\\b)/,\n                /* 13: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)grad\\b)/,\n                /* 14: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)rad\\b)/,\n                /* 15: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)turn\\b)/,\n                /* 16: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)s\\b)/,\n                /* 17: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)ms\\b)/,\n                /* 18: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)Hz\\b)/,\n                /* 19: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)kHz\\b)/,\n                /* 20: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)dpi\\b)/,\n                /* 21: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)dpcm\\b)/,\n                /* 22: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)dppx\\b)/,\n                /* 23: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)em\\b)/,\n                /* 24: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)ex\\b)/,\n                /* 25: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)ch\\b)/,\n                /* 26: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)rem\\b)/,\n                /* 27: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)vw\\b)/,\n                /* 28: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)vh\\b)/,\n                /* 29: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)vmin\\b)/,\n                /* 30: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)vmax\\b)/,\n                /* 31: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)%)/,\n                /* 32: */ /^(?:(\\d+(\\.\\d*)?|\\.\\d+)\\b)/,\n                /* 33: */ /^(?:(calc))/,\n                /* 34: */ /^(?:(var))/,\n                /* 35: */ /^(?:([a-z]+))/,\n                /* 36: */ /^(?:\\()/,\n                /* 37: */ /^(?:\\))/,\n                /* 38: */ /^(?:,)/,\n                /* 39: */ /^(?:$)/\n            ],\n            conditions: {\n                \"INITIAL\": {\n                    rules: [\n                        0,\n                        1,\n                        2,\n                        3,\n                        4,\n                        5,\n                        6,\n                        7,\n                        8,\n                        9,\n                        10,\n                        11,\n                        12,\n                        13,\n                        14,\n                        15,\n                        16,\n                        17,\n                        18,\n                        19,\n                        20,\n                        21,\n                        22,\n                        23,\n                        24,\n                        25,\n                        26,\n                        27,\n                        28,\n                        29,\n                        30,\n                        31,\n                        32,\n                        33,\n                        34,\n                        35,\n                        36,\n                        37,\n                        38,\n                        39\n                    ],\n                    inclusive: true\n                }\n            }\n        };\n        return lexer;\n    }();\n    parser.lexer = lexer;\n    function Parser() {\n        this.yy = {};\n    }\n    Parser.prototype = parser;\n    parser.Parser = Parser;\n    return new Parser();\n}();\nif (true) {\n    exports.parser = parser;\n    exports.Parser = parser.Parser;\n    exports.parse = function() {\n        return parser.parse.apply(parser, arguments);\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVkdWNlLWNzcy1jYWxjL2Rpc3QvcGFyc2VyLmpzIiwibWFwcGluZ3MiOiJBQUNBLHVDQUF1QyxHQUV2Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXFYQyxHQUlXLElBQUlBLFNBQVM7SUFHekIsWUFBWTtJQUNaLHNHQUFzRztJQUN0RyxrR0FBa0c7SUFDbEcsOEVBQThFO0lBQzlFLFNBQVNDLGlCQUFpQkMsR0FBRyxFQUFFQyxJQUFJO1FBQy9CQyxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFFBQVE7WUFDaENDLFlBQVk7WUFDWkMsVUFBVTtZQUNWQyxPQUFPO1FBQ1g7UUFFQSxJQUFJTixPQUFPLE1BQU1BLE1BQU07UUFFdkJFLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsV0FBVztZQUNuQ0MsWUFBWTtZQUNaQyxVQUFVO1lBQ1ZDLE9BQU9OO1FBQ1g7UUFFQSxJQUFJLENBQUNDLElBQUksR0FBR0E7UUFFWixJQUFJTTtRQUNKLElBQUlOLFFBQVFBLEtBQUtPLFNBQVMsWUFBWUMsT0FBTztZQUN6QyxJQUFJQyxNQUFNVCxLQUFLTyxTQUFTO1lBQ3hCLElBQUksQ0FBQ0csT0FBTyxHQUFHRCxJQUFJQyxPQUFPLElBQUlYO1lBQzlCTyxhQUFhRyxJQUFJRSxLQUFLO1FBQzFCO1FBQ0EsSUFBSSxDQUFDTCxZQUFZO1lBQ2IsSUFBSUUsTUFBTUksY0FBYyxDQUFDLHNCQUFzQjtnQkFDM0NKLE1BQU1LLGlCQUFpQixDQUFDLElBQUksRUFBRSxJQUFJLENBQUNDLFdBQVc7WUFDbEQsT0FBTztnQkFDSFIsYUFBYSxJQUFLRSxNQUFNVCxLQUFNWSxLQUFLO1lBQ3ZDO1FBQ0o7UUFDQSxJQUFJTCxZQUFZO1lBQ1pMLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsU0FBUztnQkFDakNDLFlBQVk7Z0JBQ1pDLFVBQVU7Z0JBQ1ZDLE9BQU9DO1lBQ1g7UUFDSjtJQUNKO0lBRUEsSUFBSSxPQUFPTCxPQUFPYyxjQUFjLEtBQUssWUFBWTtRQUM3Q2QsT0FBT2MsY0FBYyxDQUFDakIsaUJBQWlCa0IsU0FBUyxFQUFFUixNQUFNUSxTQUFTO0lBQ3JFLE9BQU87UUFDSGxCLGlCQUFpQmtCLFNBQVMsR0FBR2YsT0FBT2dCLE1BQU0sQ0FBQ1QsTUFBTVEsU0FBUztJQUM5RDtJQUNBbEIsaUJBQWlCa0IsU0FBUyxDQUFDRixXQUFXLEdBQUdoQjtJQUN6Q0EsaUJBQWlCa0IsU0FBUyxDQUFDRSxJQUFJLEdBQUc7SUFLMUIsOENBQThDO0lBQzlDLFNBQVNDLEdBQUdDLENBQUM7UUFDVCxJQUFJQyxLQUFLLEVBQUU7UUFDWCxJQUFJQyxJQUFJRixFQUFFRyxHQUFHO1FBQ2IsSUFBSUMsSUFBSUosRUFBRUssSUFBSTtRQUNkLElBQUssSUFBSUMsSUFBSSxHQUFHQyxJQUFJTCxFQUFFTSxNQUFNLEVBQUVGLElBQUlDLEdBQUdELElBQUs7WUFDdENMLEdBQUdRLElBQUksQ0FBQztnQkFDSlAsQ0FBQyxDQUFDSSxFQUFFO2dCQUNKRixDQUFDLENBQUNFLEVBQUU7YUFDUDtRQUNMO1FBQ0EsT0FBT0w7SUFDWDtJQUlBLGlEQUFpRDtJQUNqRCxTQUFTUyxJQUFJVixDQUFDO1FBQ1YsSUFBSUMsS0FBSyxDQUFDO1FBQ1YsSUFBSVUsSUFBSVgsRUFBRVksR0FBRztRQUNiLElBQUlDLElBQUliLEVBQUVjLElBQUk7UUFDZCxJQUFLLElBQUlSLElBQUksR0FBR0MsSUFBSUksRUFBRUgsTUFBTSxFQUFFRixJQUFJQyxHQUFHRCxJQUFLO1lBQ3RDLElBQUlTLElBQUlKLENBQUMsQ0FBQ0wsRUFBRTtZQUNaTCxFQUFFLENBQUNjLEVBQUUsR0FBR0YsQ0FBQyxDQUFDUCxFQUFFO1FBQ2hCO1FBQ0EsT0FBT0w7SUFDWDtJQUlBLHVDQUF1QztJQUN2QyxTQUFTZSxHQUFHaEIsQ0FBQztRQUNULElBQUlDLEtBQUssRUFBRTtRQUNYLElBQUlVLElBQUlYLEVBQUVpQixHQUFHO1FBQ2IsSUFBSUMsSUFBSWxCLEVBQUVtQixNQUFNO1FBQ2hCLElBQUlDLElBQUlwQixFQUFFcUIsSUFBSTtRQUNkLElBQUlDLElBQUl0QixFQUFFdUIsS0FBSztRQUNmLElBQUlDLElBQUl4QixFQUFFeUIsSUFBSTtRQUNkLElBQUlaLElBQUliLEVBQUVjLElBQUk7UUFDZCxJQUFLLElBQUlSLElBQUksR0FBR0MsSUFBSUksRUFBRUgsTUFBTSxFQUFFRixJQUFJQyxHQUFHRCxJQUFLO1lBQ3RDLElBQUlvQixJQUFJZixDQUFDLENBQUNMLEVBQUU7WUFDWixJQUFJcUIsSUFBSSxDQUFDO1lBQ1QsSUFBSyxJQUFJWixJQUFJLEdBQUdBLElBQUlXLEdBQUdYLElBQUs7Z0JBQ3hCLElBQUlhLElBQUlWLEVBQUVXLEtBQUs7Z0JBQ2YsT0FBUVQsRUFBRVMsS0FBSztvQkFDZixLQUFLO3dCQUNERixDQUFDLENBQUNDLEVBQUUsR0FBRzs0QkFDSEosRUFBRUssS0FBSzs0QkFDUGhCLEVBQUVnQixLQUFLO3lCQUNWO3dCQUNEO29CQUVKLEtBQUs7d0JBQ0RGLENBQUMsQ0FBQ0MsRUFBRSxHQUFHTixFQUFFTyxLQUFLO3dCQUNkO29CQUVKO3dCQUNJLHFCQUFxQjt3QkFDckJGLENBQUMsQ0FBQ0MsRUFBRSxHQUFHOzRCQUNIO3lCQUNIO2dCQUNMO1lBQ0o7WUFDQTNCLEdBQUdRLElBQUksQ0FBQ2tCO1FBQ1o7UUFDQSxPQUFPMUI7SUFDWDtJQUlBLHdGQUF3RjtJQUN4Riw2QkFBNkI7SUFDN0IsU0FBU0QsRUFBRThCLENBQUMsRUFBRXZCLENBQUMsRUFBRWUsQ0FBQztRQUNkQSxJQUFJQSxLQUFLO1FBQ1QsSUFBSyxJQUFJaEIsSUFBSSxHQUFHQSxJQUFJQyxHQUFHRCxJQUFLO1lBQ3hCLElBQUksQ0FBQ0csSUFBSSxDQUFDcUI7WUFDVkEsS0FBS1I7UUFDVDtJQUNKO0lBRUEsZ0VBQWdFO0lBQ2hFLDZCQUE2QjtJQUM3QixTQUFTUSxFQUFFeEIsQ0FBQyxFQUFFQyxDQUFDO1FBQ1hELElBQUksSUFBSSxDQUFDRSxNQUFNLEdBQUdGO1FBQ2xCLElBQUtDLEtBQUtELEdBQUdBLElBQUlDLEdBQUdELElBQUs7WUFDckIsSUFBSSxDQUFDRyxJQUFJLENBQUMsSUFBSSxDQUFDSCxFQUFFO1FBQ3JCO0lBQ0o7SUFFQSx1RkFBdUY7SUFDdkYsU0FBU3lCLEVBQUVULENBQUM7UUFDUixJQUFJckIsS0FBSyxFQUFFO1FBQ1gsSUFBSyxJQUFJSyxJQUFJLEdBQUdDLElBQUllLEVBQUVkLE1BQU0sRUFBRUYsSUFBSUMsR0FBR0QsSUFBSztZQUN0QyxJQUFJMEIsSUFBSVYsQ0FBQyxDQUFDaEIsRUFBRTtZQUNaLG1DQUFtQztZQUNuQyxJQUFJLE9BQU8wQixNQUFNLFlBQVk7Z0JBQ3pCMUI7Z0JBQ0EwQixFQUFFQyxLQUFLLENBQUNoQyxJQUFJcUIsQ0FBQyxDQUFDaEIsRUFBRTtZQUNwQixPQUFPO2dCQUNITCxHQUFHUSxJQUFJLENBQUN1QjtZQUNaO1FBQ0o7UUFDQSxPQUFPL0I7SUFDWDtJQUdSLElBQUl4QixTQUFTO1FBQ1Qsb0NBQW9DO1FBQ3BDLG9DQUFvQztRQUNwQyxFQUFFO1FBQ0YsV0FBVztRQUNYLEVBQUU7UUFDRiwyREFBMkQ7UUFDM0QsMERBQTBEO1FBQzFELDRDQUE0QztRQUM1Qyw0Q0FBNEM7UUFDNUMsNkNBQTZDO1FBQzdDLHlDQUF5QztRQUN6Qyx3REFBd0Q7UUFDeEQsNERBQTREO1FBQzVELHdEQUF3RDtRQUN4RCw2Q0FBNkM7UUFDN0MsNENBQTRDO1FBQzVDLDZDQUE2QztRQUM3Qyx5Q0FBeUM7UUFDekMsNkNBQTZDO1FBQzdDLDZDQUE2QztRQUM3QyxnREFBZ0Q7UUFDaEQsNENBQTRDO1FBQzVDLDRDQUE0QztRQUM1Qyw2Q0FBNkM7UUFDN0MsNERBQTREO1FBQzVELDZDQUE2QztRQUM3Qyx5Q0FBeUM7UUFDekMsRUFBRTtRQUNGLEVBQUU7UUFDRix5QkFBeUI7UUFDekIsRUFBRTtRQUNGLGdFQUFnRTtRQUNoRSw2Q0FBNkM7UUFDN0MsNkNBQTZDO1FBQzdDLDZDQUE2QztRQUM3Qyw2Q0FBNkM7UUFDN0MsNkNBQTZDO1FBQzdDLDZDQUE2QztRQUM3Qyw2Q0FBNkM7UUFDN0MsNkNBQTZDO1FBQzdDLDZDQUE2QztRQUM3Qyw2Q0FBNkM7UUFDN0MsNENBQTRDO1FBQzVDLDRDQUE0QztRQUM1Qyw2Q0FBNkM7UUFDN0MsNkNBQTZDO1FBQzdDLDZDQUE2QztRQUM3Qyw2Q0FBNkM7UUFDN0MsNENBQTRDO1FBQzVDLDZDQUE2QztRQUM3Qyw2Q0FBNkM7UUFDN0MsNkNBQTZDO1FBQzdDLDZDQUE2QztRQUM3QyxFQUFFO1FBQ0Ysc0NBQXNDO1FBRTFDeUQsT0FBTyxTQUFTQyxlQUFnQjtRQUNoQ3pELGtCQUFrQkE7UUFDbEIwRCxJQUFJLENBQUM7UUFDTEMsU0FBUztZQUNQaEIsTUFBTTtZQUNOaUIsK0JBQStCO1lBQy9CQyxnQ0FBZ0M7UUFDbEM7UUFDQUMsVUFBVTtZQUNSLFdBQVc7WUFDWCxRQUFRO1lBQ1IsT0FBTztZQUNQLFNBQVM7WUFDVCxPQUFPO1lBQ1AsU0FBUztZQUNULGFBQWE7WUFDYixXQUFXO1lBQ1gsT0FBTztZQUNQLE9BQU87WUFDUCxPQUFPO1lBQ1AsT0FBTztZQUNQLFFBQVE7WUFDUixVQUFVO1lBQ1YsVUFBVTtZQUNWLE9BQU87WUFDUCxlQUFlO1lBQ2YsVUFBVTtZQUNWLGNBQWM7WUFDZCxVQUFVO1lBQ1YsUUFBUTtZQUNSLE9BQU87WUFDUCxVQUFVO1lBQ1YsT0FBTztZQUNQLFFBQVE7WUFDUixPQUFPO1lBQ1AsU0FBUztZQUNULFNBQVM7WUFDVCxPQUFPO1lBQ1AsYUFBYTtZQUNiLGdCQUFnQjtZQUNoQixTQUFTO1lBQ1QsY0FBYztZQUNkLG1CQUFtQjtZQUNuQixTQUFTO1FBQ1g7UUFDQUMsWUFBWTtZQUNWLEdBQUc7WUFDSCxHQUFHO1lBQ0gsR0FBRztZQUNILEdBQUc7WUFDSCxHQUFHO1lBQ0gsR0FBRztZQUNILEdBQUc7WUFDSCxHQUFHO1lBQ0gsR0FBRztZQUNILElBQUk7WUFDSixJQUFJO1lBQ0osSUFBSTtZQUNKLElBQUk7WUFDSixJQUFJO1lBQ0osSUFBSTtZQUNKLElBQUk7WUFDSixJQUFJO1lBQ0osSUFBSTtZQUNKLElBQUk7WUFDSixJQUFJO1lBQ0osSUFBSTtZQUNKLElBQUk7WUFDSixJQUFJO1lBQ0osSUFBSTtZQUNKLElBQUk7WUFDSixJQUFJO1lBQ0osSUFBSTtZQUNKLElBQUk7UUFDTjtRQUNBQyxRQUFRO1FBQ0pDLEtBQUs7UUFFTCwyRkFBMkY7UUFDM0YsNkNBQTZDO1FBQzdDQyxtQkFBbUI7UUFDbkJDLG9CQUFvQjtRQUNwQkMsbUJBQW1CO1FBQ25CQyx5QkFBeUI7UUFDekJDLHFCQUFxQjtRQUVyQkMsd0JBQXdCO1FBQ3hCQyxlQUFlLEVBQUU7UUFDakJDLHdCQUF3QixFQUFFO1FBRTFCLG9FQUFvRTtRQUNwRSxrQkFBa0I7UUFDbEIsYUFBYTtRQUNiLGVBQWU7UUFFZixjQUFjO1FBQ2QsY0FBYztRQUVkLDRGQUE0RjtRQUM1Rix1Q0FBdUM7UUFDdkNDLFdBQVcsU0FBU0MsaUJBQWlCQyxNQUFNO1lBQ3ZDLE9BQU8sTUFBTUEsU0FBUztRQUMxQjtRQUVBLDhGQUE4RjtRQUM5RixFQUFFO1FBQ0Ysd0RBQXdEO1FBQ3hEQyxlQUFlLFNBQVNDLHFCQUFxQnJDLE1BQU07WUFDL0MsSUFBSSxJQUFJLENBQUNzQixVQUFVLENBQUN0QixPQUFPLEVBQUU7Z0JBQ3pCLE9BQU8sSUFBSSxDQUFDc0IsVUFBVSxDQUFDdEIsT0FBTztZQUNsQztZQUVBLG9HQUFvRztZQUNwRyxFQUFFO1lBQ0Ysa0ZBQWtGO1lBQ2xGLEVBQUU7WUFDRixnQ0FBZ0M7WUFDaEMsRUFBRTtZQUNGLCtEQUErRDtZQUMvRCxJQUFJbkIsSUFBSSxJQUFJLENBQUN3QyxRQUFRO1lBQ3JCLElBQUssSUFBSWlCLE9BQU96RCxFQUFHO2dCQUNmLElBQUlBLENBQUMsQ0FBQ3lELElBQUksS0FBS3RDLFFBQVE7b0JBQ25CLE9BQU9zQztnQkFDWDtZQUNKO1lBQ0EsT0FBTztRQUNYO1FBRUEsd0ZBQXdGO1FBQ3hGLG1HQUFtRztRQUNuRyxFQUFFO1FBQ0Ysd0RBQXdEO1FBQ3hEQyxnQkFBZ0IsU0FBU0Msc0JBQXNCeEMsTUFBTTtZQUNqRCxJQUFJQSxXQUFXLElBQUksQ0FBQ3dCLEdBQUcsSUFBSSxJQUFJLENBQUNpQixzQkFBc0IsSUFBSSxJQUFJLENBQUNBLHNCQUFzQixDQUFDekMsT0FBTyxFQUFFO2dCQUMzRixPQUFPLElBQUksQ0FBQ3lDLHNCQUFzQixDQUFDekMsT0FBTztZQUM5QyxPQUNLLElBQUlBLFdBQVcsSUFBSSxDQUFDd0IsR0FBRyxFQUFFO2dCQUMxQixPQUFPO1lBQ1g7WUFDQSxJQUFJa0IsS0FBSyxJQUFJLENBQUNOLGFBQWEsQ0FBQ3BDO1lBQzVCLElBQUkwQyxJQUFJO2dCQUNKLE9BQU8sSUFBSSxDQUFDVCxTQUFTLENBQUNTO1lBQzFCO1lBQ0EsT0FBTztRQUNYO1FBRUEsMkZBQTJGO1FBQzNGLEVBQUU7UUFDRixzRkFBc0Y7UUFDdEYsc0ZBQXNGO1FBQ3RGLHlGQUF5RjtRQUN6RixtREFBbUQ7UUFDbkQsRUFBRTtRQUNGLG9FQUFvRTtRQUNwRUMsNEJBQTRCLFNBQVNDLGtDQUFrQ3hDLEtBQUssRUFBRXlDLGVBQWU7WUFDekYsSUFBSXRCLFNBQVMsSUFBSSxDQUFDQSxNQUFNO1lBQ3hCLElBQUl1QixXQUFXLEVBQUU7WUFDakIsSUFBSUMsUUFBUSxDQUFDO1lBQ2IsNEdBQTRHO1lBQzVHLCtEQUErRDtZQUMvRCxJQUFJLENBQUNGLG1CQUFtQixJQUFJLENBQUNHLG1CQUFtQixJQUFJLElBQUksQ0FBQ0EsbUJBQW1CLENBQUM1QyxNQUFNLEVBQUU7Z0JBQ2pGLE9BQU87b0JBQ0gsSUFBSSxDQUFDNEMsbUJBQW1CLENBQUM1QyxNQUFNO2lCQUNsQztZQUNMO1lBQ0EsSUFBSyxJQUFJckIsS0FBSyxJQUFJLENBQUNrRSxLQUFLLENBQUM3QyxNQUFNLENBQUU7Z0JBQzdCckIsSUFBSSxDQUFDQTtnQkFDTCxJQUFJQSxNQUFNd0MsUUFBUTtvQkFDZCxJQUFJL0IsSUFBSXFELGtCQUFrQjlELElBQUksSUFBSSxDQUFDd0QsY0FBYyxDQUFDeEQ7b0JBQ2xELElBQUlTLEtBQUssQ0FBQ3VELEtBQUssQ0FBQ3ZELEVBQUUsRUFBRTt3QkFDaEJzRCxTQUFTeEQsSUFBSSxDQUFDRTt3QkFDZHVELEtBQUssQ0FBQ3ZELEVBQUUsR0FBRyxNQUFhLDRGQUE0RjtvQkFDeEg7Z0JBQ0o7WUFDSjtZQUNBLE9BQU9zRDtRQUNYO1FBQ0pJLGNBQWN0RSxHQUFHO1lBQ2ZJLEtBQUs0QixFQUFFO2dCQUNQO2dCQUNBL0I7Z0JBQ0E7b0JBQUM7b0JBQUk7aUJBQUc7Z0JBQ1I7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0FBO2dCQUNBO29CQUFDO29CQUFJO2lCQUFHO2FBQ1Q7WUFDQ0ssTUFBTTBCLEVBQUU7Z0JBQ1I7Z0JBQ0EvQjtnQkFDQTtvQkFBQztvQkFBRztpQkFBRTtnQkFDTjtnQkFDQTtnQkFDQUE7Z0JBQ0E7b0JBQUM7b0JBQUc7aUJBQUU7Z0JBQ047Z0JBQ0E7Z0JBQ0E7Z0JBQ0FBO2dCQUNBO29CQUFDO29CQUFHO2lCQUFHO2dCQUNQO2FBQ0Q7UUFDRDtRQUNBc0UsZUFBZSxTQUFTQyxzQkFBc0JDLFFBQVEsYUFBYSxHQUFkLEVBQWtCQyxJQUFJLEVBQUVDLFFBQVE7WUFFM0UsaUJBQWlCLEdBRWpCLCtHQUErRztZQUMvRyxJQUFJdEMsS0FBSyxJQUFJLENBQUNBLEVBQUU7WUFDaEIsSUFBSXVDLFdBQVd2QyxHQUFHM0QsTUFBTTtZQUN4QixJQUFJbUcsVUFBVXhDLEdBQUd5QyxLQUFLO1lBSXRCLE9BQVFMO2dCQUNsQixLQUFLO29CQUNELDhDQUE4QyxHQUU5QyxpRkFBaUY7b0JBQ2pGLElBQUksQ0FBQ00sQ0FBQyxHQUFHSixRQUFRLENBQUNELE9BQU8sRUFBRTtvQkFFM0I7Z0JBRUosS0FBSztvQkFDRCxxREFBcUQsR0FFckQsaUZBQWlGO29CQUNqRixJQUFJLENBQUNLLENBQUMsR0FBR0osUUFBUSxDQUFDRCxPQUFPLEVBQUU7b0JBQzNCLHVGQUF1RjtvQkFHdkYsT0FBT0MsUUFBUSxDQUFDRCxPQUFPLEVBQUU7b0JBQ3pCO2dCQUVKLEtBQUs7Z0JBQ0QsMEVBQTBFLEdBQzlFLEtBQUs7Z0JBQ0QsMEVBQTBFLEdBQzlFLEtBQUs7Z0JBQ0QsMEVBQTBFLEdBQzlFLEtBQUs7b0JBQ0QsMEVBQTBFLEdBRTFFLElBQUksQ0FBQ0ssQ0FBQyxHQUFHO3dCQUFFekQsTUFBTTt3QkFBa0IwRCxVQUFVTCxRQUFRLENBQUNELE9BQU8sRUFBRTt3QkFBRU8sTUFBTU4sUUFBUSxDQUFDRCxPQUFPLEVBQUU7d0JBQUVRLE9BQU9QLFFBQVEsQ0FBQ0QsS0FBSztvQkFBQztvQkFDakg7Z0JBRUosS0FBSztvQkFDRCxvRUFBb0UsR0FFcEUsSUFBSSxDQUFDSyxDQUFDLEdBQUdKLFFBQVEsQ0FBQ0QsT0FBTyxFQUFFO29CQUMzQjtnQkFFSixLQUFLO29CQUNELGdGQUFnRixHQUVoRixJQUFJLENBQUNLLENBQUMsR0FBRzt3QkFBRXpELE1BQU07d0JBQVFwQyxPQUFPeUYsUUFBUSxDQUFDRCxPQUFPLEVBQUU7b0JBQUM7b0JBQ25EO2dCQUVKLEtBQUs7b0JBQ0QsK0ZBQStGLEdBRS9GLElBQUksQ0FBQ0ssQ0FBQyxHQUFHO3dCQUFFekQsTUFBTTt3QkFBUXBDLE9BQU95RixRQUFRLENBQUNELE9BQU8sRUFBRTt3QkFBRVMsUUFBUVIsUUFBUSxDQUFDRCxPQUFPLEVBQUU7b0JBQUM7b0JBQy9FO2dCQUVKLEtBQUs7Z0JBQ0QsbURBQW1ELEdBQ3ZELEtBQUs7Z0JBQ0QsZ0RBQWdELEdBQ3BELEtBQUs7b0JBQ0QsNENBQTRDLEdBRTVDLElBQUksQ0FBQ0ssQ0FBQyxHQUFHSixRQUFRLENBQUNELEtBQUs7b0JBQ3ZCO2dCQUVKLEtBQUs7b0JBQ0QsbUNBQW1DLEdBRW5DLElBQUksQ0FBQ0ssQ0FBQyxHQUFHO3dCQUFFekQsTUFBTTt3QkFBU3BDLE9BQU9rRyxXQUFXVCxRQUFRLENBQUNELEtBQUs7b0JBQUU7b0JBQzVEO2dCQUVKLEtBQUs7b0JBQ0QsdUNBQXVDLEdBRXZDLElBQUksQ0FBQ0ssQ0FBQyxHQUFHO3dCQUFFekQsTUFBTTt3QkFBU3BDLE9BQU9rRyxXQUFXVCxRQUFRLENBQUNELEtBQUssSUFBSSxDQUFDO29CQUFFO29CQUNqRTtnQkFFSixLQUFLO29CQUNELG1FQUFtRSxHQUVuRSxJQUFJLENBQUNLLENBQUMsR0FBRzt3QkFBRXpELE1BQU07d0JBQWVwQyxPQUFPeUYsUUFBUSxDQUFDRCxPQUFPLEVBQUU7b0JBQUM7b0JBQzFEO2dCQUVKLEtBQUs7b0JBQ0QseUZBQXlGLEdBRXpGLElBQUksQ0FBQ0ssQ0FBQyxHQUFHO3dCQUFFekQsTUFBTTt3QkFBZXBDLE9BQU95RixRQUFRLENBQUNELE9BQU8sRUFBRTt3QkFBRVcsVUFBVVYsUUFBUSxDQUFDRCxPQUFPLEVBQUU7b0JBQUM7b0JBQ3hGO2dCQUVKLEtBQUs7b0JBQ0QsdUNBQXVDLEdBRXZDLElBQUksQ0FBQ0ssQ0FBQyxHQUFHO3dCQUFFekQsTUFBTTt3QkFBZXBDLE9BQU9rRyxXQUFXVCxRQUFRLENBQUNELEtBQUs7d0JBQUdZLE1BQU0sU0FBU0MsSUFBSSxDQUFDWixRQUFRLENBQUNELEtBQUssQ0FBQyxDQUFDLEVBQUU7b0JBQUM7b0JBQzFHO2dCQUVKLEtBQUs7b0JBQ0Qsc0NBQXNDLEdBRXRDLElBQUksQ0FBQ0ssQ0FBQyxHQUFHO3dCQUFFekQsTUFBTTt3QkFBY3BDLE9BQU9rRyxXQUFXVCxRQUFRLENBQUNELEtBQUs7d0JBQUdZLE1BQU0sU0FBU0MsSUFBSSxDQUFDWixRQUFRLENBQUNELEtBQUssQ0FBQyxDQUFDLEVBQUU7b0JBQUM7b0JBQ3pHO2dCQUVKLEtBQUs7b0JBQ0QscUNBQXFDLEdBRXJDLElBQUksQ0FBQ0ssQ0FBQyxHQUFHO3dCQUFFekQsTUFBTTt3QkFBYXBDLE9BQU9rRyxXQUFXVCxRQUFRLENBQUNELEtBQUs7d0JBQUdZLE1BQU0sU0FBU0MsSUFBSSxDQUFDWixRQUFRLENBQUNELEtBQUssQ0FBQyxDQUFDLEVBQUU7b0JBQUM7b0JBQ3hHO2dCQUVKLEtBQUs7b0JBQ0QscUNBQXFDLEdBRXJDLElBQUksQ0FBQ0ssQ0FBQyxHQUFHO3dCQUFFekQsTUFBTTt3QkFBa0JwQyxPQUFPa0csV0FBV1QsUUFBUSxDQUFDRCxLQUFLO3dCQUFHWSxNQUFNLFNBQVNDLElBQUksQ0FBQ1osUUFBUSxDQUFDRCxLQUFLLENBQUMsQ0FBQyxFQUFFO29CQUFDO29CQUM3RztnQkFFSixLQUFLO29CQUNELG9DQUFvQyxHQUVwQyxJQUFJLENBQUNLLENBQUMsR0FBRzt3QkFBRXpELE1BQU07d0JBQW1CcEMsT0FBT2tHLFdBQVdULFFBQVEsQ0FBQ0QsS0FBSzt3QkFBR1ksTUFBTSxTQUFTQyxJQUFJLENBQUNaLFFBQVEsQ0FBQ0QsS0FBSyxDQUFDLENBQUMsRUFBRTtvQkFBQztvQkFDOUc7Z0JBRUosS0FBSztvQkFDRCxvQ0FBb0MsR0FFcEMsSUFBSSxDQUFDSyxDQUFDLEdBQUc7d0JBQUV6RCxNQUFNO3dCQUFXcEMsT0FBT2tHLFdBQVdULFFBQVEsQ0FBQ0QsS0FBSzt3QkFBR1ksTUFBTTtvQkFBSztvQkFDMUU7Z0JBRUosS0FBSztvQkFDRCxvQ0FBb0MsR0FFcEMsSUFBSSxDQUFDUCxDQUFDLEdBQUc7d0JBQUV6RCxNQUFNO3dCQUFXcEMsT0FBT2tHLFdBQVdULFFBQVEsQ0FBQ0QsS0FBSzt3QkFBR1ksTUFBTTtvQkFBSztvQkFDMUU7Z0JBRUosS0FBSztvQkFDRCxvQ0FBb0MsR0FFcEMsSUFBSSxDQUFDUCxDQUFDLEdBQUc7d0JBQUV6RCxNQUFNO3dCQUFXcEMsT0FBT2tHLFdBQVdULFFBQVEsQ0FBQ0QsS0FBSzt3QkFBR1ksTUFBTTtvQkFBSztvQkFDMUU7Z0JBRUosS0FBSztvQkFDRCxxQ0FBcUMsR0FFckMsSUFBSSxDQUFDUCxDQUFDLEdBQUc7d0JBQUV6RCxNQUFNO3dCQUFZcEMsT0FBT2tHLFdBQVdULFFBQVEsQ0FBQ0QsS0FBSzt3QkFBR1ksTUFBTTtvQkFBTTtvQkFDNUU7Z0JBRUosS0FBSztvQkFDRCxvQ0FBb0MsR0FFcEMsSUFBSSxDQUFDUCxDQUFDLEdBQUc7d0JBQUV6RCxNQUFNO3dCQUFXcEMsT0FBT2tHLFdBQVdULFFBQVEsQ0FBQ0QsS0FBSzt3QkFBR1ksTUFBTTtvQkFBSztvQkFDMUU7Z0JBRUosS0FBSztvQkFDRCxvQ0FBb0MsR0FFcEMsSUFBSSxDQUFDUCxDQUFDLEdBQUc7d0JBQUV6RCxNQUFNO3dCQUFXcEMsT0FBT2tHLFdBQVdULFFBQVEsQ0FBQ0QsS0FBSzt3QkFBR1ksTUFBTTtvQkFBSztvQkFDMUU7Z0JBRUosS0FBSztvQkFDRCxzQ0FBc0MsR0FFdEMsSUFBSSxDQUFDUCxDQUFDLEdBQUc7d0JBQUV6RCxNQUFNO3dCQUFhcEMsT0FBT2tHLFdBQVdULFFBQVEsQ0FBQ0QsS0FBSzt3QkFBR1ksTUFBTTtvQkFBTztvQkFDOUU7Z0JBRUosS0FBSztvQkFDRCxzQ0FBc0MsR0FFdEMsSUFBSSxDQUFDUCxDQUFDLEdBQUc7d0JBQUV6RCxNQUFNO3dCQUFhcEMsT0FBT2tHLFdBQVdULFFBQVEsQ0FBQ0QsS0FBSzt3QkFBR1ksTUFBTTtvQkFBTztvQkFDOUU7Z0JBRUosS0FBSztvQkFDRCwyQ0FBMkMsR0FFM0MsSUFBSSxDQUFDUCxDQUFDLEdBQUc7d0JBQUV6RCxNQUFNO3dCQUFtQnBDLE9BQU9rRyxXQUFXVCxRQUFRLENBQUNELEtBQUs7d0JBQUdZLE1BQU07b0JBQUk7b0JBQ2pGO2dCQUVKLEtBQUs7b0JBQ0QsOENBQThDLEdBRTlDLElBQUlFLE9BQU9iLFFBQVEsQ0FBQ0QsS0FBSztvQkFBRWMsS0FBS3RHLEtBQUssSUFBSSxDQUFDO29CQUFHLElBQUksQ0FBQzZGLENBQUMsR0FBR1M7b0JBQ3REO1lBRUo7UUFDQTtRQUNBbkIsT0FBT3BELEdBQUc7WUFDUkMsS0FBS2MsRUFBRTtnQkFDUDtnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQS9CO2dCQUNBO29CQUFDO29CQUFHO2lCQUFFO2dCQUNOO2dCQUNBQTtnQkFDQTtvQkFBQztvQkFBRztpQkFBRztnQkFDUEE7Z0JBQ0E7b0JBQUM7b0JBQUk7aUJBQUU7Z0JBQ1A4QjtnQkFDQTtvQkFBQztvQkFBSTtpQkFBRTtnQkFDUDtnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQTlCO2dCQUNBO29CQUFDO29CQUFHO2lCQUFFO2dCQUNOO2dCQUNBO2dCQUNBO2dCQUNBOEI7Z0JBQ0E7b0JBQUM7b0JBQUk7aUJBQUU7Z0JBQ1BBO2dCQUNBO29CQUFDO29CQUFJO2lCQUFFO2dCQUNQO2dCQUNBO2dCQUNBO2FBQ0Q7WUFDQ1gsUUFBUVksRUFBRTtnQkFDVjtnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQS9CO2dCQUNBO29CQUFDO29CQUFJO29CQUFJO2lCQUFFO2dCQUNYO2dCQUNBO2dCQUNBQTtnQkFDQTtvQkFBQztvQkFBRztvQkFBRztpQkFBRTtnQkFDVDhCO2dCQUNBO29CQUFDO29CQUFJO2lCQUFHO2dCQUNSQTtnQkFDQTtvQkFBQztvQkFBSTtpQkFBRTtnQkFDUDtnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQUE7Z0JBQ0E7b0JBQUM7b0JBQUk7aUJBQUc7Z0JBQ1JBO2dCQUNBO29CQUFDO29CQUFJO2lCQUFFO2dCQUNQQTtnQkFDQTtvQkFBQztvQkFBSTtpQkFBRztnQkFDUkE7Z0JBQ0E7b0JBQUM7b0JBQUk7aUJBQUc7Z0JBQ1JBO2dCQUNBO29CQUFDO29CQUFLO2lCQUFFO2dCQUNSO2dCQUNBQTtnQkFDQTtvQkFBQztvQkFBSTtpQkFBRztnQkFDUjtnQkFDQUE7Z0JBQ0E7b0JBQUM7b0JBQUs7aUJBQUc7Z0JBQ1Q7Z0JBQ0FBO2dCQUNBO29CQUFDO29CQUFLO2lCQUFFO2dCQUNSO2dCQUNBQTtnQkFDQTtvQkFBQztvQkFBRztpQkFBRTtnQkFDTkE7Z0JBQ0E7b0JBQUM7b0JBQUc7aUJBQUU7Z0JBQ047Z0JBQ0E7Z0JBQ0E7Z0JBQ0FBO2dCQUNBO29CQUFDO29CQUFLO2lCQUFHO2dCQUNUQTtnQkFDQTtvQkFBQztvQkFBSTtpQkFBRzthQUNUO1lBQ0NULE1BQU1VLEVBQUU7Z0JBQ1IvQjtnQkFDQTtvQkFBQztvQkFBRztpQkFBRztnQkFDUEE7Z0JBQ0E7b0JBQUM7b0JBQUc7aUJBQUU7Z0JBQ047Z0JBQ0FBO2dCQUNBO29CQUFDO29CQUFHO2lCQUFHO2dCQUNQQTtnQkFDQTtvQkFBQztvQkFBRztpQkFBRTtnQkFDTjhCO2dCQUNBO29CQUFDO29CQUFJO2lCQUFHO2dCQUNSQTtnQkFDQTtvQkFBQztvQkFBSTtpQkFBRztnQkFDUkE7Z0JBQ0E7b0JBQUM7b0JBQUk7aUJBQUc7Z0JBQ1JBO2dCQUNBO29CQUFDO29CQUFJO2lCQUFHO2dCQUNSQTtnQkFDQTtvQkFBQztvQkFBSTtpQkFBRztnQkFDUkE7Z0JBQ0E7b0JBQUM7b0JBQUs7aUJBQUc7YUFDVjtZQUNDUCxPQUFPUSxFQUFFO2dCQUNUO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBRDtnQkFDQTtvQkFBQztvQkFBRztpQkFBRTtnQkFDTjtnQkFDQTtnQkFDQUE7Z0JBQ0E7b0JBQUM7b0JBQUc7aUJBQUU7Z0JBQ047Z0JBQ0FBO2dCQUNBO29CQUFDO29CQUFHO2lCQUFFO2dCQUNOO2dCQUNBQTtnQkFDQTtvQkFBQztvQkFBRztpQkFBRTtnQkFDTjtnQkFDQUE7Z0JBQ0E7b0JBQUM7b0JBQUc7aUJBQUU7Z0JBQ047Z0JBQ0FBO2dCQUNBO29CQUFDO29CQUFJO2lCQUFFO2dCQUNQO2dCQUNBQTtnQkFDQTtvQkFBQztvQkFBRztpQkFBRTtnQkFDTjtnQkFDQUE7Z0JBQ0E7b0JBQUM7b0JBQUc7aUJBQUU7YUFDUDtZQUNDTCxNQUFNTSxFQUFFO2dCQUNSL0I7Z0JBQ0E7b0JBQUM7b0JBQUc7aUJBQUk7Z0JBQ1JBO2dCQUNBO29CQUFDO29CQUFHO2lCQUFFO2dCQUNOOEI7Z0JBQ0E7b0JBQUM7b0JBQUc7aUJBQUU7Z0JBQ05BO2dCQUNBO29CQUFDO29CQUFHO2lCQUFFO2dCQUNOOUI7Z0JBQ0E7b0JBQUM7b0JBQUc7aUJBQUc7YUFDUjtZQUNDYyxNQUFNaUIsRUFBRTtnQkFDUjtnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQS9CO2dCQUNBO29CQUFDO29CQUFHO29CQUFJO2lCQUFFO2dCQUNWQTtnQkFDQTtvQkFBQztvQkFBSTtvQkFBRztpQkFBRTtnQkFDVjhCO2dCQUNBO29CQUFDO29CQUFJO2lCQUFHO2dCQUNSO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBQTtnQkFDQTtvQkFBQztvQkFBSTtpQkFBRztnQkFDUjtnQkFDQUE7Z0JBQ0E7b0JBQUM7b0JBQUk7aUJBQUc7Z0JBQ1JBO2dCQUNBO29CQUFDO29CQUFJO2lCQUFHO2dCQUNSQTtnQkFDQTtvQkFBQztvQkFBSztpQkFBRTtnQkFDUjtnQkFDQUE7Z0JBQ0E7b0JBQUM7b0JBQUk7aUJBQUc7Z0JBQ1I7Z0JBQ0E7Z0JBQ0FBO2dCQUNBO29CQUFDO29CQUFJO2lCQUFHO2dCQUNSO2dCQUNBOUI7Z0JBQ0E7b0JBQUM7b0JBQUc7aUJBQUU7Z0JBQ047Z0JBQ0E7Z0JBQ0E7Z0JBQ0FBO2dCQUNBO29CQUFDO29CQUFHO2lCQUFFO2dCQUNOO2dCQUNBO2dCQUNBO2dCQUNBOEI7Z0JBQ0E7b0JBQUM7b0JBQUk7aUJBQUU7Z0JBQ1A5QjtnQkFDQTtvQkFBQztvQkFBSTtvQkFBRztpQkFBRTtnQkFDVjhCO2dCQUNBO29CQUFDO29CQUFLO2lCQUFHO2dCQUNUO2dCQUNBQTtnQkFDQTtvQkFBQztvQkFBRztpQkFBRTtnQkFDTjthQUNEO1FBQ0Q7UUFDQTBELGdCQUFnQjlFLElBQUk7WUFDbEJFLEtBQUttQixFQUFFO2dCQUNQO2dCQUNBO2dCQUNBO2dCQUNBL0I7Z0JBQ0E7b0JBQUM7b0JBQUk7b0JBQUk7aUJBQUU7Z0JBQ1g7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7YUFDRDtZQUNDYyxNQUFNaUIsRUFBRTtnQkFDUjtnQkFDQTtnQkFDQTtnQkFDQS9CO2dCQUNBO29CQUFDO29CQUFJO29CQUFJO2lCQUFFO2dCQUNYO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBQTtnQkFDQTtvQkFBQztvQkFBRztvQkFBRztpQkFBRTtnQkFDVDtnQkFDQTtnQkFDQTthQUNEO1FBQ0Q7UUFDQXlGLFlBQVksU0FBU0EsV0FBV0MsR0FBRyxFQUFFOUcsSUFBSSxFQUFFK0csY0FBYztZQUNyRCxJQUFJL0csS0FBS2dILFdBQVcsRUFBRTtnQkFDbEIsSUFBSSxPQUFPLElBQUksQ0FBQzFELEtBQUssS0FBSyxZQUFZO29CQUNsQyxJQUFJLENBQUNBLEtBQUssQ0FBQ3dEO2dCQUNmO2dCQUNBOUcsS0FBS2lILE9BQU8sSUFBZ0IsNkJBQTZCO1lBQzdELE9BQU87Z0JBQ0gsSUFBSSxPQUFPLElBQUksQ0FBQzNELEtBQUssS0FBSyxZQUFZO29CQUNsQyxJQUFJLENBQUNBLEtBQUssQ0FBQ3dEO2dCQUNmO2dCQUNBLElBQUksQ0FBQ0MsZ0JBQWdCO29CQUNqQkEsaUJBQWlCLElBQUksQ0FBQ2pILGdCQUFnQjtnQkFDMUM7Z0JBQ0EsTUFBTSxJQUFJaUgsZUFBZUQsS0FBSzlHO1lBQ2xDO1FBQ0o7UUFDQWtILE9BQU8sU0FBU0EsTUFBTUMsS0FBSztZQUN2QixJQUFJQyxPQUFPLElBQUk7WUFDZixJQUFJekcsUUFBUSxJQUFJMEcsTUFBTSxNQUFjLG9GQUFvRjtZQUN4SCxJQUFJQyxTQUFTLElBQUlELE1BQU0sTUFBYSw4Q0FBOEM7WUFFbEYsSUFBSUUsU0FBUyxJQUFJRixNQUFNLE1BQWEsdUJBQXVCO1lBRTNELElBQUk3QixRQUFRLElBQUksQ0FBQ0EsS0FBSztZQUN0QixJQUFJZ0MsS0FBSyxHQUEyQix5Q0FBeUM7WUFNN0UsSUFBSWpGLFNBQVM7WUFJYixJQUFJdUIsU0FBUyxJQUFJLENBQUNBLE1BQU07WUFDeEIsSUFBSUMsTUFBTSxJQUFJLENBQUNBLEdBQUc7WUFDbEIsSUFBSTBELHFDQUFxQyxJQUFLLENBQUNoRSxPQUFPLENBQUNFLDhCQUE4QixHQUFHLEtBQU07WUFDOUYsSUFBSStELFlBQVk7Z0JBQUM7Z0JBQUcsR0FBRyx3RkFBd0Y7YUFBRztZQUVsSCxJQUFJekI7WUFDSixJQUFJLElBQUksQ0FBQzBCLFNBQVMsRUFBRTtnQkFDaEIxQixRQUFRLElBQUksQ0FBQzBCLFNBQVM7WUFDMUIsT0FBTztnQkFDSDFCLFFBQVEsSUFBSSxDQUFDMEIsU0FBUyxHQUFHMUgsT0FBT2dCLE1BQU0sQ0FBQyxJQUFJLENBQUNnRixLQUFLO1lBQ3JEO1lBRUEsSUFBSTJCLGlCQUFpQjtnQkFDakJmLFlBQVlnQjtnQkFDWnJELFdBQVdxRDtnQkFDWDVCLE9BQU80QjtnQkFDUGhJLFFBQVFnSTtnQkFDUkMsV0FBV0Q7Z0JBQ1hFLFlBQVlGO2dCQUNaRyxTQUFTSDtnQkFDVEksVUFBVUosVUFBZSx3R0FBd0c7WUFDckk7WUFFQSxJQUFJSztZQUNKLElBQUksT0FBT0MsV0FBVyxZQUFZO2dCQUM5QkQsU0FBUyxTQUFTRSxZQUFZQyxJQUFJLEVBQUV0SSxHQUFHO29CQUNuQyxJQUFJLENBQUNzSSxNQUFNO3dCQUNQLE1BQU0sSUFBSTdILE1BQU0sdUJBQXdCVCxDQUFBQSxPQUFPLEtBQUk7b0JBQ3ZEO2dCQUNKO1lBQ0osT0FBTztnQkFDSG1JLFNBQVNDO1lBQ2I7WUFFQSxJQUFJLENBQUNHLGdCQUFnQixHQUFHLFNBQVNBO2dCQUM3QixPQUFPVjtZQUNYO1lBU0EsU0FBU1csdUJBQXVCQyxHQUFHLEVBQUVDLEdBQUc7Z0JBQ3BDLElBQUssSUFBSUMsS0FBS0QsSUFBSztvQkFDZixJQUFJLE9BQU9ELEdBQUcsQ0FBQ0UsRUFBRSxLQUFLLGVBQWV6SSxPQUFPZSxTQUFTLENBQUNKLGNBQWMsQ0FBQytILElBQUksQ0FBQ0YsS0FBS0MsSUFBSTt3QkFDL0VGLEdBQUcsQ0FBQ0UsRUFBRSxHQUFHRCxHQUFHLENBQUNDLEVBQUU7b0JBQ25CO2dCQUNKO1lBQ0o7WUFFQSxhQUFhO1lBQ2JILHVCQUF1QlgsZ0JBQWdCLElBQUksQ0FBQ3BFLEVBQUU7WUFFOUNvRSxlQUFlM0IsS0FBSyxHQUFHQTtZQUN2QjJCLGVBQWUvSCxNQUFNLEdBQUcsSUFBSTtZQU81QixpR0FBaUc7WUFDakcsSUFBSSxPQUFPK0gsZUFBZWYsVUFBVSxLQUFLLFlBQVk7Z0JBQ2pELElBQUksQ0FBQ0EsVUFBVSxHQUFHLFNBQVMrQixjQUFjOUIsR0FBRyxFQUFFOUcsSUFBSSxFQUFFK0csY0FBYztvQkFDOUQsSUFBSSxDQUFDQSxnQkFBZ0I7d0JBQ2pCQSxpQkFBaUIsSUFBSSxDQUFDakgsZ0JBQWdCO29CQUMxQztvQkFDQSxPQUFPOEgsZUFBZWYsVUFBVSxDQUFDOEIsSUFBSSxDQUFDLElBQUksRUFBRTdCLEtBQUs5RyxNQUFNK0c7Z0JBQzNEO1lBQ0osT0FBTztnQkFDSCxJQUFJLENBQUNGLFVBQVUsR0FBRyxJQUFJLENBQUM1QyxrQkFBa0I7WUFDN0M7WUFFQSxnR0FBZ0c7WUFDaEcsSUFBSSxPQUFPMkQsZUFBZXBELFNBQVMsS0FBSyxZQUFZO2dCQUNoRCxJQUFJLENBQUNBLFNBQVMsR0FBRyxTQUFTcUUsYUFBYW5FLE1BQU07b0JBQ3pDLE9BQU9rRCxlQUFlcEQsU0FBUyxDQUFDbUUsSUFBSSxDQUFDLElBQUksRUFBRWpFO2dCQUMvQztZQUNKLE9BQU87Z0JBQ0gsSUFBSSxDQUFDRixTQUFTLEdBQUcsSUFBSSxDQUFDUixpQkFBaUI7WUFDM0M7WUFFQSxtR0FBbUc7WUFDbkcscUdBQXFHO1lBQ3JHLHFGQUFxRjtZQUNyRixFQUFFO1lBQ0YsaUdBQWlHO1lBQ2pHLHFFQUFxRTtZQUNyRSxJQUFJLENBQUNFLGlCQUFpQixHQUFHLFNBQVM0RSx5QkFBeUJDLFdBQVcsRUFBRUMsbUJBQW1CLEVBQUVDLHNCQUFzQjtnQkFDL0csSUFBSTVIO2dCQUVKLElBQUkySCxxQkFBcUI7b0JBQ3JCLElBQUloSjtvQkFFSixJQUFJNEgsZUFBZUcsVUFBVSxJQUFJLElBQUksQ0FBQ0EsVUFBVSxFQUFFO3dCQUM5QyxzRkFBc0Y7d0JBQ3RGLCtFQUErRTt3QkFDL0UvSCxPQUFPLElBQUksQ0FBQ21FLHVCQUF1QixDQUFDLE1BQXNCLE1BQTBCLE1BQU07b0JBQzlGO29CQUVBLElBQUl5RCxlQUFlRyxVQUFVLEVBQUU7d0JBQzNCMUcsS0FBS3VHLGVBQWVHLFVBQVUsQ0FBQ1ksSUFBSSxDQUFDLElBQUksRUFBRWYsZ0JBQWdCbUIsYUFBYS9JO3dCQUN2RSxJQUFJLE9BQU9xQixPQUFPLGFBQWEwSCxjQUFjMUg7b0JBQ2pEO29CQUNBLElBQUksSUFBSSxDQUFDMEcsVUFBVSxFQUFFO3dCQUNqQjFHLEtBQUssSUFBSSxDQUFDMEcsVUFBVSxDQUFDWSxJQUFJLENBQUMsSUFBSSxFQUFFZixnQkFBZ0JtQixhQUFhL0k7d0JBQzdELElBQUksT0FBT3FCLE9BQU8sYUFBYTBILGNBQWMxSDtvQkFDakQ7b0JBRUEsV0FBVztvQkFDWCxJQUFJckIsUUFBUUEsS0FBS2lILE9BQU8sRUFBRTt3QkFDdEJqSCxLQUFLaUgsT0FBTztvQkFDaEI7Z0JBQ0o7Z0JBRUEsSUFBSSxJQUFJLENBQUM1QyxzQkFBc0IsR0FBRyxHQUFHLE9BQU8wRSxhQUFvQixrRUFBa0U7Z0JBRWxJLG1EQUFtRDtnQkFDbkQsSUFBSTlDLE1BQU1pRCxlQUFlLEVBQUU7b0JBQ3ZCakQsTUFBTWlELGVBQWUsQ0FBQ0Q7Z0JBQzFCO2dCQUVBLG1FQUFtRTtnQkFDbkUsSUFBSXJCLGdCQUFnQjtvQkFDaEJBLGVBQWUzQixLQUFLLEdBQUc0QjtvQkFDdkJELGVBQWUvSCxNQUFNLEdBQUdnSTtvQkFDeEIsSUFBSTVCLE1BQU16QyxFQUFFLEtBQUtvRSxnQkFBZ0I7d0JBQzdCM0IsTUFBTXpDLEVBQUUsR0FBR3FFO29CQUNmO2dCQUNKO2dCQUNBRCxpQkFBaUJDO2dCQUNqQixJQUFJLENBQUNoQixVQUFVLEdBQUcsSUFBSSxDQUFDNUMsa0JBQWtCO2dCQUN6QyxJQUFJLENBQUNPLFNBQVMsR0FBRyxJQUFJLENBQUNSLGlCQUFpQjtnQkFFdkMsMkZBQTJGO2dCQUMzRixrRUFBa0U7Z0JBQ2xFckQsTUFBTWlCLE1BQU0sR0FBRyxHQUFpQiwrREFBK0Q7Z0JBQy9GMEYsT0FBTzFGLE1BQU0sR0FBRztnQkFFaEIyRixPQUFPM0YsTUFBTSxHQUFHO2dCQUNoQjRGLEtBQUs7Z0JBRUwsOERBQThEO2dCQUM5RCw4Q0FBOEM7Z0JBQzlDLHNFQUFzRTtnQkFDdEUsSUFBSSxDQUFDeUIsd0JBQXdCO29CQUN6QixJQUFLLElBQUl2SCxJQUFJLElBQUksQ0FBQzRDLGFBQWEsQ0FBQzFDLE1BQU0sR0FBRyxHQUFHRixLQUFLLEdBQUdBLElBQUs7d0JBQ3JELElBQUl5SCxLQUFLLElBQUksQ0FBQzdFLGFBQWEsQ0FBQzVDLEVBQUU7d0JBQzlCLElBQUl5SCxNQUFNLE9BQU9BLEdBQUdsQyxPQUFPLEtBQUssWUFBWTs0QkFDeENrQyxHQUFHbEMsT0FBTzt3QkFDZDtvQkFDSjtvQkFDQSxJQUFJLENBQUMzQyxhQUFhLENBQUMxQyxNQUFNLEdBQUc7Z0JBR2hDO2dCQUVBLE9BQU9tSDtZQUNYO1lBdUlBLGlHQUFpRztZQUNqRyw4RUFBOEU7WUFDOUUsSUFBSSxDQUFDNUUsdUJBQXVCLEdBQUcsU0FBU2lGLCtCQUErQnJKLEdBQUcsRUFBRXNKLEVBQUUsRUFBRUMsUUFBUSxFQUFFdEMsV0FBVztnQkFDakcsSUFBSXVDLE1BQU07b0JBQ05DLFFBQVF6SjtvQkFDUlEsV0FBVzhJO29CQUNYSSxNQUFNeEQsTUFBTXlELEtBQUs7b0JBQ2pCckosT0FBTzRGLE1BQU0wRCxNQUFNO29CQUNuQkMsT0FBTyxJQUFJLENBQUM5RSxjQUFjLENBQUN2QyxXQUFXQTtvQkFDdENzSCxVQUFVdEg7b0JBQ1Z1SCxNQUFNN0QsTUFBTThELFFBQVE7b0JBRXBCVCxVQUFVQTtvQkFDVnRDLGFBQWFBO29CQUNickUsT0FBT0E7b0JBQ1BxSCxRQUFRQTtvQkFDUkMsV0FBV0M7b0JBQ1hDLGNBQWN4SjtvQkFDZHlKLGFBQWE5QztvQkFDYitDLGFBQWE5QztvQkFFYitDLGVBQWU5QztvQkFDZmhFLElBQUlvRTtvQkFDSjNCLE9BQU9BO29CQUNQcEcsUUFBUSxJQUFJO29CQUVaLDZEQUE2RDtvQkFDN0QsNkNBQTZDO29CQUM3QywwREFBMEQ7b0JBQzFELEVBQUU7b0JBQ0YsZ0VBQWdFO29CQUNoRSxpRUFBaUU7b0JBQ2pFLCtEQUErRDtvQkFDL0RvSCxTQUFTLFNBQVNzRDt3QkFDZCxnREFBZ0Q7d0JBQ2hELGtCQUFrQjt3QkFDbEIscUJBQXFCO3dCQUNyQixxQkFBcUI7d0JBQ3JCLDJCQUEyQjt3QkFDM0IsTUFBTTt3QkFDTixJQUFJQyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUN4RCxXQUFXO3dCQUM1QixJQUFLLElBQUluQyxPQUFPLElBQUksQ0FBRTs0QkFDbEIsSUFBSSxJQUFJLENBQUNqRSxjQUFjLENBQUNpRSxRQUFRLE9BQU9BLFFBQVEsVUFBVTtnQ0FDckQsSUFBSSxDQUFDQSxJQUFJLEdBQUdnRDs0QkFDaEI7d0JBQ0o7d0JBQ0EsSUFBSSxDQUFDYixXQUFXLEdBQUd3RDtvQkFDdkI7Z0JBQ0o7Z0JBQ0EsNkdBQTZHO2dCQUM3RyxJQUFJLENBQUNsRyxhQUFhLENBQUN6QyxJQUFJLENBQUMwSDtnQkFDeEIsT0FBT0E7WUFDWDtZQWNBLFNBQVNrQix1QkFBdUJsSSxNQUFNO2dCQUNsQyxJQUFJbUksWUFBWXRELEtBQUt6QyxhQUFhLENBQUNwQztnQkFDbkMsSUFBSSxDQUFDbUksV0FBVztvQkFDWkEsWUFBWW5JO2dCQUNoQjtnQkFDQSxPQUFPbUk7WUFDWDtZQUdBLFNBQVNDO2dCQUNMLElBQUlmLFFBQVEzRCxNQUFNMkUsR0FBRztnQkFDckIsNENBQTRDO2dCQUM1QyxJQUFJLE9BQU9oQixVQUFVLFVBQVU7b0JBQzNCQSxRQUFReEMsS0FBS3hELFFBQVEsQ0FBQ2dHLE1BQU0sSUFBSUE7Z0JBQ3BDO2dCQUVBLE9BQU9BLFNBQVM3RjtZQUNwQjtZQUVBLFNBQVM4RztnQkFDTCxJQUFJakIsUUFBUTNELE1BQU00RSxPQUFPO2dCQUN6Qiw0Q0FBNEM7Z0JBQzVDLElBQUksT0FBT2pCLFVBQVUsVUFBVTtvQkFDM0JBLFFBQVF4QyxLQUFLeEQsUUFBUSxDQUFDZ0csTUFBTSxJQUFJQTtnQkFDcEM7Z0JBRUEsT0FBT0EsU0FBUzdGO1lBQ3BCO1lBRUEsSUFBSTZHLE1BQU1EO1lBR1YsSUFBSWhJLE9BQU9xSCxRQUFReEksR0FBR2dCO1lBQ3RCLElBQUlzSSxRQUFRO2dCQUNSNUUsR0FBRztnQkFDSDZFLElBQUlsRDtnQkFDSnJFLElBQUlvRTtZQUNSO1lBQ0EsSUFBSXRHO1lBQ0osSUFBSTBKO1lBQ0osSUFBSUM7WUFDSixJQUFJZjtZQUNKLElBQUlnQixTQUFTO1lBR2IsSUFBSTtnQkFDQSxJQUFJLENBQUM3RyxzQkFBc0I7Z0JBRTNCNEIsTUFBTWtGLFFBQVEsQ0FBQ2hFLE9BQU9TO2dCQUV0QixtRUFBbUU7Z0JBQ25FLG9FQUFvRTtnQkFDcEUsK0RBQStEO2dCQUMvRCxvQkFBb0I7Z0JBQ3BCLElBQUksT0FBTzNCLE1BQU1tRixPQUFPLEtBQUssWUFBWTtvQkFDckMsSUFBSUMsWUFBWXBGLE1BQU1tRixPQUFPO29CQUM3QixJQUFJQyxVQUFVUixPQUFPLElBQUksT0FBT0EsWUFBWSxZQUFZO3dCQUNwREQsTUFBTUM7b0JBQ1Y7Z0JBQ0o7Z0JBSUF0RCxNQUFNLENBQUNDLEdBQUcsR0FBRztnQkFDYkYsTUFBTSxDQUFDRSxHQUFHLEdBQUc7Z0JBQ2I3RyxLQUFLLENBQUM2RyxHQUFHLEdBQUc7Z0JBQ1osRUFBRUE7Z0JBTUYsSUFBSSxJQUFJLENBQUNNLFNBQVMsRUFBRTtvQkFDaEIsSUFBSSxDQUFDQSxTQUFTLENBQUNhLElBQUksQ0FBQyxJQUFJLEVBQUVmO2dCQUM5QjtnQkFDQSxJQUFJQSxlQUFlRSxTQUFTLEVBQUU7b0JBQzFCRixlQUFlRSxTQUFTLENBQUNhLElBQUksQ0FBQyxJQUFJLEVBQUVmO2dCQUN4QztnQkFFQXNDLFdBQVc1QyxNQUFNLENBQUNFLEtBQUssRUFBRTtnQkFDekIsT0FBUztvQkFDTCwwQ0FBMEM7b0JBQzFDN0UsUUFBUXVILFVBQXdCLGtCQUFrQjtvQkFFbEQsbUNBQW1DO29CQUNuQyxJQUFJLElBQUksQ0FBQ3RELGNBQWMsQ0FBQ2pFLE1BQU0sRUFBRTt3QkFDNUJxSCxTQUFTO3dCQUNURSxXQUFXLElBQUksQ0FBQ3RELGNBQWMsQ0FBQ2pFLE1BQU07b0JBQ3pDLE9BQU87d0JBQ0gsa0ZBQWtGO3dCQUNsRixhQUFhO3dCQUNiLEVBQUU7d0JBQ0YsZ0VBQWdFO3dCQUNoRSxJQUFJLENBQUNKLFFBQVE7NEJBQ1RBLFNBQVNxSTt3QkFDYjt3QkFDQSxnREFBZ0Q7d0JBQ2hEcEksSUFBSSxLQUFNLENBQUNHLE1BQU0sSUFBSTZDLEtBQUssQ0FBQzdDLE1BQU0sQ0FBQ0osT0FBTyxJQUFLbUY7d0JBQzlDd0MsV0FBVzFILENBQUMsQ0FBQyxFQUFFO3dCQUNmd0gsU0FBU3hILENBQUMsQ0FBQyxFQUFFO3dCQVliLHFCQUFxQjt3QkFDckIsSUFBSSxDQUFDd0gsUUFBUTs0QkFDVCxJQUFJUjs0QkFDSixJQUFJOEIsaUJBQWtCLElBQUksQ0FBQ3hHLGNBQWMsQ0FBQ3ZDLFdBQVdBOzRCQUNyRCxJQUFJK0csV0FBVyxJQUFJLENBQUNwRSwwQkFBMEIsQ0FBQ3ZDOzRCQUUvQyxlQUFlOzRCQUNmLElBQUksT0FBT3NELE1BQU04RCxRQUFRLEtBQUssVUFBVTtnQ0FDcENQLFNBQVMseUJBQTBCdkQsQ0FBQUEsTUFBTThELFFBQVEsR0FBRyxLQUFLOzRCQUM3RCxPQUFPO2dDQUNIUCxTQUFTOzRCQUNiOzRCQUNBLElBQUksT0FBT3ZELE1BQU1zRixZQUFZLEtBQUssWUFBWTtnQ0FDMUMvQixVQUFVLE9BQU92RCxNQUFNc0YsWUFBWSxDQUFDLEtBQUssSUFBSSxNQUFNOzRCQUN2RDs0QkFDQSxJQUFJakMsU0FBUzFILE1BQU0sRUFBRTtnQ0FDakI0SCxVQUFVLGVBQWVGLFNBQVNrQyxJQUFJLENBQUMsUUFBUSxzQkFBc0JGOzRCQUN6RSxPQUFPO2dDQUNIOUIsVUFBVSxnQkFBZ0I4Qjs0QkFDOUI7NEJBQ0Esb0NBQW9DOzRCQUNwQ2hLLElBQUksSUFBSSxDQUFDNkMsdUJBQXVCLENBQUNxRixRQUFRLE1BQU1GLFVBQVU7NEJBQ3pEOUgsSUFBSSxJQUFJLENBQUNxRixVQUFVLENBQUN2RixFQUFFa0ksTUFBTSxFQUFFbEksR0FBRyxJQUFJLENBQUN4QixnQkFBZ0I7NEJBQ3RELElBQUksT0FBTzBCLE1BQU0sYUFBYTtnQ0FDMUIwSixTQUFTMUo7NEJBQ2I7NEJBQ0E7d0JBQ0o7b0JBR0o7b0JBV0EsT0FBUXdJO3dCQUNSLDhCQUE4Qjt3QkFDOUI7NEJBQ0kseURBQXlEOzRCQUN6RCxJQUFJQSxrQkFBa0IzQyxPQUFPO2dDQUN6Qi9GLElBQUksSUFBSSxDQUFDNkMsdUJBQXVCLENBQUMsc0RBQXNEeEIsUUFBUSxjQUFjSixRQUFRLE1BQU0sTUFBTTtnQ0FDaklmLElBQUksSUFBSSxDQUFDcUYsVUFBVSxDQUFDdkYsRUFBRWtJLE1BQU0sRUFBRWxJLEdBQUcsSUFBSSxDQUFDeEIsZ0JBQWdCO2dDQUN0RCxJQUFJLE9BQU8wQixNQUFNLGFBQWE7b0NBQzFCMEosU0FBUzFKO2dDQUNiO2dDQUNBOzRCQUNKOzRCQUNBLCtHQUErRzs0QkFDL0csaUNBQWlDOzRCQUNqQ0YsSUFBSSxJQUFJLENBQUM2Qyx1QkFBdUIsQ0FBQywrRkFBK0YsTUFBTSxNQUFNOzRCQUM1STNDLElBQUksSUFBSSxDQUFDcUYsVUFBVSxDQUFDdkYsRUFBRWtJLE1BQU0sRUFBRWxJLEdBQUcsSUFBSSxDQUFDeEIsZ0JBQWdCOzRCQUN0RCxJQUFJLE9BQU8wQixNQUFNLGFBQWE7Z0NBQzFCMEosU0FBUzFKOzRCQUNiOzRCQUNBO3dCQUVKLFNBQVM7d0JBQ1QsS0FBSzs0QkFDRGIsS0FBSyxDQUFDNkcsR0FBRyxHQUFHakY7NEJBQ1pnRixNQUFNLENBQUNDLEdBQUcsR0FBR3ZCLE1BQU0wRCxNQUFNOzRCQUV6QnJDLE1BQU0sQ0FBQ0UsR0FBRyxHQUFHMEMsVUFBVSxhQUFhOzRCQUVwQyxFQUFFMUM7NEJBQ0ZqRixTQUFTOzRCQVVUO3dCQUVKLFVBQVU7d0JBQ1YsS0FBSzs0QkFJRDBJLGtCQUFrQixJQUFJLENBQUN4RixZQUFZLENBQUN5RSxXQUFXLEVBQUUsRUFBRyxtRkFBbUY7NEJBQ3ZJYyxZQUFZQyxlQUFlLENBQUMsRUFBRTs0QkFXOUJ6SixJQUFJLElBQUksQ0FBQ2tFLGFBQWEsQ0FBQ2lELElBQUksQ0FBQ21DLE9BQU9aLFVBQVUxQyxLQUFLLEdBQUdEOzRCQUVyRCxJQUFJLE9BQU8vRixNQUFNLGFBQWE7Z0NBQzFCMEosU0FBUzFKO2dDQUNUOzRCQUNKOzRCQUVBLGdCQUFnQjs0QkFDaEJnRyxNQUFNd0Q7NEJBRU4sNkVBQTZFOzRCQUM3RSxJQUFJUyxXQUFXUixlQUFlLENBQUMsRUFBRSxFQUFLLDRCQUE0Qjs0QkFDbEV0SyxLQUFLLENBQUM2RyxHQUFHLEdBQUdpRTs0QkFDWmxFLE1BQU0sQ0FBQ0MsR0FBRyxHQUFHc0QsTUFBTTVFLENBQUM7NEJBRXBCLDZDQUE2Qzs0QkFDN0NnRSxXQUFXMUUsS0FBSyxDQUFDOEIsTUFBTSxDQUFDRSxLQUFLLEVBQUUsQ0FBQyxDQUFDaUUsU0FBUzs0QkFDMUNuRSxNQUFNLENBQUNFLEdBQUcsR0FBRzBDOzRCQUNiLEVBQUUxQzs0QkFVRjt3QkFFSixVQUFVO3dCQUNWLEtBQUs7NEJBQ0QsSUFBSUEsT0FBTyxDQUFDLEdBQUc7Z0NBQ1gwRCxTQUFTO2dDQUNULHlEQUF5RDtnQ0FDekQsRUFBRTtnQ0FDRixnRkFBZ0Y7Z0NBQ2hGLG9CQUFvQjtnQ0FDcEIsRUFBRTtnQ0FDRixrQ0FBa0M7Z0NBQ2xDLDJDQUEyQztnQ0FDM0MsRUFBRTtnQ0FDRixpRkFBaUY7Z0NBQ2pGLG9GQUFvRjtnQ0FDcEYsMkVBQTJFO2dDQUMzRSxFQUFFO2dDQUNGLFdBQVc7Z0NBQ1gsRUFBRTtnQ0FDRixzQkFBc0I7Z0NBQ3RCLHVGQUF1RjtnQ0FDdkYsc0RBQXNEO2dDQUN0RCxzQ0FBc0M7Z0NBQ3RDLDRCQUE0QjtnQ0FDNUIseUhBQXlIO2dDQUN6SCxzQkFBc0I7Z0NBQ3RCMUQ7Z0NBQ0EsSUFBSSxPQUFPRCxNQUFNLENBQUNDLEdBQUcsS0FBSyxhQUFhO29DQUNuQzBELFNBQVMzRCxNQUFNLENBQUNDLEdBQUc7Z0NBQ3ZCOzRCQUNKOzRCQUNBO29CQUNKO29CQUdBO2dCQUNKO1lBQ0osRUFBRSxPQUFPNkIsSUFBSTtnQkFDVCx1RkFBdUY7Z0JBQ3ZGLHdGQUF3RjtnQkFDeEYsSUFBSUEsY0FBYyxJQUFJLENBQUN2SixnQkFBZ0IsRUFBRTtvQkFDckMsTUFBTXVKO2dCQUNWLE9BQ0ssSUFBSXBELFNBQVMsT0FBT0EsTUFBTXlGLGVBQWUsS0FBSyxjQUFjckMsY0FBY3BELE1BQU15RixlQUFlLEVBQUU7b0JBQ2xHLE1BQU1yQztnQkFDVjtnQkFFQS9ILElBQUksSUFBSSxDQUFDNkMsdUJBQXVCLENBQUMscUNBQXFDa0YsSUFBSSxNQUFNO2dCQUNoRjZCLFNBQVM7Z0JBQ1QxSixJQUFJLElBQUksQ0FBQ3FGLFVBQVUsQ0FBQ3ZGLEVBQUVrSSxNQUFNLEVBQUVsSSxHQUFHLElBQUksQ0FBQ3hCLGdCQUFnQjtnQkFDdEQsSUFBSSxPQUFPMEIsTUFBTSxhQUFhO29CQUMxQjBKLFNBQVMxSjtnQkFDYjtZQUNKLFNBQVU7Z0JBQ04wSixTQUFTLElBQUksQ0FBQ2hILGlCQUFpQixDQUFDZ0gsUUFBUSxNQUFNO2dCQUM5QyxJQUFJLENBQUM3RyxzQkFBc0I7WUFDL0IsRUFBSSxXQUFXO1lBRWYsT0FBTzZHO1FBQ1g7SUFDQTtJQUNBckwsT0FBT29FLGtCQUFrQixHQUFHcEUsT0FBT2dILFVBQVU7SUFDN0NoSCxPQUFPbUUsaUJBQWlCLEdBQUduRSxPQUFPMkUsU0FBUztJQUMzQywwQ0FBMEMsR0FFMUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FzTkMsR0FHRCxJQUFJeUIsUUFBUTtRQUNWOzs7Ozs7Ozs7R0FTQyxHQUNELFNBQVN5RixnQkFBZ0IzTCxHQUFHLEVBQUVDLElBQUk7WUFDaENDLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsUUFBUTtnQkFDbENDLFlBQVk7Z0JBQ1pDLFVBQVU7Z0JBQ1ZDLE9BQU87WUFDVDtZQUVBLElBQUlOLE9BQU8sTUFDVEEsTUFBTTtZQUVSRSxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFdBQVc7Z0JBQ3JDQyxZQUFZO2dCQUNaQyxVQUFVO2dCQUNWQyxPQUFPTjtZQUNUO1lBRUEsSUFBSSxDQUFDQyxJQUFJLEdBQUdBO1lBQ1osSUFBSU07WUFFSixJQUFJTixRQUFRQSxLQUFLTyxTQUFTLFlBQVlDLE9BQU87Z0JBQzNDLElBQUlDLE1BQU1ULEtBQUtPLFNBQVM7Z0JBQ3hCLElBQUksQ0FBQ0csT0FBTyxHQUFHRCxJQUFJQyxPQUFPLElBQUlYO2dCQUM5Qk8sYUFBYUcsSUFBSUUsS0FBSztZQUN4QjtZQUVBLElBQUksQ0FBQ0wsWUFBWTtnQkFDZixJQUFJRSxNQUFNSSxjQUFjLENBQUMsc0JBQXNCO29CQUM3QyxLQUFLO29CQUNMSixNQUFNSyxpQkFBaUIsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDQyxXQUFXO2dCQUNoRCxPQUFPO29CQUNMUixhQUFhLElBQUlFLE1BQU1ULEtBQUtZLEtBQUs7Z0JBQ25DO1lBQ0Y7WUFFQSxJQUFJTCxZQUFZO2dCQUNkTCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFNBQVM7b0JBQ25DQyxZQUFZO29CQUNaQyxVQUFVO29CQUNWQyxPQUFPQztnQkFDVDtZQUNGO1FBQ0Y7UUFFQSxJQUFJLE9BQU9MLE9BQU9jLGNBQWMsS0FBSyxZQUFZO1lBQy9DZCxPQUFPYyxjQUFjLENBQUMySyxnQkFBZ0IxSyxTQUFTLEVBQUVSLE1BQU1RLFNBQVM7UUFDbEUsT0FBTztZQUNMMEssZ0JBQWdCMUssU0FBUyxHQUFHZixPQUFPZ0IsTUFBTSxDQUFDVCxNQUFNUSxTQUFTO1FBQzNEO1FBRUEwSyxnQkFBZ0IxSyxTQUFTLENBQUNGLFdBQVcsR0FBRzRLO1FBQ3hDQSxnQkFBZ0IxSyxTQUFTLENBQUNFLElBQUksR0FBRztRQUVqQyxJQUFJK0UsUUFBUTtZQUVkLG9DQUFvQztZQUNwQyxvQ0FBb0M7WUFDcEMsRUFBRTtZQUNGLFdBQVc7WUFDWCxFQUFFO1lBQ0YsNkNBQTZDO1lBQzdDLDZDQUE2QztZQUM3Qyw0Q0FBNEM7WUFDNUMsRUFBRTtZQUNGLEVBQUU7WUFDRixtQ0FBbUM7WUFDbkMsRUFBRTtZQUNGLDZDQUE2QztZQUM3Qyw2Q0FBNkM7WUFDN0MsNkNBQTZDO1lBQzdDLDZDQUE2QztZQUM3QyxtREFBbUQ7WUFDbkQsNkNBQTZDO1lBQzdDLDZDQUE2QztZQUM3QyxFQUFFO1lBQ0YsRUFBRTtZQUNGLHdCQUF3QjtZQUN4QixFQUFFO1lBQ0YsMkNBQTJDO1lBQzNDLDJDQUEyQztZQUMzQywyQ0FBMkM7WUFDM0MsMkNBQTJDO1lBQzNDLDJDQUEyQztZQUMzQywyQ0FBMkM7WUFDM0MsMkNBQTJDO1lBQzNDLDJDQUEyQztZQUMzQywyQ0FBMkM7WUFDM0MsMkNBQTJDO1lBQzNDLDJDQUEyQztZQUMzQyxvRUFBb0U7WUFDcEUsMkNBQTJDO1lBQzNDLDJDQUEyQztZQUMzQyxFQUFFO1lBQ0Ysc0NBQXNDO1lBRXRDbEMsS0FBSztZQUNENEgsT0FBTztZQUVQLGtGQUFrRjtZQUVsRixrRkFBa0Y7WUFFbEYsMEVBQTBFO1lBRTFFQyxvQkFBb0I7WUFFcEJ0SCxlQUFlLEVBQUU7WUFDakJ1SCxnQkFBZ0I7WUFDaEJDLE1BQU07WUFDTkMsWUFBWTtZQUNaQyxRQUFRO1lBQ1JDLE9BQU87WUFDUEMsdUJBQXVCO1lBQ3ZCQyxnQkFBZ0IsRUFBRTtZQUNsQnpDLE9BQU87WUFDUDBDLFNBQVM7WUFDVEMsU0FBUztZQUNUMUMsUUFBUTtZQUNSMkMsUUFBUTtZQUNSQyxRQUFRO1lBQ1J4QyxVQUFVO1lBQ1Z5QyxRQUFRO1lBRVI7Ozs7O0tBS0MsR0FDREMsdUJBQXVCLFNBQVNDLDRCQUE0QjNNLEdBQUcsRUFBRWlILFdBQVcsRUFBRTJGLG1CQUFtQjtnQkFDL0Y1TSxNQUFNLEtBQUtBO2dCQUVYLDRGQUE0RjtnQkFDNUYsa0VBQWtFO2dCQUNsRSxJQUFJNE0sdUJBQXVCOUUsV0FBVztvQkFDcEM4RSxzQkFBc0IsQ0FBRTVNLENBQUFBLElBQUk2TSxPQUFPLENBQUMsUUFBUSxLQUFLN00sSUFBSTZNLE9BQU8sQ0FBQyxPQUFPO2dCQUN0RTtnQkFFQSxJQUFJLElBQUksQ0FBQ0osTUFBTSxJQUFJRyxxQkFBcUI7b0JBQ3RDLElBQUksT0FBTyxJQUFJLENBQUNFLGdCQUFnQixLQUFLLFlBQVk7d0JBQy9DLElBQUlDLGFBQWEsSUFBSSxDQUFDRCxnQkFBZ0IsQ0FBQyxJQUFJLENBQUNMLE1BQU07d0JBRWxELElBQUksQ0FBQyxTQUFTTyxJQUFJLENBQUNoTixNQUFNOzRCQUN2QkEsT0FBTzt3QkFDVDt3QkFFQUEsT0FBTywwQkFBMEIsSUFBSSxDQUFDOE0sZ0JBQWdCLENBQUMsSUFBSSxDQUFDTCxNQUFNO29CQUNwRSxPQUFPLElBQUksT0FBTyxJQUFJLENBQUNqQixZQUFZLEtBQUssWUFBWTt3QkFDbEQsSUFBSXlCLFVBQVUsSUFBSSxDQUFDekIsWUFBWTt3QkFFL0IsSUFBSXlCLFNBQVM7NEJBQ1gsSUFBSWpOLElBQUk2QixNQUFNLElBQUk3QixHQUFHLENBQUNBLElBQUk2QixNQUFNLEdBQUcsRUFBRSxLQUFLLFFBQVFvTCxPQUFPLENBQUMsRUFBRSxLQUFLLE1BQU07Z0NBQ3JFak4sT0FBTyxPQUFPaU47NEJBQ2hCLE9BQU87Z0NBQ0xqTixPQUFPaU47NEJBQ1Q7d0JBQ0Y7b0JBQ0Y7Z0JBQ0Y7Z0JBRUEsaUJBQWlCLEdBQ2pCLElBQUl6RCxNQUFNO29CQUNSQyxRQUFReko7b0JBQ1JpSCxhQUFhLENBQUMsQ0FBQ0E7b0JBQ2Z5QyxNQUFNLElBQUksQ0FBQ0MsS0FBSztvQkFDaEJFLE9BQU87b0JBQ1BFLE1BQU0sSUFBSSxDQUFDQyxRQUFRO29CQUNuQmtELEtBQUssSUFBSSxDQUFDVCxNQUFNO29CQUNoQmhKLElBQUksSUFBSSxDQUFDQSxFQUFFO29CQUNYeUMsT0FBTyxJQUFJO29CQUVYOzs7Ozs7Ozs7OztTQVdDLEdBQ0RnQixTQUFTLFNBQVNpRzt3QkFDaEIsZ0RBQWdEO3dCQUNoRCxrQkFBa0I7d0JBQ2xCLHFCQUFxQjt3QkFDckIsTUFBTTt3QkFDTixJQUFJMUMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDeEQsV0FBVzt3QkFFNUIsSUFBSyxJQUFJbkMsT0FBTyxJQUFJLENBQUU7NEJBQ3BCLElBQUksSUFBSSxDQUFDakUsY0FBYyxDQUFDaUUsUUFBUSxPQUFPQSxRQUFRLFVBQVU7Z0NBQ3ZELElBQUksQ0FBQ0EsSUFBSSxHQUFHZ0Q7NEJBQ2Q7d0JBQ0Y7d0JBRUEsSUFBSSxDQUFDYixXQUFXLEdBQUd3RDtvQkFDckI7Z0JBQ0Y7Z0JBRUEsNkdBQTZHO2dCQUM3RyxJQUFJLENBQUNsRyxhQUFhLENBQUN6QyxJQUFJLENBQUMwSDtnQkFFeEIsT0FBT0E7WUFDVDtZQUVBOzs7OztLQUtDLEdBQ0QxQyxZQUFZLFNBQVNzRyxpQkFBaUJyRyxHQUFHLEVBQUU5RyxJQUFJLEVBQUUrRyxjQUFjO2dCQUM3RCxJQUFJLENBQUNBLGdCQUFnQjtvQkFDbkJBLGlCQUFpQixJQUFJLENBQUMyRSxlQUFlO2dCQUN2QztnQkFFQSxJQUFJLElBQUksQ0FBQ2xJLEVBQUUsRUFBRTtvQkFDWCxJQUFJLElBQUksQ0FBQ0EsRUFBRSxDQUFDM0QsTUFBTSxJQUFJLE9BQU8sSUFBSSxDQUFDMkQsRUFBRSxDQUFDM0QsTUFBTSxDQUFDZ0gsVUFBVSxLQUFLLFlBQVk7d0JBQ3JFLE9BQU8sSUFBSSxDQUFDckQsRUFBRSxDQUFDM0QsTUFBTSxDQUFDZ0gsVUFBVSxDQUFDOEIsSUFBSSxDQUFDLElBQUksRUFBRTdCLEtBQUs5RyxNQUFNK0csbUJBQW1CLElBQUksQ0FBQzRFLEtBQUs7b0JBQ3RGLE9BQU8sSUFBSSxPQUFPLElBQUksQ0FBQ25JLEVBQUUsQ0FBQ3FELFVBQVUsS0FBSyxZQUFZO3dCQUNuRCxPQUFPLElBQUksQ0FBQ3JELEVBQUUsQ0FBQ3FELFVBQVUsQ0FBQzhCLElBQUksQ0FBQyxJQUFJLEVBQUU3QixLQUFLOUcsTUFBTStHLG1CQUFtQixJQUFJLENBQUM0RSxLQUFLO29CQUMvRTtnQkFDRjtnQkFFQSxNQUFNLElBQUk1RSxlQUFlRCxLQUFLOUc7WUFDaEM7WUFFQTs7Ozs7S0FLQyxHQUNEb04sU0FBUyxTQUFTQyxRQUFRdkcsSUFBSSxZQUFZLEdBQWI7Z0JBQzNCLElBQUl3RyxhQUFhO2dCQUVqQixJQUFJLElBQUksQ0FBQ2QsTUFBTSxFQUFFO29CQUNmYyxhQUFhLGNBQWUsS0FBSSxDQUFDdkQsUUFBUSxHQUFHO2dCQUM5QztnQkFFQSxJQUFJekksSUFBSSxJQUFJLENBQUNtTCxxQkFBcUIsQ0FDaEMsa0JBQWtCYSxhQUFhLE9BQU94RyxLQUN0QyxJQUFJLENBQUNyRCxPQUFPLENBQUM4Six5QkFBeUI7Z0JBR3hDLDBFQUEwRTtnQkFDMUUsSUFBSUMsT0FBT25HLE1BQU1yRyxTQUFTLENBQUN5TSxLQUFLLENBQUM5RSxJQUFJLENBQUMrRSxXQUFXO2dCQUVqRCxJQUFJRixLQUFLNUwsTUFBTSxFQUFFO29CQUNmTixFQUFFcU0sc0JBQXNCLEdBQUdIO2dCQUM3QjtnQkFFQSxPQUFPLElBQUksQ0FBQzNHLFVBQVUsQ0FBQ3ZGLEVBQUVrSSxNQUFNLEVBQUVsSSxHQUFHLElBQUksQ0FBQ29LLGVBQWUsS0FBSyxJQUFJLENBQUNDLEtBQUs7WUFDekU7WUFFQTs7Ozs7Ozs7Ozs7S0FXQyxHQUNEekMsaUJBQWlCLFNBQVMwRSxzQkFBc0IzRSxzQkFBc0I7Z0JBQ3BFLG1FQUFtRTtnQkFDbkUsSUFBSSxDQUFDa0MsUUFBUSxDQUFDLElBQUksQ0FBQztnQkFFbkIsOERBQThEO2dCQUM5RCw4Q0FBOEM7Z0JBQzlDLHNFQUFzRTtnQkFDdEUsSUFBSSxDQUFDbEMsd0JBQXdCO29CQUMzQixJQUFLLElBQUl2SCxJQUFJLElBQUksQ0FBQzRDLGFBQWEsQ0FBQzFDLE1BQU0sR0FBRyxHQUFHRixLQUFLLEdBQUdBLElBQUs7d0JBQ3ZELElBQUl5SCxLQUFLLElBQUksQ0FBQzdFLGFBQWEsQ0FBQzVDLEVBQUU7d0JBRTlCLElBQUl5SCxNQUFNLE9BQU9BLEdBQUdsQyxPQUFPLEtBQUssWUFBWTs0QkFDMUNrQyxHQUFHbEMsT0FBTzt3QkFDWjtvQkFDRjtvQkFFQSxJQUFJLENBQUMzQyxhQUFhLENBQUMxQyxNQUFNLEdBQUc7Z0JBQzlCO2dCQUVBLE9BQU8sSUFBSTtZQUNiO1lBRUE7Ozs7O0tBS0MsR0FDRGlNLE9BQU8sU0FBU0M7Z0JBQ2QsSUFBSSxDQUFDbkUsTUFBTSxHQUFHO2dCQUNkLElBQUksQ0FBQzRDLE1BQU0sR0FBRztnQkFDZCxJQUFJLENBQUM3QyxLQUFLLEdBQUc7Z0JBRWIsZ0NBQWdDO2dCQUNoQyxJQUFJLENBQUMyQyxPQUFPLEdBQUc7Z0JBRWYsSUFBSSxDQUFDSixLQUFLLEdBQUc7Z0JBQ2IsSUFBSSxDQUFDRixVQUFVLEdBQUc7Z0JBQ2xCLElBQUlnQyxNQUFPLElBQUksQ0FBQ3ZCLE1BQU0sR0FBRyxJQUFJLENBQUNBLE1BQU0sQ0FBQ3dCLFdBQVcsR0FBRztnQkFFbkQsSUFBSSxDQUFDeEIsTUFBTSxHQUFHO29CQUNaeUIsWUFBWSxJQUFJLENBQUNsRSxRQUFRLEdBQUc7b0JBQzVCbUUsY0FBY0g7b0JBQ2RJLFdBQVcsSUFBSSxDQUFDcEUsUUFBUSxHQUFHO29CQUMzQmlFLGFBQWFEO29CQUNiSyxPQUFPO3dCQUFDLElBQUksQ0FBQzlCLE1BQU07d0JBQUUsSUFBSSxDQUFDQSxNQUFNO3FCQUFDO2dCQUNuQztZQUNGO1lBRUE7Ozs7O0tBS0MsR0FDRG5CLFVBQVUsU0FBU2tELGVBQWVsSCxLQUFLLEVBQUUzRCxFQUFFO2dCQUN6QyxJQUFJLENBQUNBLEVBQUUsR0FBR0EsTUFBTSxJQUFJLENBQUNBLEVBQUUsSUFBSSxDQUFDO2dCQUU1Qiw0REFBNEQ7Z0JBQzVELDBEQUEwRDtnQkFDMUQsMkJBQTJCO2dCQUMzQixJQUFJLENBQUMsSUFBSSxDQUFDcUksY0FBYyxFQUFFO29CQUN4QixxQ0FBcUM7b0JBQ3JDLElBQUl5QyxRQUFRLElBQUksQ0FBQ0EsS0FBSztvQkFFdEIsSUFBSyxJQUFJNU0sSUFBSSxHQUFHVyxNQUFNaU0sTUFBTTFNLE1BQU0sRUFBRUYsSUFBSVcsS0FBS1gsSUFBSzt3QkFDaEQsSUFBSTZNLFVBQVVELEtBQUssQ0FBQzVNLEVBQUU7d0JBRXRCLDBFQUEwRTt3QkFDMUUsSUFBSSxPQUFPNk0sWUFBWSxVQUFVOzRCQUMvQkQsS0FBSyxDQUFDNU0sRUFBRSxHQUFHNE0sS0FBSyxDQUFDQyxRQUFRO3dCQUMzQjtvQkFDRjtvQkFFQSxtRUFBbUU7b0JBQ25FLElBQUlDLGFBQWEsSUFBSSxDQUFDQSxVQUFVO29CQUVoQyxJQUFLLElBQUk5RixLQUFLOEYsV0FBWTt3QkFDeEIsSUFBSUMsT0FBT0QsVUFBVSxDQUFDOUYsRUFBRTt3QkFDeEIsSUFBSWdHLFdBQVdELEtBQUtILEtBQUs7d0JBQ3pCLElBQUlqTSxNQUFNcU0sU0FBUzlNLE1BQU07d0JBQ3pCLElBQUkrTSxlQUFlLElBQUl0SCxNQUFNaEYsTUFBTSxJQUFnQixzSEFBc0g7d0JBQ3pLLElBQUl1TSxlQUFlLElBQUl2SCxNQUFNaEYsTUFBTTt3QkFFbkMsSUFBSyxJQUFJWCxJQUFJLEdBQUdBLElBQUlXLEtBQUtYLElBQUs7NEJBQzVCLElBQUlNLE1BQU0wTSxRQUFRLENBQUNoTixFQUFFOzRCQUNyQixJQUFJNk0sVUFBVUQsS0FBSyxDQUFDdE0sSUFBSTs0QkFDeEIyTSxZQUFZLENBQUNqTixJQUFJLEVBQUUsR0FBRzZNOzRCQUN0QkssWUFBWSxDQUFDbE4sSUFBSSxFQUFFLEdBQUdNO3dCQUN4Qjt3QkFFQXlNLEtBQUtILEtBQUssR0FBR007d0JBQ2JILEtBQUtJLGNBQWMsR0FBR0Y7d0JBQ3RCRixLQUFLSyxZQUFZLEdBQUd6TTtvQkFDdEI7b0JBRUEsSUFBSSxDQUFDd0osY0FBYyxHQUFHO2dCQUN4QjtnQkFFQSxJQUFJLENBQUNHLE1BQU0sR0FBRzdFLFNBQVM7Z0JBQ3ZCLElBQUksQ0FBQzBHLEtBQUs7Z0JBQ1YsSUFBSSxDQUFDM0IscUJBQXFCLEdBQUc7Z0JBQzdCLElBQUksQ0FBQ0osSUFBSSxHQUFHO2dCQUNaLElBQUksQ0FBQy9CLFFBQVEsR0FBRztnQkFDaEIsSUFBSSxDQUFDcUMsT0FBTyxHQUFHO2dCQUNmLElBQUksQ0FBQ0QsY0FBYyxHQUFHO29CQUFDO2lCQUFVO2dCQUNqQyxJQUFJLENBQUNQLGtCQUFrQixHQUFHO2dCQUUxQixJQUFJLENBQUNZLE1BQU0sR0FBRztvQkFDWnlCLFlBQVk7b0JBQ1pDLGNBQWM7b0JBQ2RDLFdBQVc7b0JBQ1hILGFBQWE7b0JBQ2JJLE9BQU87d0JBQUM7d0JBQUc7cUJBQUU7Z0JBQ2Y7Z0JBRUEsSUFBSSxDQUFDOUIsTUFBTSxHQUFHO2dCQUNkLE9BQU8sSUFBSTtZQUNiO1lBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0EyQ0MsR0FDRHlDLG9CQUFvQixTQUFTQyx5QkFBeUJDLFFBQVEsRUFBRUMsTUFBTTtnQkFDcEUsSUFBSTdOLEtBQUs0TixTQUFTdEcsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUNxRCxNQUFNLEVBQUVrRDtnQkFFMUMsSUFBSSxPQUFPN04sT0FBTyxVQUFVO29CQUMxQixJQUFJQSxJQUFJO3dCQUNOLElBQUksQ0FBQzJLLE1BQU0sR0FBRyxLQUFLM0s7b0JBQ3JCO2dCQUNBLG9DQUFvQztnQkFDdEMsT0FBTztvQkFDTCxJQUFJLENBQUMySyxNQUFNLEdBQUczSztnQkFDaEI7Z0JBRUEsT0FBTyxJQUFJO1lBQ2I7WUFFQTs7Ozs7S0FLQyxHQUNEOEYsT0FBTyxTQUFTZ0k7Z0JBQ2QsSUFBSSxDQUFDLElBQUksQ0FBQ25ELE1BQU0sRUFBRTtvQkFDaEIsaVFBQWlRO29CQUNqUSxPQUFPO2dCQUNUO2dCQUVBLElBQUlvRCxLQUFLLElBQUksQ0FBQ3BELE1BQU0sQ0FBQyxFQUFFO2dCQUN2QixJQUFJLENBQUNyQyxNQUFNLElBQUl5RjtnQkFDZixJQUFJLENBQUM3QyxNQUFNO2dCQUNYLElBQUksQ0FBQ0QsTUFBTTtnQkFDWCxJQUFJLENBQUM1QyxLQUFLLElBQUkwRjtnQkFDZCxJQUFJLENBQUNoRCxPQUFPLElBQUlnRDtnQkFFaEIsb0VBQW9FO2dCQUNwRSxpRkFBaUY7Z0JBQ2pGLGdGQUFnRjtnQkFDaEYsd0NBQXdDO2dCQUN4QyxJQUFJQyxZQUFZO2dCQUVoQixJQUFJQyxRQUFRO2dCQUVaLElBQUlGLE9BQU8sTUFBTTtvQkFDZkUsUUFBUTtnQkFDVixPQUFPLElBQUlGLE9BQU8sTUFBTTtvQkFDdEJFLFFBQVE7b0JBQ1IsSUFBSUMsTUFBTSxJQUFJLENBQUN2RCxNQUFNLENBQUMsRUFBRTtvQkFFeEIsSUFBSXVELFFBQVEsTUFBTTt3QkFDaEJGO3dCQUNBRCxNQUFNRzt3QkFDTixJQUFJLENBQUM1RixNQUFNLElBQUk0Rjt3QkFDZixJQUFJLENBQUNoRCxNQUFNO3dCQUNYLElBQUksQ0FBQ0QsTUFBTTt3QkFDWCxJQUFJLENBQUM1QyxLQUFLLElBQUk2Rjt3QkFDZCxJQUFJLENBQUNuRCxPQUFPLElBQUltRDt3QkFDaEIsSUFBSSxDQUFDL0MsTUFBTSxDQUFDNEIsS0FBSyxDQUFDLEVBQUU7b0JBQ3RCO2dCQUNGO2dCQUVBLElBQUlrQixPQUFPO29CQUNULElBQUksQ0FBQ3ZGLFFBQVE7b0JBQ2IsSUFBSSxDQUFDeUMsTUFBTSxDQUFDMkIsU0FBUztvQkFDckIsSUFBSSxDQUFDM0IsTUFBTSxDQUFDd0IsV0FBVyxHQUFHO2dCQUM1QixPQUFPO29CQUNMLElBQUksQ0FBQ3hCLE1BQU0sQ0FBQ3dCLFdBQVc7Z0JBQ3pCO2dCQUVBLElBQUksQ0FBQ3hCLE1BQU0sQ0FBQzRCLEtBQUssQ0FBQyxFQUFFO2dCQUNwQixJQUFJLENBQUNwQyxNQUFNLEdBQUcsSUFBSSxDQUFDQSxNQUFNLENBQUN5QixLQUFLLENBQUM0QjtnQkFDaEMsT0FBT0Q7WUFDVDtZQUVBOzs7OztLQUtDLEdBQ0RJLE9BQU8sU0FBU0MsWUFBWUwsRUFBRTtnQkFDNUIsSUFBSS9NLE1BQU0rTSxHQUFHeE4sTUFBTTtnQkFDbkIsSUFBSTBOLFFBQVFGLEdBQUdNLEtBQUssQ0FBQztnQkFDckIsSUFBSSxDQUFDMUQsTUFBTSxHQUFHb0QsS0FBSyxJQUFJLENBQUNwRCxNQUFNO2dCQUM5QixJQUFJLENBQUNyQyxNQUFNLEdBQUcsSUFBSSxDQUFDQSxNQUFNLENBQUNnRyxNQUFNLENBQUMsR0FBRyxJQUFJLENBQUNoRyxNQUFNLENBQUMvSCxNQUFNLEdBQUdTO2dCQUN6RCxJQUFJLENBQUNrSyxNQUFNLEdBQUcsSUFBSSxDQUFDNUMsTUFBTSxDQUFDL0gsTUFBTTtnQkFDaEMsSUFBSSxDQUFDMEssTUFBTSxJQUFJaks7Z0JBQ2YsSUFBSSxDQUFDcUgsS0FBSyxHQUFHLElBQUksQ0FBQ0EsS0FBSyxDQUFDaUcsTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDakcsS0FBSyxDQUFDOUgsTUFBTSxHQUFHUztnQkFDdEQsSUFBSSxDQUFDK0osT0FBTyxHQUFHLElBQUksQ0FBQ0EsT0FBTyxDQUFDdUQsTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDdkQsT0FBTyxDQUFDeEssTUFBTSxHQUFHUztnQkFFNUQsSUFBSWlOLE1BQU0xTixNQUFNLEdBQUcsR0FBRztvQkFDcEIsSUFBSSxDQUFDbUksUUFBUSxJQUFJdUYsTUFBTTFOLE1BQU0sR0FBRztvQkFDaEMsSUFBSSxDQUFDNEssTUFBTSxDQUFDMkIsU0FBUyxHQUFHLElBQUksQ0FBQ3BFLFFBQVEsR0FBRztvQkFFeEMsZ0VBQWdFO29CQUNoRSx3REFBd0Q7b0JBQ3hELDBDQUEwQztvQkFDMUMsSUFBSTZGLE1BQU0sSUFBSSxDQUFDbEcsS0FBSztvQkFFcEIsSUFBSW1HLFlBQVlELElBQUlGLEtBQUssQ0FBQztvQkFFMUIsSUFBSUcsVUFBVWpPLE1BQU0sS0FBSyxHQUFHO3dCQUMxQmdPLE1BQU0sSUFBSSxDQUFDeEQsT0FBTzt3QkFDbEJ5RCxZQUFZRCxJQUFJRixLQUFLLENBQUM7b0JBQ3hCO29CQUVBLElBQUksQ0FBQ2xELE1BQU0sQ0FBQ3dCLFdBQVcsR0FBRzZCLFNBQVMsQ0FBQ0EsVUFBVWpPLE1BQU0sR0FBRyxFQUFFLENBQUNBLE1BQU07Z0JBQ2xFLE9BQU87b0JBQ0wsSUFBSSxDQUFDNEssTUFBTSxDQUFDd0IsV0FBVyxJQUFJM0w7Z0JBQzdCO2dCQUVBLElBQUksQ0FBQ21LLE1BQU0sQ0FBQzRCLEtBQUssQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDNUIsTUFBTSxDQUFDNEIsS0FBSyxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUM3QixNQUFNO2dCQUN6RCxJQUFJLENBQUNULElBQUksR0FBRztnQkFDWixPQUFPLElBQUk7WUFDYjtZQUVBOzs7OztLQUtDLEdBQ0RnRSxNQUFNLFNBQVNDO2dCQUNiLElBQUksQ0FBQzlELEtBQUssR0FBRztnQkFDYixPQUFPLElBQUk7WUFDYjtZQUVBOzs7Ozs7S0FNQyxHQUNEK0QsUUFBUSxTQUFTQztnQkFDZixJQUFJLElBQUksQ0FBQ3hNLE9BQU8sQ0FBQ3lNLGVBQWUsRUFBRTtvQkFDaEMsSUFBSSxDQUFDbkUsVUFBVSxHQUFHO2dCQUNwQixPQUFPO29CQUNMLHFGQUFxRjtvQkFDckYsa0ZBQWtGO29CQUNsRixnQkFBZ0I7b0JBQ2hCLElBQUl1QixhQUFhO29CQUVqQixJQUFJLElBQUksQ0FBQ2QsTUFBTSxFQUFFO3dCQUNmYyxhQUFhLGNBQWUsS0FBSSxDQUFDdkQsUUFBUSxHQUFHO29CQUM5QztvQkFFQSxJQUFJekksSUFBSSxJQUFJLENBQUNtTCxxQkFBcUIsQ0FDaEMsa0JBQWtCYSxhQUFhLGtJQUMvQjtvQkFHRixJQUFJLENBQUNwQixxQkFBcUIsR0FBRyxJQUFJLENBQUNyRixVQUFVLENBQUN2RixFQUFFa0ksTUFBTSxFQUFFbEksR0FBRyxJQUFJLENBQUNvSyxlQUFlLEtBQUssSUFBSSxDQUFDQyxLQUFLO2dCQUMvRjtnQkFFQSxPQUFPLElBQUk7WUFDYjtZQUVBOzs7OztLQUtDLEdBQ0R3RSxNQUFNLFNBQVNDLFdBQVd0TixDQUFDO2dCQUN6QixPQUFPLElBQUksQ0FBQzBNLEtBQUssQ0FBQyxJQUFJLENBQUM5RixLQUFLLENBQUMrRCxLQUFLLENBQUMzSztZQUNyQztZQUVBOzs7Ozs7Ozs7Ozs7O0tBYUMsR0FDRHVOLFdBQVcsU0FBU0MsZ0JBQWdCQyxPQUFPLEVBQUVDLFFBQVE7Z0JBQ25ELElBQUlDLE9BQU8sSUFBSSxDQUFDckUsT0FBTyxDQUFDc0UsU0FBUyxDQUFDLEdBQUcsSUFBSSxDQUFDdEUsT0FBTyxDQUFDeEssTUFBTSxHQUFHLElBQUksQ0FBQzhILEtBQUssQ0FBQzlILE1BQU07Z0JBRTVFLElBQUkyTyxVQUFVLEdBQ1pBLFVBQVVFLEtBQUs3TyxNQUFNO3FCQUNsQixJQUFJLENBQUMyTyxTQUNSQSxVQUFVO2dCQUVaLElBQUlDLFdBQVcsR0FDYkEsV0FBV0MsS0FBSzdPLE1BQU0sRUFBVywrQ0FBK0M7cUJBQzdFLElBQUksQ0FBQzRPLFVBQ1JBLFdBQVc7Z0JBRWIsNEVBQTRFO2dCQUM1RSwwRUFBMEU7Z0JBQzFFLDREQUE0RDtnQkFDNURDLE9BQU9BLEtBQUtkLE1BQU0sQ0FBQyxDQUFDWSxVQUFVLElBQUk7Z0JBRWxDLHFGQUFxRjtnQkFDckYsa0NBQWtDO2dCQUNsQyxJQUFJN04sSUFBSStOLEtBQUtFLE9BQU8sQ0FBQyxZQUFZLE1BQU1qQixLQUFLLENBQUM7Z0JBRTdDaE4sSUFBSUEsRUFBRStLLEtBQUssQ0FBQyxDQUFDK0M7Z0JBQ2JDLE9BQU8vTixFQUFFOEksSUFBSSxDQUFDO2dCQUVkLHNFQUFzRTtnQkFDdEUsK0JBQStCO2dCQUMvQixJQUFJaUYsS0FBSzdPLE1BQU0sR0FBRzJPLFNBQVM7b0JBQ3pCRSxPQUFPLFFBQVFBLEtBQUtkLE1BQU0sQ0FBQyxDQUFDWTtnQkFDOUI7Z0JBRUEsT0FBT0U7WUFDVDtZQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FxQkMsR0FDREcsZUFBZSxTQUFTQyxvQkFBb0JOLE9BQU8sRUFBRUMsUUFBUTtnQkFDM0QsSUFBSU0sT0FBTyxJQUFJLENBQUNwSCxLQUFLO2dCQUVyQixJQUFJNkcsVUFBVSxHQUNaQSxVQUFVTyxLQUFLbFAsTUFBTSxHQUFHLElBQUksQ0FBQ29LLE1BQU0sQ0FBQ3BLLE1BQU07cUJBQ3ZDLElBQUksQ0FBQzJPLFNBQ1JBLFVBQVU7Z0JBRVosSUFBSUMsV0FBVyxHQUNiQSxXQUFXRCxTQUFrQiwrQ0FBK0M7cUJBQ3pFLElBQUksQ0FBQ0MsVUFDUkEsV0FBVztnQkFFYiwrRUFBK0U7Z0JBQy9FLDBFQUEwRTtnQkFDMUUsNERBQTREO2dCQUM1RCxJQUFJTSxLQUFLbFAsTUFBTSxHQUFHMk8sVUFBVSxJQUFJLEdBQUc7b0JBQ2pDTyxRQUFRLElBQUksQ0FBQzlFLE1BQU0sQ0FBQzBFLFNBQVMsQ0FBQyxHQUFHSCxVQUFVLElBQUksSUFBTSxvQ0FBb0M7Z0JBQzNGO2dCQUVBLHFGQUFxRjtnQkFDckYsa0NBQWtDO2dCQUNsQyxJQUFJN04sSUFBSW9PLEtBQUtILE9BQU8sQ0FBQyxZQUFZLE1BQU1qQixLQUFLLENBQUM7Z0JBRTdDaE4sSUFBSUEsRUFBRStLLEtBQUssQ0FBQyxHQUFHK0M7Z0JBQ2ZNLE9BQU9wTyxFQUFFOEksSUFBSSxDQUFDO2dCQUVkLHNFQUFzRTtnQkFDdEUsZ0NBQWdDO2dCQUNoQyxJQUFJc0YsS0FBS2xQLE1BQU0sR0FBRzJPLFNBQVM7b0JBQ3pCTyxPQUFPQSxLQUFLSixTQUFTLENBQUMsR0FBR0gsV0FBVztnQkFDdEM7Z0JBRUEsT0FBT087WUFDVDtZQUVBOzs7Ozs7S0FNQyxHQUNEdkYsY0FBYyxTQUFTd0YsbUJBQW1CQyxTQUFTLEVBQUVDLFVBQVU7Z0JBQzdELElBQUlyQixNQUFNLElBQUksQ0FBQ1MsU0FBUyxDQUFDVyxXQUFXTCxPQUFPLENBQUMsT0FBTztnQkFDbkQsSUFBSXpOLElBQUksSUFBSW1FLE1BQU11SSxJQUFJaE8sTUFBTSxHQUFHLEdBQUc0SixJQUFJLENBQUM7Z0JBQ3ZDLE9BQU9vRSxNQUFNLElBQUksQ0FBQ2dCLGFBQWEsQ0FBQ0ssWUFBWU4sT0FBTyxDQUFDLE9BQU8sT0FBTyxPQUFPek4sSUFBSTtZQUMvRTtZQUVBOzs7Ozs7Ozs7Ozs7Ozs7O0tBZ0JDLEdBQ0RnTyxvQkFBb0IsU0FBU0MsbUJBQW1CQyxNQUFNLEVBQUVDLFNBQVMsRUFBRUMsU0FBUyxFQUFFQyxPQUFPO2dCQUNuRixJQUFJdEUsTUFBTTtvQkFDUmdCLFlBQVk7b0JBQ1pDLGNBQWM7b0JBQ2RDLFdBQVc7b0JBQ1hILGFBQWE7b0JBQ2JJLE9BQU87d0JBQUM7d0JBQUc7cUJBQUU7Z0JBQ2Y7Z0JBRUEsSUFBSWdELFFBQVE7b0JBQ1ZuRSxJQUFJZ0IsVUFBVSxHQUFHbUQsT0FBT25ELFVBQVUsR0FBRztvQkFDckNoQixJQUFJa0IsU0FBUyxHQUFHaUQsT0FBT2pELFNBQVMsR0FBRztvQkFDbkNsQixJQUFJaUIsWUFBWSxHQUFHa0QsT0FBT2xELFlBQVksR0FBRztvQkFDekNqQixJQUFJZSxXQUFXLEdBQUdvRCxPQUFPcEQsV0FBVyxHQUFHO29CQUV2QyxJQUFJb0QsT0FBT2hELEtBQUssRUFBRTt3QkFDaEJuQixJQUFJbUIsS0FBSyxDQUFDLEVBQUUsR0FBR2dELE9BQU9oRCxLQUFLLENBQUMsRUFBRSxHQUFHO3dCQUNqQ25CLElBQUltQixLQUFLLENBQUMsRUFBRSxHQUFHZ0QsT0FBT2hELEtBQUssQ0FBQyxFQUFFLEdBQUc7b0JBQ25DO2dCQUNGO2dCQUVBLElBQUluQixJQUFJZ0IsVUFBVSxJQUFJLEtBQUtoQixJQUFJa0IsU0FBUyxHQUFHbEIsSUFBSWdCLFVBQVUsRUFBRTtvQkFDekQsbURBQW1EO29CQUNuRCxJQUFJaEIsSUFBSWdCLFVBQVUsSUFBSSxLQUFLb0QsV0FBVzt3QkFDcENwRSxJQUFJZ0IsVUFBVSxHQUFHb0QsVUFBVWxELFNBQVMsR0FBRzt3QkFDdkNsQixJQUFJaUIsWUFBWSxHQUFHbUQsVUFBVXJELFdBQVcsR0FBRzt3QkFFM0MsSUFBSXFELFVBQVVqRCxLQUFLLEVBQUU7NEJBQ25CbkIsSUFBSW1CLEtBQUssQ0FBQyxFQUFFLEdBQUdnRCxPQUFPaEQsS0FBSyxDQUFDLEVBQUUsR0FBRzt3QkFDbkM7b0JBQ0Y7b0JBRUEsSUFBSSxDQUFDbkIsSUFBSWtCLFNBQVMsSUFBSSxLQUFLbEIsSUFBSWtCLFNBQVMsR0FBR2xCLElBQUlnQixVQUFVLEtBQUtxRCxXQUFXO3dCQUN2RXJFLElBQUlrQixTQUFTLEdBQUdtRCxVQUFVckQsVUFBVSxHQUFHO3dCQUN2Q2hCLElBQUllLFdBQVcsR0FBR3NELFVBQVVwRCxZQUFZLEdBQUc7d0JBRTNDLElBQUlvRCxVQUFVbEQsS0FBSyxFQUFFOzRCQUNuQm5CLElBQUltQixLQUFLLENBQUMsRUFBRSxHQUFHZ0QsT0FBT2hELEtBQUssQ0FBQyxFQUFFLEdBQUc7d0JBQ25DO29CQUNGO29CQUVBLDZEQUE2RDtvQkFDN0QsSUFBSW5CLElBQUlnQixVQUFVLElBQUksS0FBS3NELFdBQVl0RSxDQUFBQSxJQUFJa0IsU0FBUyxJQUFJLEtBQUtvRCxRQUFRcEQsU0FBUyxJQUFJbEIsSUFBSWtCLFNBQVMsR0FBRzt3QkFDaEdsQixJQUFJZ0IsVUFBVSxHQUFHc0QsUUFBUXRELFVBQVUsR0FBRzt3QkFDdENoQixJQUFJaUIsWUFBWSxHQUFHcUQsUUFBUXJELFlBQVksR0FBRzt3QkFFMUMsSUFBSXFELFFBQVFuRCxLQUFLLEVBQUU7NEJBQ2pCbkIsSUFBSW1CLEtBQUssQ0FBQyxFQUFFLEdBQUdtRCxRQUFRbkQsS0FBSyxDQUFDLEVBQUUsR0FBRzt3QkFDcEM7b0JBQ0Y7b0JBRUEsSUFBSW5CLElBQUlrQixTQUFTLElBQUksS0FBS29ELFdBQVl0RSxDQUFBQSxJQUFJZ0IsVUFBVSxJQUFJLEtBQUtzRCxRQUFRdEQsVUFBVSxJQUFJaEIsSUFBSWdCLFVBQVUsR0FBRzt3QkFDbEdoQixJQUFJa0IsU0FBUyxHQUFHb0QsUUFBUXBELFNBQVMsR0FBRzt3QkFDcENsQixJQUFJZSxXQUFXLEdBQUd1RCxRQUFRdkQsV0FBVyxHQUFHO3dCQUV4QyxJQUFJdUQsUUFBUW5ELEtBQUssRUFBRTs0QkFDakJuQixJQUFJbUIsS0FBSyxDQUFDLEVBQUUsR0FBR21ELFFBQVFuRCxLQUFLLENBQUMsRUFBRSxHQUFHO3dCQUNwQztvQkFDRjtnQkFDRjtnQkFFQSwyRkFBMkY7Z0JBQzNGLGdFQUFnRTtnQkFDaEUsSUFBSW5CLElBQUlrQixTQUFTLElBQUksR0FBRztvQkFDdEIsSUFBSWxCLElBQUlnQixVQUFVLElBQUksR0FBRzt3QkFDdkJoQixJQUFJZ0IsVUFBVSxHQUFHLElBQUksQ0FBQ3pCLE1BQU0sQ0FBQ3lCLFVBQVU7d0JBQ3ZDaEIsSUFBSWtCLFNBQVMsR0FBRyxJQUFJLENBQUMzQixNQUFNLENBQUMyQixTQUFTO3dCQUNyQ2xCLElBQUlpQixZQUFZLEdBQUcsSUFBSSxDQUFDMUIsTUFBTSxDQUFDMEIsWUFBWTt3QkFDM0NqQixJQUFJZSxXQUFXLEdBQUcsSUFBSSxDQUFDeEIsTUFBTSxDQUFDd0IsV0FBVzt3QkFDekNmLElBQUltQixLQUFLLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQzVCLE1BQU0sQ0FBQzRCLEtBQUssQ0FBQyxFQUFFO3dCQUNuQ25CLElBQUltQixLQUFLLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQzVCLE1BQU0sQ0FBQzRCLEtBQUssQ0FBQyxFQUFFO29CQUNyQyxPQUFPO3dCQUNMbkIsSUFBSWtCLFNBQVMsR0FBRyxJQUFJLENBQUMzQixNQUFNLENBQUMyQixTQUFTO3dCQUNyQ2xCLElBQUllLFdBQVcsR0FBRyxJQUFJLENBQUN4QixNQUFNLENBQUN3QixXQUFXO3dCQUN6Q2YsSUFBSW1CLEtBQUssQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDNUIsTUFBTSxDQUFDNEIsS0FBSyxDQUFDLEVBQUU7b0JBQ3JDO2dCQUNGO2dCQUVBLElBQUluQixJQUFJZ0IsVUFBVSxJQUFJLEdBQUc7b0JBQ3ZCaEIsSUFBSWdCLFVBQVUsR0FBR2hCLElBQUlrQixTQUFTO29CQUM5QmxCLElBQUlpQixZQUFZLEdBQUcsR0FBSSxvQkFBb0I7b0JBQzNDakIsSUFBSW1CLEtBQUssQ0FBQyxFQUFFLEdBQUduQixJQUFJbUIsS0FBSyxDQUFDLEVBQUU7Z0JBQzdCO2dCQUVBLElBQUluQixJQUFJaUIsWUFBWSxHQUFHLEdBQUc7b0JBQ3hCakIsSUFBSWlCLFlBQVksR0FBRztnQkFDckI7Z0JBRUEsSUFBSWpCLElBQUllLFdBQVcsR0FBRyxHQUFHO29CQUN2QmYsSUFBSWUsV0FBVyxHQUFJZixJQUFJaUIsWUFBWSxHQUFHLElBQUlqQixJQUFJaUIsWUFBWSxHQUFHO2dCQUMvRDtnQkFFQSxPQUFPakI7WUFDVDtZQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQTRDQyxHQUNESixrQkFBa0IsU0FBUzJFLHVCQUF1QnZFLEdBQUcsRUFBRXdFLFdBQVcsRUFBRUMsWUFBWTtnQkFDOUV6RSxNQUFNLElBQUksQ0FBQ2lFLGtCQUFrQixDQUFDakUsS0FBS3dFLGFBQWFDO2dCQUNoRCxNQUFNQyxVQUFVO2dCQUNoQixNQUFNQyxlQUFlO2dCQUNyQixNQUFNQyxzQ0FBc0M7Z0JBQzVDLElBQUkxSyxRQUFRLElBQUksQ0FBQ2lGLE9BQU8sR0FBRyxJQUFJLENBQUNKLE1BQU07Z0JBQ3RDLElBQUlzRCxRQUFRbkksTUFBTXVJLEtBQUssQ0FBQztnQkFDeEIsSUFBSW9DLEtBQUtDLEtBQUtDLEdBQUcsQ0FBQyxHQUFJUCxjQUFjQSxZQUFZeEQsVUFBVSxHQUFHaEIsSUFBSWdCLFVBQVUsR0FBRzBEO2dCQUM5RSxJQUFJTSxLQUFLRixLQUFLQyxHQUFHLENBQUMsR0FBSU4sZUFBZUEsYUFBYXZELFNBQVMsR0FBR2xCLElBQUlrQixTQUFTLEdBQUd5RDtnQkFDOUUsSUFBSU0sdUJBQXVCLElBQUlILEtBQUtJLEtBQUssQ0FBQ0YsS0FBSyxLQUFLO2dCQUNwRCxJQUFJRyxZQUFZLElBQUkvSyxNQUFNNkssc0JBQXNCMUcsSUFBSSxDQUFDO2dCQUNyRCxJQUFJNkcsd0JBQXdCLEVBQUU7Z0JBRTlCLElBQUloUixLQUFLaU8sTUFBTTdCLEtBQUssQ0FBQ3FFLEtBQUssR0FBR0csS0FBSyxHQUFHSyxHQUFHLENBQUMsU0FBU0MsaUJBQWlCekksSUFBSSxFQUFFMEksS0FBSztvQkFDNUUsSUFBSUMsTUFBTUQsUUFBUVY7b0JBQ2xCLElBQUlZLFVBQVUsQ0FBQ04sWUFBWUssR0FBRSxFQUFHOUMsTUFBTSxDQUFDLENBQUN1QztvQkFDeEMsSUFBSTdRLEtBQUtxUixVQUFVLE9BQU81STtvQkFDMUIsSUFBSTZJLFNBQVMsSUFBSXRMLE1BQU02Syx1QkFBdUIsR0FBRzFHLElBQUksQ0FBQztvQkFDdEQsSUFBSWMsU0FBUyxJQUFJO29CQUNqQixJQUFJakssTUFBTTtvQkFFVixJQUFJb1EsUUFBUXhGLElBQUlnQixVQUFVLEVBQUU7d0JBQzFCM0IsVUFBVVcsSUFBSWlCLFlBQVk7d0JBRTFCN0wsTUFBTTBQLEtBQUtDLEdBQUcsQ0FDWixHQUNBLENBQUVTLFFBQVF4RixJQUFJa0IsU0FBUyxHQUFHbEIsSUFBSWUsV0FBVyxHQUFHbEUsS0FBS2xJLE1BQU0sSUFBS3FMLElBQUlpQixZQUFZLEdBQUc7b0JBRW5GLE9BQU8sSUFBSXVFLFFBQVF4RixJQUFJa0IsU0FBUyxFQUFFO3dCQUNoQzlMLE1BQU0wUCxLQUFLQyxHQUFHLENBQUMsR0FBRy9FLElBQUllLFdBQVcsR0FBRztvQkFDdEMsT0FBTyxJQUFJeUUsTUFBTXhGLElBQUlnQixVQUFVLElBQUl3RSxNQUFNeEYsSUFBSWtCLFNBQVMsRUFBRTt3QkFDdEQ5TCxNQUFNMFAsS0FBS0MsR0FBRyxDQUFDLEdBQUdsSSxLQUFLbEksTUFBTSxHQUFHO29CQUNsQztvQkFFQSxJQUFJUyxLQUFLO3dCQUNQLElBQUl1USxPQUFPLElBQUl2TCxNQUFNaUYsUUFBUWQsSUFBSSxDQUFDO3dCQUNsQyxJQUFJcUgsT0FBTyxJQUFJeEwsTUFBTWhGLEtBQUttSixJQUFJLENBQUM7d0JBQy9CbkssTUFBTSxPQUFPc1IsU0FBU0MsT0FBT0M7d0JBRTdCLElBQUkvSSxLQUFLZ0osSUFBSSxHQUFHbFIsTUFBTSxHQUFHLEdBQUc7NEJBQzFCeVEsc0JBQXNCeFEsSUFBSSxDQUFDMlE7d0JBQzdCO29CQUNGO29CQUVBblIsS0FBS0EsR0FBR3NQLE9BQU8sQ0FBQyxPQUFPO29CQUN2QixPQUFPdFA7Z0JBQ1Q7Z0JBRUEsK0VBQStFO2dCQUMvRSxvQ0FBb0M7Z0JBQ3BDLElBQUlnUixzQkFBc0J6USxNQUFNLEdBQUcsSUFBSWlRLHFDQUFxQztvQkFDMUUsSUFBSWtCLGFBQWFWLHFCQUFxQixDQUFDUixzQ0FBc0MsRUFBRSxHQUFHO29CQUNsRixJQUFJbUIsV0FBV1gscUJBQXFCLENBQUNBLHNCQUFzQnpRLE1BQU0sR0FBR2lRLG9DQUFvQyxHQUFHO29CQUMzRyxJQUFJb0Isb0JBQW9CLElBQUk1TCxNQUFNNkssdUJBQXVCLEdBQUcxRyxJQUFJLENBQUMsT0FBTztvQkFDeEV5SCxxQkFBcUIsT0FBTyxJQUFJNUwsTUFBTTZLLHVCQUF1QixHQUFHMUcsSUFBSSxDQUFDLE9BQU87b0JBQzVFbkssR0FBRzZSLE1BQU0sQ0FBQ0gsWUFBWUMsV0FBV0QsYUFBYSxHQUFHRTtnQkFDbkQ7Z0JBRUEsT0FBTzVSLEdBQUdtSyxJQUFJLENBQUM7WUFDakI7WUFFQTs7Ozs7Ozs7O0tBU0MsR0FDRDJILGdCQUFnQixTQUFTQyxzQkFBc0I1RyxNQUFNLEVBQUU2RyxpQkFBaUI7Z0JBQ3RFLElBQUlwQixLQUFLekYsT0FBT3lCLFVBQVU7Z0JBQzFCLElBQUlxRixLQUFLOUcsT0FBTzJCLFNBQVM7Z0JBQ3pCLElBQUlvRixLQUFLL0csT0FBTzBCLFlBQVk7Z0JBQzVCLElBQUlzRixLQUFLaEgsT0FBT3dCLFdBQVc7Z0JBQzNCLElBQUl5RixLQUFLSCxLQUFLckI7Z0JBQ2QsSUFBSXlCLEtBQUtGLEtBQUtEO2dCQUNkLElBQUlsUztnQkFFSixJQUFJb1MsT0FBTyxHQUFHO29CQUNacFMsS0FBSyxVQUFVNFEsS0FBSztvQkFFcEIsSUFBSXlCLE1BQU0sR0FBRzt3QkFDWHJTLE1BQU0sWUFBWWtTO29CQUNwQixPQUFPO3dCQUNMbFMsTUFBTSxhQUFha1MsS0FBSyxTQUFTQztvQkFDbkM7Z0JBQ0YsT0FBTztvQkFDTG5TLEtBQUssV0FBVzRRLEtBQUssYUFBYXNCLEtBQUssVUFBVUQsS0FBSyxhQUFhRSxLQUFLO2dCQUMxRTtnQkFFQSxJQUFJaEgsT0FBTzRCLEtBQUssSUFBSWlGLG1CQUFtQjtvQkFDckMsSUFBSU0sS0FBS25ILE9BQU80QixLQUFLLENBQUMsRUFBRTtvQkFDeEIsSUFBSXdGLEtBQUtwSCxPQUFPNEIsS0FBSyxDQUFDLEVBQUUsR0FBRztvQkFFM0IsSUFBSXdGLE1BQU1ELElBQUk7d0JBQ1p0UyxNQUFNLHNCQUFzQnNTLEtBQUs7b0JBQ25DLE9BQU87d0JBQ0x0UyxNQUFNLDRCQUE0QnNTLEtBQUssU0FBU0MsS0FBSztvQkFDdkQ7Z0JBQ0Y7Z0JBRUEsT0FBT3ZTO1lBQ1Q7WUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FpQkMsR0FDRHdTLFlBQVksU0FBU0MsaUJBQWlCcEssS0FBSyxFQUFFcUssWUFBWTtnQkFDdkQsSUFBSW5LLE9BQU8wRixPQUFPMEUsUUFBUUMsV0FBV0M7Z0JBRXJDLElBQUksSUFBSSxDQUFDelEsT0FBTyxDQUFDeU0sZUFBZSxFQUFFO29CQUNoQyxlQUFlO29CQUNmOEQsU0FBUzt3QkFDUGpLLFVBQVUsSUFBSSxDQUFDQSxRQUFRO3dCQUV2QnlDLFFBQVE7NEJBQ055QixZQUFZLElBQUksQ0FBQ3pCLE1BQU0sQ0FBQ3lCLFVBQVU7NEJBQ2xDRSxXQUFXLElBQUksQ0FBQzNCLE1BQU0sQ0FBQzJCLFNBQVM7NEJBQ2hDRCxjQUFjLElBQUksQ0FBQzFCLE1BQU0sQ0FBQzBCLFlBQVk7NEJBQ3RDRixhQUFhLElBQUksQ0FBQ3hCLE1BQU0sQ0FBQ3dCLFdBQVc7NEJBQ3BDSSxPQUFPLElBQUksQ0FBQzVCLE1BQU0sQ0FBQzRCLEtBQUssQ0FBQ1gsS0FBSyxDQUFDO3dCQUNqQzt3QkFFQTlELFFBQVEsSUFBSSxDQUFDQSxNQUFNO3dCQUNuQkQsT0FBTyxJQUFJLENBQUNBLEtBQUs7d0JBQ2pCMkMsU0FBUyxJQUFJLENBQUNBLE9BQU87d0JBQ3JCRCxTQUFTLElBQUksQ0FBQ0EsT0FBTzt3QkFDckJHLFFBQVEsSUFBSSxDQUFDQSxNQUFNO3dCQUNuQkQsUUFBUSxJQUFJLENBQUNBLE1BQU07d0JBQ25CTCxPQUFPLElBQUksQ0FBQ0EsS0FBSzt3QkFDakJELFFBQVEsSUFBSSxDQUFDQSxNQUFNO3dCQUVuQixvREFBb0Q7d0JBQ3BEeEksSUFBSSxJQUFJLENBQUNBLEVBQUU7d0JBRVgySSxnQkFBZ0IsSUFBSSxDQUFDQSxjQUFjLENBQUNzQixLQUFLLENBQUM7d0JBQzFDM0IsTUFBTSxJQUFJLENBQUNBLElBQUk7b0JBQ2pCO2dCQUNGO2dCQUVBbUksWUFBWXZLLEtBQUssQ0FBQyxFQUFFO2dCQUNwQndLLGdCQUFnQkQsVUFBVXJTLE1BQU07Z0JBRWhDLDBFQUEwRTtnQkFDMUUwTixRQUFRMkUsVUFBVXZFLEtBQUssQ0FBQztnQkFFeEIsSUFBSUosTUFBTTFOLE1BQU0sR0FBRyxHQUFHO29CQUNwQixJQUFJLENBQUNtSSxRQUFRLElBQUl1RixNQUFNMU4sTUFBTSxHQUFHO29CQUNoQyxJQUFJLENBQUM0SyxNQUFNLENBQUMyQixTQUFTLEdBQUcsSUFBSSxDQUFDcEUsUUFBUSxHQUFHO29CQUN4QyxJQUFJLENBQUN5QyxNQUFNLENBQUN3QixXQUFXLEdBQUdzQixLQUFLLENBQUNBLE1BQU0xTixNQUFNLEdBQUcsRUFBRSxDQUFDQSxNQUFNO2dCQUMxRCxPQUFPO29CQUNMLElBQUksQ0FBQzRLLE1BQU0sQ0FBQ3dCLFdBQVcsSUFBSWtHO2dCQUM3QjtnQkFFQSxJQUFJO2dCQUNKLElBQUksQ0FBQ3ZLLE1BQU0sSUFBSXNLO2dCQUVmLElBQUksQ0FBQ3ZLLEtBQUssSUFBSXVLO2dCQUNkLElBQUksQ0FBQzdILE9BQU8sSUFBSTZIO2dCQUNoQixJQUFJLENBQUM1SCxPQUFPLEdBQUczQztnQkFDZixJQUFJLENBQUM2QyxNQUFNLEdBQUcsSUFBSSxDQUFDNUMsTUFBTSxDQUFDL0gsTUFBTTtnQkFDaEMsSUFBSSxDQUFDNEssTUFBTSxDQUFDNEIsS0FBSyxDQUFDLEVBQUUsSUFBSThGO2dCQUV4QixzRkFBc0Y7Z0JBQ3RGLDBGQUEwRjtnQkFDMUYsbURBQW1EO2dCQUNuRCxJQUFJLENBQUM1SCxNQUFNLElBQUk0SDtnQkFFZixJQUFJLENBQUNqSSxLQUFLLEdBQUc7Z0JBQ2IsSUFBSSxDQUFDRixVQUFVLEdBQUc7Z0JBQ2xCLElBQUksQ0FBQ0MsTUFBTSxHQUFHLElBQUksQ0FBQ0EsTUFBTSxDQUFDeUIsS0FBSyxDQUFDeUc7Z0JBRWhDLHVCQUF1QjtnQkFDdkIsRUFBRTtnQkFDRixvRUFBb0U7Z0JBQ3BFdEssUUFBUSxJQUFJLENBQUNsRSxhQUFhLENBQUNpRCxJQUFJLENBQzdCLElBQUksRUFDSixJQUFJLENBQUNuRixFQUFFLEVBQ1B1USxjQUNBLElBQUksQ0FBQzVILGNBQWMsQ0FBQyxJQUFJLENBQUNBLGNBQWMsQ0FBQ3ZLLE1BQU0sR0FBRyxFQUFFO2dCQUdyRCwyRUFBMkU7Z0JBQzNFLHNEQUFzRDtnQkFFdEQsSUFBSSxJQUFJLENBQUNrSyxJQUFJLElBQUksSUFBSSxDQUFDRSxNQUFNLEVBQUU7b0JBQzVCLElBQUksQ0FBQ0YsSUFBSSxHQUFHO2dCQUNkO2dCQUVBLElBQUlsQyxPQUFPO29CQUNULE9BQU9BO2dCQUNULE9BQU8sSUFBSSxJQUFJLENBQUNtQyxVQUFVLEVBQUU7b0JBQzFCLGtCQUFrQjtvQkFDbEIsSUFBSyxJQUFJckQsS0FBS3NMLE9BQVE7d0JBQ3BCLElBQUksQ0FBQ3RMLEVBQUUsR0FBR3NMLE1BQU0sQ0FBQ3RMLEVBQUU7b0JBQ3JCO29CQUVBLElBQUksQ0FBQ2tELGtCQUFrQixHQUFHO29CQUMxQixPQUFPLE9BQVEsZ0ZBQWdGO2dCQUNqRyxPQUFPLElBQUksSUFBSSxDQUFDTSxxQkFBcUIsRUFBRTtvQkFDckMsNkRBQTZEO29CQUM3RCwrREFBK0Q7b0JBQy9EdEMsUUFBUSxJQUFJLENBQUNzQyxxQkFBcUI7b0JBRWxDLElBQUksQ0FBQ0EscUJBQXFCLEdBQUc7b0JBQzdCLE9BQU90QztnQkFDVDtnQkFFQSxPQUFPO1lBQ1Q7WUFFQTs7Ozs7S0FLQyxHQUNEa0gsTUFBTSxTQUFTcUQ7Z0JBQ2IsSUFBSSxJQUFJLENBQUNySSxJQUFJLEVBQUU7b0JBQ2IsSUFBSSxDQUFDK0IsS0FBSztvQkFDVixPQUFPLElBQUksQ0FBQzlKLEdBQUc7Z0JBQ2pCO2dCQUVBLElBQUksQ0FBQyxJQUFJLENBQUNpSSxNQUFNLEVBQUU7b0JBQ2hCLElBQUksQ0FBQ0YsSUFBSSxHQUFHO2dCQUNkO2dCQUVBLElBQUlsQyxPQUFPRixPQUFPMEssV0FBVzVCO2dCQUU3QixJQUFJLENBQUMsSUFBSSxDQUFDdkcsS0FBSyxFQUFFO29CQUNmLElBQUksQ0FBQzRCLEtBQUs7Z0JBQ1o7Z0JBRUEsSUFBSVksT0FBTyxJQUFJLENBQUM3QyxrQkFBa0I7Z0JBRWxDLElBQUksQ0FBQzZDLE1BQU07b0JBQ1QsK0ZBQStGO29CQUMvRiwyR0FBMkc7b0JBQzNHLHlHQUF5RztvQkFDekcsd0NBQXdDO29CQUN4Q0EsT0FBTyxJQUFJLENBQUM3QyxrQkFBa0IsR0FBRyxJQUFJLENBQUN5SSxhQUFhO29CQUVuRCwrRkFBK0Y7b0JBQy9GLDRFQUE0RTtvQkFDNUUsSUFBSSxDQUFDNUYsUUFBUSxDQUFDQSxLQUFLSCxLQUFLLEVBQUU7d0JBQ3hCLElBQUloQixhQUFhO3dCQUVqQixJQUFJLElBQUksQ0FBQzdKLE9BQU8sQ0FBQzZRLGFBQWEsRUFBRTs0QkFDOUJoSCxhQUFhLGNBQWUsS0FBSSxDQUFDdkQsUUFBUSxHQUFHO3dCQUM5Qzt3QkFFQSxJQUFJekksSUFBSSxJQUFJLENBQUNtTCxxQkFBcUIsQ0FDaEMsZ0NBQWdDYSxhQUFhLHdFQUF3RSxJQUFJLENBQUNpSCxRQUFRLEtBQUssdUZBQ3ZJO3dCQUdGLHdHQUF3Rzt3QkFDeEcsT0FBTyxJQUFJLENBQUMxTixVQUFVLENBQUN2RixFQUFFa0ksTUFBTSxFQUFFbEksR0FBRyxJQUFJLENBQUNvSyxlQUFlLEtBQUssSUFBSSxDQUFDQyxLQUFLO29CQUN6RTtnQkFDRjtnQkFFQSxJQUFJK0MsV0FBV0QsS0FBS0gsS0FBSztnQkFDekIsSUFBSWtHLFVBQVUvRixLQUFLSSxjQUFjO2dCQUNqQyxJQUFJeE0sTUFBTW9NLEtBQUtLLFlBQVk7Z0JBRTNCLHFFQUFxRTtnQkFDckUseUVBQXlFO2dCQUN6RSxJQUFLLElBQUlwTixJQUFJLEdBQUdBLEtBQUtXLEtBQUtYLElBQUs7b0JBQzdCMFMsWUFBWSxJQUFJLENBQUNwSSxNQUFNLENBQUN0QyxLQUFLLENBQUM4SyxPQUFPLENBQUM5UyxFQUFFO29CQUV4QyxJQUFJMFMsYUFBYyxFQUFDMUssU0FBUzBLLFNBQVMsQ0FBQyxFQUFFLENBQUN4UyxNQUFNLEdBQUc4SCxLQUFLLENBQUMsRUFBRSxDQUFDOUgsTUFBTSxHQUFHO3dCQUNsRThILFFBQVEwSzt3QkFDUjVCLFFBQVE5UTt3QkFFUixJQUFJLElBQUksQ0FBQytCLE9BQU8sQ0FBQ3lNLGVBQWUsRUFBRTs0QkFDaEN0RyxRQUFRLElBQUksQ0FBQ2lLLFVBQVUsQ0FBQ08sV0FBVzFGLFFBQVEsQ0FBQ2hOLEVBQUU7NEJBRTlDLElBQUlrSSxVQUFVLE9BQU87Z0NBQ25CLE9BQU9BOzRCQUNULE9BQU8sSUFBSSxJQUFJLENBQUNtQyxVQUFVLEVBQUU7Z0NBQzFCckMsUUFBUTdCO2dDQUNSLFVBQVcseURBQXlEOzRCQUN0RSxPQUFPO2dDQUNMLDhGQUE4RjtnQ0FDOUYsT0FBTzs0QkFDVDt3QkFDRixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUNwRSxPQUFPLENBQUNnUixJQUFJLEVBQUU7NEJBQzdCO3dCQUNGO29CQUNGO2dCQUNGO2dCQUVBLElBQUkvSyxPQUFPO29CQUNURSxRQUFRLElBQUksQ0FBQ2lLLFVBQVUsQ0FBQ25LLE9BQU9nRixRQUFRLENBQUM4RCxNQUFNO29CQUU5QyxJQUFJNUksVUFBVSxPQUFPO3dCQUNuQixPQUFPQTtvQkFDVDtvQkFFQSw4RkFBOEY7b0JBQzlGLE9BQU87Z0JBQ1Q7Z0JBRUEsSUFBSSxDQUFDLElBQUksQ0FBQ29DLE1BQU0sRUFBRTtvQkFDaEIsSUFBSSxDQUFDRixJQUFJLEdBQUc7b0JBQ1osSUFBSSxDQUFDK0IsS0FBSztvQkFDVixPQUFPLElBQUksQ0FBQzlKLEdBQUc7Z0JBQ2pCLE9BQU87b0JBQ0wsSUFBSXVKLGFBQWE7b0JBRWpCLElBQUksSUFBSSxDQUFDN0osT0FBTyxDQUFDNlEsYUFBYSxFQUFFO3dCQUM5QmhILGFBQWEsY0FBZSxLQUFJLENBQUN2RCxRQUFRLEdBQUc7b0JBQzlDO29CQUVBLElBQUl6SSxJQUFJLElBQUksQ0FBQ21MLHFCQUFxQixDQUNoQyxrQkFBa0JhLGFBQWEsd0JBQy9CLElBQUksQ0FBQzdKLE9BQU8sQ0FBQzhKLHlCQUF5QjtvQkFHeEMsSUFBSW1ILGVBQWUsSUFBSSxDQUFDMUksTUFBTTtvQkFDOUIsSUFBSTJJLGtCQUFrQixJQUFJLENBQUNKLFFBQVE7b0JBQ25DLElBQUlLLHNCQUFzQixJQUFJLENBQUN6SSxjQUFjLENBQUN2SyxNQUFNO29CQUNwRGdJLFFBQVEsSUFBSSxDQUFDL0MsVUFBVSxDQUFDdkYsRUFBRWtJLE1BQU0sRUFBRWxJLEdBQUcsSUFBSSxDQUFDb0ssZUFBZSxLQUFLLElBQUksQ0FBQ0MsS0FBSztvQkFFeEUsSUFBSS9CLFVBQVUsSUFBSSxDQUFDK0IsS0FBSyxFQUFFO3dCQUN4Qix3RkFBd0Y7d0JBQ3hGLDhGQUE4Rjt3QkFDOUYscUZBQXFGO3dCQUNyRixJQUFJLENBQUMsSUFBSSxDQUFDVSxPQUFPLElBQUkseURBQXlEO3dCQUM5RXFJLGlCQUFpQixJQUFJLENBQUMxSSxNQUFNLElBQUksK0RBQStEO3dCQUMvRiw0REFBNEQ7d0JBQzVEMkksb0JBQW9CLElBQUksQ0FBQ0osUUFBUSxNQUFNSyx3QkFBd0IsSUFBSSxDQUFDekksY0FBYyxDQUFDdkssTUFBTSxFQUFFOzRCQUN6RixJQUFJLENBQUN1RixLQUFLO3dCQUNaO29CQUNGO29CQUVBLE9BQU95QztnQkFDVDtZQUNGO1lBRUE7Ozs7O0tBS0MsR0FDRGdCLEtBQUssU0FBU2lLO2dCQUNaLElBQUlyVDtnQkFFSiwwR0FBMEc7Z0JBQzFHLElBQUksT0FBTyxJQUFJLENBQUN3RyxPQUFPLEtBQUssWUFBWTtvQkFDdEN4RyxJQUFJLElBQUksQ0FBQ3dHLE9BQU8sQ0FBQ1csSUFBSSxDQUFDLElBQUksRUFBRTtnQkFDOUI7Z0JBRUEsSUFBSSxPQUFPLElBQUksQ0FBQ2xGLE9BQU8sQ0FBQ3VFLE9BQU8sS0FBSyxZQUFZO29CQUM5Qyw4RkFBOEY7b0JBQzlGeEcsSUFBSSxJQUFJLENBQUNpQyxPQUFPLENBQUN1RSxPQUFPLENBQUNXLElBQUksQ0FBQyxJQUFJLEVBQUVuSCxNQUFNQTtnQkFDNUM7Z0JBRUEsSUFBSSxJQUFJLENBQUNnQyxFQUFFLElBQUksT0FBTyxJQUFJLENBQUNBLEVBQUUsQ0FBQ3dFLE9BQU8sS0FBSyxZQUFZO29CQUNwRCw4RkFBOEY7b0JBQzlGeEcsSUFBSSxJQUFJLENBQUNnQyxFQUFFLENBQUN3RSxPQUFPLENBQUNXLElBQUksQ0FBQyxJQUFJLEVBQUVuSCxNQUFNQTtnQkFDdkM7Z0JBRUEsTUFBTyxDQUFDQSxFQUFHO29CQUNUQSxJQUFJLElBQUksQ0FBQ3NQLElBQUk7Z0JBQ2Y7Z0JBRUEsSUFBSSxJQUFJLENBQUN0TixFQUFFLElBQUksT0FBTyxJQUFJLENBQUNBLEVBQUUsQ0FBQ3lFLFFBQVEsS0FBSyxZQUFZO29CQUNyRCw4RkFBOEY7b0JBQzlGekcsSUFBSSxJQUFJLENBQUNnQyxFQUFFLENBQUN5RSxRQUFRLENBQUNVLElBQUksQ0FBQyxJQUFJLEVBQUVuSCxNQUFNQTtnQkFDeEM7Z0JBRUEsSUFBSSxPQUFPLElBQUksQ0FBQ2lDLE9BQU8sQ0FBQ3dFLFFBQVEsS0FBSyxZQUFZO29CQUMvQyw4RkFBOEY7b0JBQzlGekcsSUFBSSxJQUFJLENBQUNpQyxPQUFPLENBQUN3RSxRQUFRLENBQUNVLElBQUksQ0FBQyxJQUFJLEVBQUVuSCxNQUFNQTtnQkFDN0M7Z0JBRUEsSUFBSSxPQUFPLElBQUksQ0FBQ3lHLFFBQVEsS0FBSyxZQUFZO29CQUN2Qyw4RkFBOEY7b0JBQzlGekcsSUFBSSxJQUFJLENBQUN5RyxRQUFRLENBQUNVLElBQUksQ0FBQyxJQUFJLEVBQUVuSCxNQUFNQTtnQkFDckM7Z0JBRUEsT0FBT0E7WUFDVDtZQUVBOzs7Ozs7S0FNQyxHQUNEcUosU0FBUyxTQUFTaUs7Z0JBQ2hCLElBQUl0VDtnQkFFSixNQUFPLENBQUNBLEVBQUc7b0JBQ1RBLElBQUksSUFBSSxDQUFDc1AsSUFBSTtnQkFDZjtnQkFFQSxPQUFPdFA7WUFDVDtZQUVBOzs7Ozs7O0tBT0MsR0FDRDRKLFNBQVMsU0FBUzJKO2dCQUNoQixJQUFJMVQsS0FBSztvQkFDUHdKLFNBQVMsQ0FBRSxRQUFPLElBQUksQ0FBQzdDLE9BQU8sS0FBSyxjQUFjLE9BQU8sSUFBSSxDQUFDdkUsT0FBTyxDQUFDdUUsT0FBTyxLQUFLLGNBQWMsSUFBSSxDQUFDeEUsRUFBRSxJQUFJLE9BQU8sSUFBSSxDQUFDQSxFQUFFLENBQUN3RSxPQUFPLEtBQUssY0FBYyxJQUFJLENBQUN4RSxFQUFFLElBQUksT0FBTyxJQUFJLENBQUNBLEVBQUUsQ0FBQ3lFLFFBQVEsS0FBSyxjQUFjLE9BQU8sSUFBSSxDQUFDeEUsT0FBTyxDQUFDd0UsUUFBUSxLQUFLLGNBQWMsT0FBTyxJQUFJLENBQUNBLFFBQVEsS0FBSyxVQUFTLEtBQU0sT0FBTyxJQUFJLENBQUM0QyxPQUFPLEtBQUs7Z0JBQ3pUO2dCQUVBLE9BQU94SjtZQUNUO1lBRUE7Ozs7Ozs7S0FPQyxHQUNEMlQsT0FBTyxTQUFTQyxZQUFZQyxTQUFTO2dCQUNuQyxPQUFPLElBQUksQ0FBQ0MsU0FBUyxDQUFDRDtZQUN4QjtZQUVBOzs7Ozs7S0FNQyxHQUNEQyxXQUFXLFNBQVNDLGdCQUFnQkYsU0FBUztnQkFDM0MsSUFBSSxDQUFDL0ksY0FBYyxDQUFDdEssSUFBSSxDQUFDcVQ7Z0JBQ3pCLElBQUksQ0FBQ3RKLGtCQUFrQixHQUFHO2dCQUMxQixPQUFPLElBQUk7WUFDYjtZQUVBOzs7Ozs7S0FNQyxHQUNEeUosVUFBVSxTQUFTQztnQkFDakIsSUFBSXhTLElBQUksSUFBSSxDQUFDcUosY0FBYyxDQUFDdkssTUFBTSxHQUFHO2dCQUVyQyxJQUFJa0IsSUFBSSxHQUFHO29CQUNULElBQUksQ0FBQzhJLGtCQUFrQixHQUFHO29CQUMxQixPQUFPLElBQUksQ0FBQ08sY0FBYyxDQUFDNUssR0FBRztnQkFDaEMsT0FBTztvQkFDTCxPQUFPLElBQUksQ0FBQzRLLGNBQWMsQ0FBQyxFQUFFO2dCQUMvQjtZQUNGO1lBRUE7Ozs7Ozs7S0FPQyxHQUNEb0ksVUFBVSxTQUFTZ0IsZUFBZXpTLENBQUM7Z0JBQ2pDQSxJQUFJLElBQUksQ0FBQ3FKLGNBQWMsQ0FBQ3ZLLE1BQU0sR0FBRyxJQUFJbVEsS0FBS3lELEdBQUcsQ0FBQzFTLEtBQUs7Z0JBRW5ELElBQUlBLEtBQUssR0FBRztvQkFDVixPQUFPLElBQUksQ0FBQ3FKLGNBQWMsQ0FBQ3JKLEVBQUU7Z0JBQy9CLE9BQU87b0JBQ0wsT0FBTztnQkFDVDtZQUNGO1lBRUE7Ozs7OztLQU1DLEdBQ0R1UixlQUFlLFNBQVNvQjtnQkFDdEIsSUFBSSxJQUFJLENBQUN0SixjQUFjLENBQUN2SyxNQUFNLElBQUksSUFBSSxDQUFDdUssY0FBYyxDQUFDLElBQUksQ0FBQ0EsY0FBYyxDQUFDdkssTUFBTSxHQUFHLEVBQUUsRUFBRTtvQkFDckYsT0FBTyxJQUFJLENBQUM0TSxVQUFVLENBQUMsSUFBSSxDQUFDckMsY0FBYyxDQUFDLElBQUksQ0FBQ0EsY0FBYyxDQUFDdkssTUFBTSxHQUFHLEVBQUUsQ0FBQztnQkFDN0UsT0FBTztvQkFDTCxPQUFPLElBQUksQ0FBQzRNLFVBQVUsQ0FBQyxVQUFVO2dCQUNuQztZQUNGO1lBRUE7Ozs7O0tBS0MsR0FDRGtILGdCQUFnQixTQUFTQztnQkFDdkIsT0FBTyxJQUFJLENBQUN4SixjQUFjLENBQUN2SyxNQUFNO1lBQ25DO1lBRUE2QixTQUFTO2dCQUNQNlEsZUFBZTtZQUNqQjtZQUVBNUksaUJBQWlCQTtZQUVqQmhHLGVBQWUsU0FBU2tRLHFCQUFxQnBTLEVBQUUsRUFBRXFTLFlBQVksRUFBRUMsUUFBUTtnQkFDckUsSUFBSUMsTUFBTSxJQUFJO2dCQUNkLElBQUlDLFVBQVVGO2dCQUVkLE9BQVFEO29CQUNSLEtBQUs7d0JBSUg7b0JBRUY7d0JBQ0UsT0FBTyxJQUFJLENBQUNJLHdCQUF3QixDQUFDSixhQUFhO2dCQUNwRDtZQUNGO1lBRUFJLDBCQUEwQjtnQkFDeEIseUJBQXlCLEdBQ3pCLG9DQUFvQyxHQUNwQyxHQUFHO2dCQUVILHlCQUF5QixHQUN6QixvQkFBb0IsR0FDcEIsR0FBRztnQkFFSCx5QkFBeUIsR0FDekIsb0JBQW9CLEdBQ3BCLEdBQUc7Z0JBRUgseUJBQXlCLEdBQ3pCLG9CQUFvQixHQUNwQixHQUFHO2dCQUVILHlCQUF5QixHQUN6QixtQkFBbUIsR0FDbkIsR0FBRztnQkFFSCx5QkFBeUIsR0FDekIsa0RBQWtELEdBQ2xELEdBQUc7Z0JBRUgseUJBQXlCLEdBQ3pCLGtEQUFrRCxHQUNsRCxHQUFHO2dCQUVILHlCQUF5QixHQUN6QixrREFBa0QsR0FDbEQsR0FBRztnQkFFSCx5QkFBeUIsR0FDekIsa0RBQWtELEdBQ2xELEdBQUc7Z0JBRUgseUJBQXlCLEdBQ3pCLGtEQUFrRCxHQUNsRCxJQUFJO2dCQUVKLHlCQUF5QixHQUN6QixrREFBa0QsR0FDbEQsSUFBSTtnQkFFSix5QkFBeUIsR0FDekIsbURBQW1ELEdBQ25ELElBQUk7Z0JBRUoseUJBQXlCLEdBQ3pCLG9EQUFvRCxHQUNwRCxJQUFJO2dCQUVKLHlCQUF5QixHQUN6QixtREFBbUQsR0FDbkQsSUFBSTtnQkFFSix5QkFBeUIsR0FDekIsb0RBQW9ELEdBQ3BELElBQUk7Z0JBRUoseUJBQXlCLEdBQ3pCLGlEQUFpRCxHQUNqRCxJQUFJO2dCQUVKLHlCQUF5QixHQUN6QixrREFBa0QsR0FDbEQsSUFBSTtnQkFFSix5QkFBeUIsR0FDekIsa0RBQWtELEdBQ2xELElBQUk7Z0JBRUoseUJBQXlCLEdBQ3pCLG1EQUFtRCxHQUNuRCxJQUFJO2dCQUVKLHlCQUF5QixHQUN6QixtREFBbUQsR0FDbkQsSUFBSTtnQkFFSix5QkFBeUIsR0FDekIsb0RBQW9ELEdBQ3BELElBQUk7Z0JBRUoseUJBQXlCLEdBQ3pCLG9EQUFvRCxHQUNwRCxJQUFJO2dCQUVKLHlCQUF5QixHQUN6QixrREFBa0QsR0FDbEQsSUFBSTtnQkFFSix5QkFBeUIsR0FDekIsa0RBQWtELEdBQ2xELElBQUk7Z0JBRUoseUJBQXlCLEdBQ3pCLGtEQUFrRCxHQUNsRCxJQUFJO2dCQUVKLHlCQUF5QixHQUN6QixtREFBbUQsR0FDbkQsSUFBSTtnQkFFSix5QkFBeUIsR0FDekIsa0RBQWtELEdBQ2xELElBQUk7Z0JBRUoseUJBQXlCLEdBQ3pCLGtEQUFrRCxHQUNsRCxJQUFJO2dCQUVKLHlCQUF5QixHQUN6QixvREFBb0QsR0FDcEQsSUFBSTtnQkFFSix5QkFBeUIsR0FDekIsb0RBQW9ELEdBQ3BELElBQUk7Z0JBRUoseUJBQXlCLEdBQ3pCLCtDQUErQyxHQUMvQyxJQUFJO2dCQUVKLHlCQUF5QixHQUN6QixnREFBZ0QsR0FDaEQsSUFBSTtnQkFFSix5QkFBeUIsR0FDekIsd0JBQXdCLEdBQ3hCLElBQUk7Z0JBRUoseUJBQXlCLEdBQ3pCLHVCQUF1QixHQUN2QixJQUFJO2dCQUVKLHlCQUF5QixHQUN6QiwwQkFBMEIsR0FDMUIsSUFBSTtnQkFFSix5QkFBeUIsR0FDekIsb0JBQW9CLEdBQ3BCLElBQUk7Z0JBRUoseUJBQXlCLEdBQ3pCLG9CQUFvQixHQUNwQixJQUFJO2dCQUVKLHlCQUF5QixHQUN6QixtQkFBbUIsR0FDbkIsSUFBSTtnQkFFSix5QkFBeUIsR0FDekIsbUJBQW1CLEdBQ25CLElBQUk7WUFDTjtZQUVBM0gsT0FBTztnQkFDTCxPQUFPLEdBQUk7Z0JBQ1gsT0FBTyxHQUFJO2dCQUNYLE9BQU8sR0FBSTtnQkFDWCxPQUFPLEdBQUk7Z0JBQ1gsT0FBTyxHQUFJO2dCQUNYLE9BQU8sR0FBSTtnQkFDWCxPQUFPLEdBQUk7Z0JBQ1gsT0FBTyxHQUFJO2dCQUNYLE9BQU8sR0FBSTtnQkFDWCxPQUFPLEdBQUk7Z0JBQ1gsT0FBTyxHQUFJO2dCQUNYLE9BQU8sR0FBSTtnQkFDWCxPQUFPLEdBQUk7Z0JBQ1gsT0FBTyxHQUFJO2dCQUNYLE9BQU8sR0FBSTtnQkFDWCxPQUFPLEdBQUk7Z0JBQ1gsT0FBTyxHQUFJO2dCQUNYLE9BQU8sR0FBSTtnQkFDWCxPQUFPLEdBQUk7Z0JBQ1gsT0FBTyxHQUFJO2dCQUNYLE9BQU8sR0FBSTtnQkFDWCxPQUFPLEdBQUk7Z0JBQ1gsT0FBTyxHQUFJO2dCQUNYLE9BQU8sR0FBSTtnQkFDWCxPQUFPLEdBQUk7Z0JBQ1gsT0FBTyxHQUFJO2dCQUNYLE9BQU8sR0FBSTtnQkFDWCxPQUFPLEdBQUk7Z0JBQ1gsT0FBTyxHQUFJO2dCQUNYLE9BQU8sR0FBSTtnQkFDWCxPQUFPLEdBQUk7Z0JBQ1gsT0FBTyxHQUFJO2dCQUNYLE9BQU8sR0FBSTtnQkFDWCxPQUFPLEdBQUk7Z0JBQ1gsT0FBTyxHQUFJO2dCQUNYLE9BQU8sR0FBSTtnQkFDWCxPQUFPLEdBQUk7Z0JBQ1gsT0FBTyxHQUFJO2dCQUNYLE9BQU8sR0FBSTtnQkFDWCxPQUFPLEdBQUk7YUFDWjtZQUVERSxZQUFZO2dCQUNWLFdBQVc7b0JBQ1RGLE9BQU87d0JBQ0w7d0JBQ0E7d0JBQ0E7d0JBQ0E7d0JBQ0E7d0JBQ0E7d0JBQ0E7d0JBQ0E7d0JBQ0E7d0JBQ0E7d0JBQ0E7d0JBQ0E7d0JBQ0E7d0JBQ0E7d0JBQ0E7d0JBQ0E7d0JBQ0E7d0JBQ0E7d0JBQ0E7d0JBQ0E7d0JBQ0E7d0JBQ0E7d0JBQ0E7d0JBQ0E7d0JBQ0E7d0JBQ0E7d0JBQ0E7d0JBQ0E7d0JBQ0E7d0JBQ0E7d0JBQ0E7d0JBQ0E7d0JBQ0E7d0JBQ0E7d0JBQ0E7d0JBQ0E7d0JBQ0E7d0JBQ0E7d0JBQ0E7d0JBQ0E7cUJBQ0Q7b0JBRUQ0SCxXQUFXO2dCQUNiO1lBQ0Y7UUFDRjtRQUVBLE9BQU9qUTtJQUNUO0lBQ0FwRyxPQUFPb0csS0FBSyxHQUFHQTtJQUlmLFNBQVNrUTtRQUNQLElBQUksQ0FBQzNTLEVBQUUsR0FBRyxDQUFDO0lBQ2I7SUFDQTJTLE9BQU9uVixTQUFTLEdBQUduQjtJQUNuQkEsT0FBT3NXLE1BQU0sR0FBR0E7SUFFaEIsT0FBTyxJQUFJQTtBQUNYO0FBS0EsSUFBSSxJQUFxRCxFQUFhO0lBQ3BFRSxjQUFjLEdBQUd4VztJQUNqQndXLGNBQWMsR0FBR3hXLE9BQU9zVyxNQUFNO0lBQzlCRSxhQUFhLEdBQUc7UUFDZCxPQUFPeFcsT0FBT3FILEtBQUssQ0FBQzdELEtBQUssQ0FBQ3hELFFBQVE2TjtJQUNwQztBQUVGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5jb21lLWV4cGVuc2UtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvcmVkdWNlLWNzcy1jYWxjL2Rpc3QvcGFyc2VyLmpzPzEwNmIiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKiBwYXJzZXIgZ2VuZXJhdGVkIGJ5IGppc29uIDAuNi4xLTIxNSAqL1xuXG4vKlxuICogUmV0dXJucyBhIFBhcnNlciBvYmplY3Qgb2YgdGhlIGZvbGxvd2luZyBzdHJ1Y3R1cmU6XG4gKlxuICogIFBhcnNlcjoge1xuICogICAgeXk6IHt9ICAgICBUaGUgc28tY2FsbGVkIFwic2hhcmVkIHN0YXRlXCIgb3IgcmF0aGVyIHRoZSAqc291cmNlKiBvZiBpdDtcbiAqICAgICAgICAgICAgICAgdGhlIHJlYWwgXCJzaGFyZWQgc3RhdGVcIiBgeXlgIHBhc3NlZCBhcm91bmQgdG9cbiAqICAgICAgICAgICAgICAgdGhlIHJ1bGUgYWN0aW9ucywgZXRjLiBpcyBhIGRlcml2YXRpdmUvY29weSBvZiB0aGlzIG9uZSxcbiAqICAgICAgICAgICAgICAgbm90IGEgZGlyZWN0IHJlZmVyZW5jZSFcbiAqICB9XG4gKlxuICogIFBhcnNlci5wcm90b3R5cGU6IHtcbiAqICAgIHl5OiB7fSxcbiAqICAgIEVPRjogMSxcbiAqICAgIFRFUlJPUjogMixcbiAqXG4gKiAgICB0cmFjZTogZnVuY3Rpb24oZXJyb3JNZXNzYWdlLCAuLi4pLFxuICpcbiAqICAgIEppc29uUGFyc2VyRXJyb3I6IGZ1bmN0aW9uKG1zZywgaGFzaCksXG4gKlxuICogICAgcXVvdGVOYW1lOiBmdW5jdGlvbihuYW1lKSxcbiAqICAgICAgICAgICAgICAgSGVscGVyIGZ1bmN0aW9uIHdoaWNoIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHVzZXIgY29kZSBsYXRlciBvbjogcHV0IHN1aXRhYmxlXG4gKiAgICAgICAgICAgICAgIHF1b3RlcyBhcm91bmQgbGl0ZXJhbCBJRHMgaW4gYSBkZXNjcmlwdGlvbiBzdHJpbmcuXG4gKlxuICogICAgb3JpZ2luYWxRdW90ZU5hbWU6IGZ1bmN0aW9uKG5hbWUpLFxuICogICAgICAgICAgICAgICBUaGUgYmFzaWMgcXVvdGVOYW1lIGhhbmRsZXIgcHJvdmlkZWQgYnkgSklTT04uXG4gKiAgICAgICAgICAgICAgIGBjbGVhbnVwQWZ0ZXJQYXJzZSgpYCB3aWxsIGNsZWFuIHVwIGFuZCByZXNldCBgcXVvdGVOYW1lKClgIHRvIHJlZmVyZW5jZSB0aGlzIGZ1bmN0aW9uXG4gKiAgICAgICAgICAgICAgIGF0IHRoZSBlbmQgb2YgdGhlIGBwYXJzZSgpYC5cbiAqXG4gKiAgICBkZXNjcmliZVN5bWJvbDogZnVuY3Rpb24oc3ltYm9sKSxcbiAqICAgICAgICAgICAgICAgUmV0dXJuIGEgbW9yZS1vci1sZXNzIGh1bWFuLXJlYWRhYmxlIGRlc2NyaXB0aW9uIG9mIHRoZSBnaXZlbiBzeW1ib2wsIHdoZW5cbiAqICAgICAgICAgICAgICAgYXZhaWxhYmxlLCBvciB0aGUgc3ltYm9sIGl0c2VsZiwgc2VydmluZyBhcyBpdHMgb3duICdkZXNjcmlwdGlvbicgZm9yIGxhY2tcbiAqICAgICAgICAgICAgICAgb2Ygc29tZXRoaW5nIGJldHRlciB0byBzZXJ2ZSB1cC5cbiAqXG4gKiAgICAgICAgICAgICAgIFJldHVybiBOVUxMIHdoZW4gdGhlIHN5bWJvbCBpcyB1bmtub3duIHRvIHRoZSBwYXJzZXIuXG4gKlxuICogICAgc3ltYm9sc186IHthc3NvY2lhdGl2ZSBsaXN0OiBuYW1lID09PiBudW1iZXJ9LFxuICogICAgdGVybWluYWxzXzoge2Fzc29jaWF0aXZlIGxpc3Q6IG51bWJlciA9PT4gbmFtZX0sXG4gKiAgICBub250ZXJtaW5hbHM6IHthc3NvY2lhdGl2ZSBsaXN0OiBydWxlLW5hbWUgPT0+IHthc3NvY2lhdGl2ZSBsaXN0OiBudW1iZXIgPT0+IHJ1bGUtYWx0fX0sXG4gKiAgICB0ZXJtaW5hbF9kZXNjcmlwdGlvbnNfOiAoaWYgdGhlcmUgYXJlIGFueSkge2Fzc29jaWF0aXZlIGxpc3Q6IG51bWJlciA9PT4gZGVzY3JpcHRpb259LFxuICogICAgcHJvZHVjdGlvbnNfOiBbLi4uXSxcbiAqXG4gKiAgICBwZXJmb3JtQWN0aW9uOiBmdW5jdGlvbiBwYXJzZXJfX3BlcmZvcm1BY3Rpb24oeXl0ZXh0LCB5eWxlbmcsIHl5bGluZW5vLCB5eWxvYywgeXlzdGF0ZSwgeXlzcCwgeXl2c3RhY2ssIHl5bHN0YWNrLCB5eXN0YWNrLCB5eXNzdGFjayksXG4gKlxuICogICAgICAgICAgICAgICBUaGUgZnVuY3Rpb24gcGFyYW1ldGVycyBhbmQgYHRoaXNgIGhhdmUgdGhlIGZvbGxvd2luZyB2YWx1ZS9tZWFuaW5nOlxuICogICAgICAgICAgICAgICAtIGB0aGlzYCAgICA6IHJlZmVyZW5jZSB0byB0aGUgYHl5dmFsYCBpbnRlcm5hbCBvYmplY3QsIHdoaWNoIGhhcyBtZW1iZXJzIChgJGAgYW5kIGBfJGApXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gc3RvcmUvcmVmZXJlbmNlIHRoZSBydWxlIHZhbHVlIGAkJGAgYW5kIGxvY2F0aW9uIGluZm8gYEAkYC5cbiAqXG4gKiAgICAgICAgICAgICAgICAgT25lIGltcG9ydGFudCB0aGluZyB0byBub3RlIGFib3V0IGB0aGlzYCBhLmsuYS4gYHl5dmFsYDogZXZlcnkgKnJlZHVjZSogYWN0aW9uIGdldHNcbiAqICAgICAgICAgICAgICAgICB0byBzZWUgdGhlIHNhbWUgb2JqZWN0IHZpYSB0aGUgYHRoaXNgIHJlZmVyZW5jZSwgaS5lLiBpZiB5b3Ugd2lzaCB0byBjYXJyeSBjdXN0b21cbiAqICAgICAgICAgICAgICAgICBkYXRhIGZyb20gb25lIHJlZHVjZSBhY3Rpb24gdGhyb3VnaCB0byB0aGUgbmV4dCB3aXRoaW4gYSBzaW5nbGUgcGFyc2UgcnVuLCB0aGVuIHlvdVxuICogICAgICAgICAgICAgICAgIG1heSBnZXQgbmFzdHkgYW5kIHVzZSBgeXl2YWxgIGEuay5hLiBgdGhpc2AgZm9yIHN0b3JpbmcgeW91IG93biBzZW1pLXBlcm1hbmVudCBkYXRhLlxuICpcbiAqICAgICAgICAgICAgICAgICBgdGhpcy55eWAgaXMgYSBkaXJlY3QgcmVmZXJlbmNlIHRvIHRoZSBgeXlgIHNoYXJlZCBzdGF0ZSBvYmplY3QuXG4gKlxuICogICAgICAgICAgICAgICAgIGAlcGFyc2UtcGFyYW1gLXNwZWNpZmllZCBhZGRpdGlvbmFsIGBwYXJzZSgpYCBhcmd1bWVudHMgaGF2ZSBiZWVuIGFkZGVkIHRvIHRoaXMgYHl5YFxuICogICAgICAgICAgICAgICAgIG9iamVjdCBhdCBgcGFyc2UoKWAgc3RhcnQgYW5kIGFyZSB0aGVyZWZvcmUgYXZhaWxhYmxlIHRvIHRoZSBhY3Rpb24gY29kZSB2aWEgdGhlXG4gKiAgICAgICAgICAgICAgICAgc2FtZSBuYW1lZCBgeXkueHh4eGAgYXR0cmlidXRlcyAod2hlcmUgYHh4eHhgIHJlcHJlc2VudHMgYSBpZGVudGlmaWVyIG5hbWUgZnJvbVxuICogICAgICAgICAgICAgICAgIHRoZSAlcGFyc2UtcGFyYW1gIGxpc3QuXG4gKlxuICogICAgICAgICAgICAgICAtIGB5eXRleHRgICA6IHJlZmVyZW5jZSB0byB0aGUgbGV4ZXIgdmFsdWUgd2hpY2ggYmVsb25ncyB0byB0aGUgbGFzdCBsZXhlciB0b2tlbiB1c2VkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gbWF0Y2ggdGhpcyBydWxlLiBUaGlzIGlzICpub3QqIHRoZSBsb29rLWFoZWFkIHRva2VuLCBidXQgdGhlIGxhc3QgdG9rZW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0J3MgYWN0dWFsbHkgcGFydCBvZiB0aGlzIHJ1bGUuXG4gKlxuICogICAgICAgICAgICAgICAgIEZvcm11bGF0ZWQgYW5vdGhlciB3YXksIGB5eXRleHRgIGlzIHRoZSB2YWx1ZSBvZiB0aGUgdG9rZW4gaW1tZWRpYXRlbHkgcHJlY2VlZGluZ1xuICogICAgICAgICAgICAgICAgIHRoZSBjdXJyZW50IGxvb2stYWhlYWQgdG9rZW4uXG4gKiAgICAgICAgICAgICAgICAgQ2F2ZWF0cyBhcHBseSBmb3IgcnVsZXMgd2hpY2ggZG9uJ3QgcmVxdWlyZSBsb29rLWFoZWFkLCBzdWNoIGFzIGVwc2lsb24gcnVsZXMuXG4gKlxuICogICAgICAgICAgICAgICAtIGB5eWxlbmdgICA6IGRpdHRvIGFzIGB5eXRleHRgLCBvbmx5IG5vdyBmb3IgdGhlIGxleGVyLnl5bGVuZyB2YWx1ZS5cbiAqXG4gKiAgICAgICAgICAgICAgIC0gYHl5bGluZW5vYDogZGl0dG8gYXMgYHl5dGV4dGAsIG9ubHkgbm93IGZvciB0aGUgbGV4ZXIueXlsaW5lbm8gdmFsdWUuXG4gKlxuICogICAgICAgICAgICAgICAtIGB5eWxvY2AgICA6IGRpdHRvIGFzIGB5eXRleHRgLCBvbmx5IG5vdyBmb3IgdGhlIGxleGVyLnl5bGxvYyBsZXhlciB0b2tlbiBsb2NhdGlvbiBpbmZvLlxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFdBUk5JTkc6IHNpbmNlIGppc29uIDAuNC4xOC0xODYgdGhpcyBlbnRyeSBtYXkgYmUgTlVMTC9VTkRFRklORUQgaW5zdGVhZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgYW4gZW1wdHkgb2JqZWN0IHdoZW4gbm8gc3VpdGFibGUgbG9jYXRpb24gaW5mbyBjYW4gYmUgcHJvdmlkZWQuXG4gKlxuICogICAgICAgICAgICAgICAtIGB5eXN0YXRlYCA6IHRoZSBjdXJyZW50IHBhcnNlciBzdGF0ZSBudW1iZXIsIHVzZWQgaW50ZXJuYWxseSBmb3IgZGlzcGF0Y2hpbmcgYW5kXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRpbmcgdGhlIGFjdGlvbiBjb2RlIGNodW5rIG1hdGNoaW5nIHRoZSBydWxlIGN1cnJlbnRseSBiZWluZyByZWR1Y2VkLlxuICpcbiAqICAgICAgICAgICAgICAgLSBgeXlzcGAgICAgOiB0aGUgY3VycmVudCBzdGF0ZSBzdGFjayBwb3NpdGlvbiAoYS5rLmEuICdzdGFjayBwb2ludGVyJylcbiAqXG4gKiAgICAgICAgICAgICAgICAgVGhpcyBvbmUgY29tZXMgaW4gaGFuZHkgd2hlbiB5b3UgYXJlIGdvaW5nIHRvIGRvIGFkdmFuY2VkIHRoaW5ncyB0byB0aGUgcGFyc2VyXG4gKiAgICAgICAgICAgICAgICAgc3RhY2tzLCBhbGwgb2Ygd2hpY2ggYXJlIGFjY2Vzc2libGUgZnJvbSB5b3VyIGFjdGlvbiBjb2RlIChzZWUgdGhlIG5leHQgZW50cmllcyBiZWxvdykuXG4gKlxuICogICAgICAgICAgICAgICAgIEFsc28gbm90ZSB0aGF0IHlvdSBjYW4gYWNjZXNzIHRoaXMgYW5kIG90aGVyIHN0YWNrIGluZGV4IHZhbHVlcyB1c2luZyB0aGUgbmV3IGRvdWJsZS1oYXNoXG4gKiAgICAgICAgICAgICAgICAgc3ludGF4LCBpLmUuIGAjIyQgPT09ICMjMCA9PT0geXlzcGAsIHdoaWxlIGAjIzFgIGlzIHRoZSBzdGFjayBpbmRleCBmb3IgYWxsIHRoaW5nc1xuICogICAgICAgICAgICAgICAgIHJlbGF0ZWQgdG8gdGhlIGZpcnN0IHJ1bGUgdGVybSwganVzdCBsaWtlIHlvdSBoYXZlIGAkMWAsIGBAMWAgYW5kIGAjMWAuXG4gKiAgICAgICAgICAgICAgICAgVGhpcyBpcyBtYWRlIGF2YWlsYWJsZSB0byB3cml0ZSB2ZXJ5IGFkdmFuY2VkIGdyYW1tYXIgYWN0aW9uIHJ1bGVzLCBlLmcuIHdoZW4geW91IHdhbnRcbiAqICAgICAgICAgICAgICAgICB0byBpbnZlc3RpZ2F0ZSB0aGUgcGFyc2Ugc3RhdGUgc3RhY2sgaW4geW91ciBhY3Rpb24gY29kZSwgd2hpY2ggd291bGQsIGZvciBleGFtcGxlLFxuICogICAgICAgICAgICAgICAgIGJlIHJlbGV2YW50IHdoZW4geW91IHdpc2ggdG8gaW1wbGVtZW50IGVycm9yIGRpYWdub3N0aWNzIGFuZCByZXBvcnRpbmcgc2NoZW1lcyBzaW1pbGFyXG4gKiAgICAgICAgICAgICAgICAgdG8gdGhlIHdvcmsgZGVzY3JpYmVkIGhlcmU6XG4gKlxuICogICAgICAgICAgICAgICAgICsgUG90dGllciwgRi4sIDIwMTYuIFJlYWNoYWJpbGl0eSBhbmQgZXJyb3IgZGlhZ25vc2lzIGluIExSKDEpIGF1dG9tYXRhLlxuICogICAgICAgICAgICAgICAgICAgSW4gSm91cm7DqWVzIEZyYW5jb3Bob25lcyBkZXMgTGFuZ3VhZ2VzIEFwcGxpY2F0aWZzLlxuICpcbiAqICAgICAgICAgICAgICAgICArIEplZmZlcnksIEMuTC4sIDIwMDMuIEdlbmVyYXRpbmcgTFIgc3ludGF4IGVycm9yIG1lc3NhZ2VzIGZyb20gZXhhbXBsZXMuXG4gKiAgICAgICAgICAgICAgICAgICBBQ00gVHJhbnNhY3Rpb25zIG9uIFByb2dyYW1taW5nIExhbmd1YWdlcyBhbmQgU3lzdGVtcyAoVE9QTEFTKSwgMjUoNSksIHBwLjYzMeKAkzY0MC5cbiAqXG4gKiAgICAgICAgICAgICAgIC0gYHl5cnVsZWxlbmd0aGA6IHRoZSBjdXJyZW50IHJ1bGUncyB0ZXJtIGNvdW50LCBpLmUuIHRoZSBudW1iZXIgb2YgZW50cmllcyBvY2N1cGllZCBvbiB0aGUgc3RhY2suXG4gKlxuICogICAgICAgICAgICAgICAgIFRoaXMgb25lIGNvbWVzIGluIGhhbmR5IHdoZW4geW91IGFyZSBnb2luZyB0byBkbyBhZHZhbmNlZCB0aGluZ3MgdG8gdGhlIHBhcnNlclxuICogICAgICAgICAgICAgICAgIHN0YWNrcywgYWxsIG9mIHdoaWNoIGFyZSBhY2Nlc3NpYmxlIGZyb20geW91ciBhY3Rpb24gY29kZSAoc2VlIHRoZSBuZXh0IGVudHJpZXMgYmVsb3cpLlxuICpcbiAqICAgICAgICAgICAgICAgLSBgeXl2c3RhY2tgOiByZWZlcmVuY2UgdG8gdGhlIHBhcnNlciB2YWx1ZSBzdGFjay4gQWxzbyBhY2Nlc3NlZCB2aWEgdGhlIGAkMWAgZXRjLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdHMuXG4gKlxuICogICAgICAgICAgICAgICAtIGB5eWxzdGFja2A6IHJlZmVyZW5jZSB0byB0aGUgcGFyc2VyIHRva2VuIGxvY2F0aW9uIHN0YWNrLiBBbHNvIGFjY2Vzc2VkIHZpYVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBgQDFgIGV0Yy4gY29uc3RydWN0cy5cbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgV0FSTklORzogc2luY2Ugamlzb24gMC40LjE4LTE4NiB0aGlzIGFycmF5IE1BWSBjb250YWluIHNsb3RzIHdoaWNoIGFyZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIFVOREVGSU5FRCByYXRoZXIgdGhhbiBhbiBlbXB0eSAobG9jYXRpb24pIG9iamVjdCwgd2hlbiB0aGUgbGV4ZXIvcGFyc2VyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uIGNvZGUgZGlkIG5vdCBwcm92aWRlIGEgc3VpdGFibGUgbG9jYXRpb24gaW5mbyBvYmplY3Qgd2hlbiBzdWNoIGFcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbG90IHdhcyBmaWxsZWQhXG4gKlxuICogICAgICAgICAgICAgICAtIGB5eXN0YWNrYCA6IHJlZmVyZW5jZSB0byB0aGUgcGFyc2VyIHRva2VuIGlkIHN0YWNrLiBBbHNvIGFjY2Vzc2VkIHZpYSB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgIzFgIGV0Yy4gY29uc3RydWN0cy5cbiAqXG4gKiAgICAgICAgICAgICAgICAgTm90ZTogdGhpcyBpcyBhIGJpdCBvZiBhICoqd2hpdGUgbGllKiogYXMgd2UgY2FuIHN0YXRpY2FsbHkgZGVjb2RlIGFueSBgI25gIHJlZmVyZW5jZSB0b1xuICogICAgICAgICAgICAgICAgIGl0cyBudW1lcmljIHRva2VuIGlkIHZhbHVlLCBoZW5jZSB0aGF0IGNvZGUgd291bGRuJ3QgbmVlZCB0aGUgYHl5c3RhY2tgIGJ1dCAqeW91KiBtaWdodFxuICogICAgICAgICAgICAgICAgIHdhbnQgYWNjZXNzIHRoaXMgYXJyYXkgZm9yIHlvdXIgb3duIHB1cnBvc2VzLCBzdWNoIGFzIGVycm9yIGFuYWx5c2lzIGFzIG1lbnRpb25lZCBhYm92ZSFcbiAqXG4gKiAgICAgICAgICAgICAgICAgTm90ZSB0aGF0IHRoaXMgc3RhY2sgc3RvcmVzIHRoZSBjdXJyZW50IHN0YWNrIG9mICp0b2tlbnMqLCB0aGF0IGlzIHRoZSBzZXF1ZW5jZSBvZlxuICogICAgICAgICAgICAgICAgIGFscmVhZHkgcGFyc2VkPXJlZHVjZWQgKm5vbnRlcm1pbmFscyogKHRva2VucyByZXByZXNlbnRpbmcgcnVsZXMpIGFuZCAqdGVybWluYWxzKlxuICogICAgICAgICAgICAgICAgIChsZXhlciB0b2tlbnMgKnNoaWZ0ZWQqIG9udG8gdGhlIHN0YWNrIHVudGlsIHRoZSBydWxlIHRoZXkgYmVsb25nIHRvIGlzIGZvdW5kIGFuZFxuICogICAgICAgICAgICAgICAgICpyZWR1Y2VkKi5cbiAqXG4gKiAgICAgICAgICAgICAgIC0gYHl5c3N0YWNrYDogcmVmZXJlbmNlIHRvIHRoZSBwYXJzZXIgc3RhdGUgc3RhY2suIFRoaXMgb25lIGNhcnJpZXMgdGhlIGludGVybmFsIHBhcnNlclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICpzdGF0ZXMqIHN1Y2ggYXMgdGhlIG9uZSBpbiBgeXlzdGF0ZWAsIHdoaWNoIGFyZSB1c2VkIHRvIHJlcHJlc2VudFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBwYXJzZXIgc3RhdGUgbWFjaGluZSBpbiB0aGUgKnBhcnNlIHRhYmxlKi4gKlZlcnkqICppbnRlcm5hbCogc3R1ZmYsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hhdCBjYW4gSSBzYXk/IElmIHlvdSBhY2Nlc3MgdGhpcyBvbmUsIHlvdSdyZSBjbGVhcmx5IGRvaW5nIHdpY2tlZCB0aGluZ3NcbiAqXG4gKiAgICAgICAgICAgICAgIC0gYC4uLmAgICAgIDogdGhlIGV4dHJhIGFyZ3VtZW50cyB5b3Ugc3BlY2lmaWVkIGluIHRoZSBgJXBhcnNlLXBhcmFtYCBzdGF0ZW1lbnQgaW4geW91clxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyYW1tYXIgZGVmaW5pdGlvbiBmaWxlLlxuICpcbiAqICAgIHRhYmxlOiBbLi4uXSxcbiAqICAgICAgICAgICAgICAgU3RhdGUgdHJhbnNpdGlvbiB0YWJsZVxuICogICAgICAgICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKlxuICogICAgICAgICAgICAgICBpbmRleCBsZXZlbHMgYXJlOlxuICogICAgICAgICAgICAgICAtIGBzdGF0ZWAgIC0tPiBoYXNoIHRhYmxlXG4gKiAgICAgICAgICAgICAgIC0gYHN5bWJvbGAgLS0+IGFjdGlvbiAobnVtYmVyIG9yIGFycmF5KVxuICpcbiAqICAgICAgICAgICAgICAgICBJZiB0aGUgYGFjdGlvbmAgaXMgYW4gYXJyYXksIHRoZXNlIGFyZSB0aGUgZWxlbWVudHMnIG1lYW5pbmc6XG4gKiAgICAgICAgICAgICAgICAgLSBpbmRleCBbMF06IDEgPSBzaGlmdCwgMiA9IHJlZHVjZSwgMyA9IGFjY2VwdFxuICogICAgICAgICAgICAgICAgIC0gaW5kZXggWzFdOiBHT1RPIGBzdGF0ZWBcbiAqXG4gKiAgICAgICAgICAgICAgICAgSWYgdGhlIGBhY3Rpb25gIGlzIGEgbnVtYmVyLCBpdCBpcyB0aGUgR09UTyBgc3RhdGVgXG4gKlxuICogICAgZGVmYXVsdEFjdGlvbnM6IHsuLi59LFxuICpcbiAqICAgIHBhcnNlRXJyb3I6IGZ1bmN0aW9uKHN0ciwgaGFzaCwgRXhjZXB0aW9uQ2xhc3MpLFxuICogICAgeXlFcnJvcjogZnVuY3Rpb24oc3RyLCAuLi4pLFxuICogICAgeXlSZWNvdmVyaW5nOiBmdW5jdGlvbigpLFxuICogICAgeXlFcnJPazogZnVuY3Rpb24oKSxcbiAqICAgIHl5Q2xlYXJJbjogZnVuY3Rpb24oKSxcbiAqXG4gKiAgICBjb25zdHJ1Y3RQYXJzZUVycm9ySW5mbzogZnVuY3Rpb24oZXJyb3JfbWVzc2FnZSwgZXhjZXB0aW9uX29iamVjdCwgZXhwZWN0ZWRfdG9rZW5fc2V0LCBpc19yZWNvdmVyYWJsZSksXG4gKiAgICAgICAgICAgICAgIEhlbHBlciBmdW5jdGlvbiAqKndoaWNoIHdpbGwgYmUgc2V0IHVwIGR1cmluZyB0aGUgZmlyc3QgaW52b2NhdGlvbiBvZiB0aGUgYHBhcnNlKClgIG1ldGhvZCoqLlxuICogICAgICAgICAgICAgICBQcm9kdWNlcyBhIG5ldyBlcnJvckluZm8gJ2hhc2ggb2JqZWN0JyB3aGljaCBjYW4gYmUgcGFzc2VkIGludG8gYHBhcnNlRXJyb3IoKWAuXG4gKiAgICAgICAgICAgICAgIFNlZSBpdCdzIHVzZSBpbiB0aGlzIHBhcnNlciBrZXJuZWwgaW4gbWFueSBwbGFjZXM7IGV4YW1wbGUgdXNhZ2U6XG4gKlxuICogICAgICAgICAgICAgICAgICAgdmFyIGluZm9PYmogPSBwYXJzZXIuY29uc3RydWN0UGFyc2VFcnJvckluZm8oJ2ZhaWwhJywgbnVsbCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5jb2xsZWN0X2V4cGVjdGVkX3Rva2VuX3NldChzdGF0ZSksIHRydWUpO1xuICogICAgICAgICAgICAgICAgICAgdmFyIHJldFZhbCA9IHBhcnNlci5wYXJzZUVycm9yKGluZm9PYmouZXJyU3RyLCBpbmZvT2JqLCBwYXJzZXIuSmlzb25QYXJzZXJFcnJvcik7XG4gKlxuICogICAgb3JpZ2luYWxQYXJzZUVycm9yOiBmdW5jdGlvbihzdHIsIGhhc2gsIEV4Y2VwdGlvbkNsYXNzKSxcbiAqICAgICAgICAgICAgICAgVGhlIGJhc2ljIGBwYXJzZUVycm9yYCBoYW5kbGVyIHByb3ZpZGVkIGJ5IEpJU09OLlxuICogICAgICAgICAgICAgICBgY2xlYW51cEFmdGVyUGFyc2UoKWAgd2lsbCBjbGVhbiB1cCBhbmQgcmVzZXQgYHBhcnNlRXJyb3IoKWAgdG8gcmVmZXJlbmNlIHRoaXMgZnVuY3Rpb25cbiAqICAgICAgICAgICAgICAgYXQgdGhlIGVuZCBvZiB0aGUgYHBhcnNlKClgLlxuICpcbiAqICAgIG9wdGlvbnM6IHsgLi4uIHBhcnNlciAlb3B0aW9ucyAuLi4gfSxcbiAqXG4gKiAgICBwYXJzZTogZnVuY3Rpb24oaW5wdXRbLCBhcmdzLi4uXSksXG4gKiAgICAgICAgICAgICAgIFBhcnNlIHRoZSBnaXZlbiBgaW5wdXRgIGFuZCByZXR1cm4gdGhlIHBhcnNlZCB2YWx1ZSAob3IgYHRydWVgIHdoZW4gbm9uZSB3YXMgcHJvdmlkZWQgYnlcbiAqICAgICAgICAgICAgICAgdGhlIHJvb3QgYWN0aW9uLCBpbiB3aGljaCBjYXNlIHRoZSBwYXJzZXIgaXMgYWN0aW5nIGFzIGEgKm1hdGNoZXIqKS5cbiAqICAgICAgICAgICAgICAgWW91IE1BWSB1c2UgdGhlIGFkZGl0aW9uYWwgYGFyZ3MuLi5gIHBhcmFtZXRlcnMgYXMgcGVyIGAlcGFyc2UtcGFyYW1gIHNwZWMgb2YgdGhpcyBncmFtbWFyOlxuICogICAgICAgICAgICAgICB0aGVzZSBleHRyYSBgYXJncy4uLmAgYXJlIGFkZGVkIHZlcmJhdGltIHRvIHRoZSBgeXlgIG9iamVjdCByZWZlcmVuY2UgYXMgbWVtYmVyIHZhcmlhYmxlcy5cbiAqXG4gKiAgICAgICAgICAgICAgIFdBUk5JTkc6XG4gKiAgICAgICAgICAgICAgIFBhcnNlcidzIGFkZGl0aW9uYWwgYGFyZ3MuLi5gIHBhcmFtZXRlcnMgKHZpYSBgJXBhcnNlLXBhcmFtYCkgTUFZIGNvbmZsaWN0IHdpdGhcbiAqICAgICAgICAgICAgICAgYW55IGF0dHJpYnV0ZXMgYWxyZWFkeSBhZGRlZCB0byBgeXlgIGJ5IHRoZSBqaXNvbiBydW4tdGltZTtcbiAqICAgICAgICAgICAgICAgd2hlbiBzdWNoIGEgY29sbGlzaW9uIGlzIGRldGVjdGVkIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gdG8gcHJldmVudCB0aGUgZ2VuZXJhdGVkIHJ1bi10aW1lXG4gKiAgICAgICAgICAgICAgIGZyb20gc2lsZW50bHkgYWNjZXB0aW5nIHRoaXMgY29uZnVzaW5nIGFuZCBwb3RlbnRpYWxseSBoYXphcmRvdXMgc2l0dWF0aW9uIVxuICpcbiAqICAgICAgICAgICAgICAgVGhlIGxleGVyIE1BWSBhZGQgaXRzIG93biBzZXQgb2YgYWRkaXRpb25hbCBwYXJhbWV0ZXJzICh2aWEgdGhlIGAlcGFyc2UtcGFyYW1gIGxpbmUgaW5cbiAqICAgICAgICAgICAgICAgdGhlIGxleGVyIHNlY3Rpb24gb2YgdGhlIGdyYW1tYXIgc3BlYyk6IHRoZXNlIHdpbGwgYmUgaW5zZXJ0ZWQgaW4gdGhlIGB5eWAgc2hhcmVkIHN0YXRlXG4gKiAgICAgICAgICAgICAgIG9iamVjdCBhbmQgYW55IGNvbGxpc2lvbiB3aXRoIHRob3NlIHdpbGwgYmUgcmVwb3J0ZWQgYnkgdGhlIGxleGVyIHZpYSBhIHRocm93biBleGNlcHRpb24uXG4gKlxuICogICAgY2xlYW51cEFmdGVyUGFyc2U6IGZ1bmN0aW9uKHJlc3VsdFZhbHVlLCBpbnZva2VfcG9zdF9tZXRob2RzLCBkb19ub3RfbnVrZV9lcnJvcmluZm9zKSxcbiAqICAgICAgICAgICAgICAgSGVscGVyIGZ1bmN0aW9uICoqd2hpY2ggd2lsbCBiZSBzZXQgdXAgZHVyaW5nIHRoZSBmaXJzdCBpbnZvY2F0aW9uIG9mIHRoZSBgcGFyc2UoKWAgbWV0aG9kKiouXG4gKiAgICAgICAgICAgICAgIFRoaXMgaGVscGVyIEFQSSBpcyBpbnZva2VkIGF0IHRoZSBlbmQgb2YgdGhlIGBwYXJzZSgpYCBjYWxsLCB1bmxlc3MgYW4gZXhjZXB0aW9uIHdhcyB0aHJvd25cbiAqICAgICAgICAgICAgICAgYW5kIGAlb3B0aW9ucyBuby10cnktY2F0Y2hgIGhhcyBiZWVuIGRlZmluZWQgZm9yIHRoaXMgZ3JhbW1hcjogaW4gdGhhdCBjYXNlIHRoaXMgaGVscGVyIE1BWVxuICogICAgICAgICAgICAgICBiZSBpbnZva2VkIGJ5IGNhbGxpbmcgdXNlciBjb2RlIHRvIGVuc3VyZSB0aGUgYHBvc3RfcGFyc2VgIGNhbGxiYWNrcyBhcmUgaW52b2tlZCBhbmRcbiAqICAgICAgICAgICAgICAgdGhlIGludGVybmFsIHBhcnNlciBnZXRzIHByb3Blcmx5IGdhcmJhZ2UgY29sbGVjdGVkIHVuZGVyIHRoZXNlIHBhcnRpY3VsYXIgY2lyY3Vtc3RhbmNlcy5cbiAqXG4gKiAgICB5eU1lcmdlTG9jYXRpb25JbmZvOiBmdW5jdGlvbihmaXJzdF9pbmRleCwgbGFzdF9pbmRleCwgZmlyc3RfeXlsbG9jLCBsYXN0X3l5bGxvYywgZG9udF9sb29rX2JhY2spLFxuICogICAgICAgICAgICAgICBIZWxwZXIgZnVuY3Rpb24gKip3aGljaCB3aWxsIGJlIHNldCB1cCBkdXJpbmcgdGhlIGZpcnN0IGludm9jYXRpb24gb2YgdGhlIGBwYXJzZSgpYCBtZXRob2QqKi5cbiAqICAgICAgICAgICAgICAgVGhpcyBoZWxwZXIgQVBJIGNhbiBiZSBpbnZva2VkIHRvIGNhbGN1bGF0ZSBhIHNwYW5uaW5nIGB5eWxsb2NgIGxvY2F0aW9uIGluZm8gb2JqZWN0LlxuICpcbiAqICAgICAgICAgICAgICAgTm90ZTogJWVwc2lsb24gcnVsZXMgTUFZIHNwZWNpZnkgbm8gYGZpcnN0X2luZGV4YCBhbmQgYGZpcnN0X3l5bGxvY2AsIGluIHdoaWNoIGNhc2VcbiAqICAgICAgICAgICAgICAgdGhpcyBmdW5jdGlvbiB3aWxsIGF0dGVtcHQgdG8gb2J0YWluIGEgc3VpdGFibGUgbG9jYXRpb24gbWFya2VyIGJ5IGluc3BlY3RpbmcgdGhlIGxvY2F0aW9uIHN0YWNrXG4gKiAgICAgICAgICAgICAgIGJhY2t3YXJkcy5cbiAqXG4gKiAgICAgICAgICAgICAgIEZvciBtb3JlIGluZm8gc2VlIHRoZSBkb2N1bWVudGF0aW9uIGNvbW1lbnQgZnVydGhlciBiZWxvdywgaW1tZWRpYXRlbHkgYWJvdmUgdGhpcyBmdW5jdGlvbidzXG4gKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uLlxuICpcbiAqICAgIGxleGVyOiB7XG4gKiAgICAgICAgeXk6IHsuLi59LCAgICAgICAgICAgQSByZWZlcmVuY2UgdG8gdGhlIHNvLWNhbGxlZCBcInNoYXJlZCBzdGF0ZVwiIGB5eWAgb25jZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmVkIHZpYSBhIGNhbGwgdG8gdGhlIGAuc2V0SW5wdXQoaW5wdXQsIHl5KWAgbGV4ZXIgQVBJLlxuICogICAgICAgIEVPRjogMSxcbiAqICAgICAgICBFUlJPUjogMixcbiAqICAgICAgICBKaXNvbkxleGVyRXJyb3I6IGZ1bmN0aW9uKG1zZywgaGFzaCksXG4gKiAgICAgICAgcGFyc2VFcnJvcjogZnVuY3Rpb24oc3RyLCBoYXNoLCBFeGNlcHRpb25DbGFzcyksXG4gKiAgICAgICAgc2V0SW5wdXQ6IGZ1bmN0aW9uKGlucHV0LCBbeXldKSxcbiAqICAgICAgICBpbnB1dDogZnVuY3Rpb24oKSxcbiAqICAgICAgICB1bnB1dDogZnVuY3Rpb24oc3RyKSxcbiAqICAgICAgICBtb3JlOiBmdW5jdGlvbigpLFxuICogICAgICAgIHJlamVjdDogZnVuY3Rpb24oKSxcbiAqICAgICAgICBsZXNzOiBmdW5jdGlvbihuKSxcbiAqICAgICAgICBwYXN0SW5wdXQ6IGZ1bmN0aW9uKG4pLFxuICogICAgICAgIHVwY29taW5nSW5wdXQ6IGZ1bmN0aW9uKG4pLFxuICogICAgICAgIHNob3dQb3NpdGlvbjogZnVuY3Rpb24oKSxcbiAqICAgICAgICB0ZXN0X21hdGNoOiBmdW5jdGlvbihyZWdleF9tYXRjaF9hcnJheSwgcnVsZV9pbmRleCwgLi4uKSxcbiAqICAgICAgICBuZXh0OiBmdW5jdGlvbiguLi4pLFxuICogICAgICAgIGxleDogZnVuY3Rpb24oLi4uKSxcbiAqICAgICAgICBiZWdpbjogZnVuY3Rpb24oY29uZGl0aW9uKSxcbiAqICAgICAgICBwdXNoU3RhdGU6IGZ1bmN0aW9uKGNvbmRpdGlvbiksXG4gKiAgICAgICAgcG9wU3RhdGU6IGZ1bmN0aW9uKCksXG4gKiAgICAgICAgdG9wU3RhdGU6IGZ1bmN0aW9uKCksXG4gKiAgICAgICAgX2N1cnJlbnRSdWxlczogZnVuY3Rpb24oKSxcbiAqICAgICAgICBzdGF0ZVN0YWNrU2l6ZTogZnVuY3Rpb24oKSxcbiAqICAgICAgICBjbGVhbnVwQWZ0ZXJMZXg6IGZ1bmN0aW9uKClcbiAqXG4gKiAgICAgICAgb3B0aW9uczogeyAuLi4gbGV4ZXIgJW9wdGlvbnMgLi4uIH0sXG4gKlxuICogICAgICAgIHBlcmZvcm1BY3Rpb246IGZ1bmN0aW9uKHl5LCB5eV8sICRhdm9pZGluZ19uYW1lX2NvbGxpc2lvbnMsIFlZX1NUQVJULCAuLi4pLFxuICogICAgICAgIHJ1bGVzOiBbLi4uXSxcbiAqICAgICAgICBjb25kaXRpb25zOiB7YXNzb2NpYXRpdmUgbGlzdDogbmFtZSA9PT4gc2V0fSxcbiAqICAgIH1cbiAqICB9XG4gKlxuICpcbiAqICB0b2tlbiBsb2NhdGlvbiBpbmZvIChAJCwgXyQsIGV0Yy4pOiB7XG4gKiAgICBmaXJzdF9saW5lOiBuLFxuICogICAgbGFzdF9saW5lOiBuLFxuICogICAgZmlyc3RfY29sdW1uOiBuLFxuICogICAgbGFzdF9jb2x1bW46IG4sXG4gKiAgICByYW5nZTogW3N0YXJ0X251bWJlciwgZW5kX251bWJlcl1cbiAqICAgICAgICAgICAgICAgKHdoZXJlIHRoZSBudW1iZXJzIGFyZSBpbmRleGVzIGludG8gdGhlIGlucHV0IHN0cmluZywgemVyby1iYXNlZClcbiAqICB9XG4gKlxuICogLS0tXG4gKlxuICogVGhlIGBwYXJzZUVycm9yYCBmdW5jdGlvbiByZWNlaXZlcyBhICdoYXNoJyBvYmplY3Qgd2l0aCB0aGVzZSBtZW1iZXJzIGZvciBsZXhlciBhbmRcbiAqIHBhcnNlciBlcnJvcnM6XG4gKlxuICogIHtcbiAqICAgIHRleHQ6ICAgICAgICAobWF0Y2hlZCB0ZXh0KVxuICogICAgdG9rZW46ICAgICAgICh0aGUgcHJvZHVjZWQgdGVybWluYWwgdG9rZW4sIGlmIGFueSlcbiAqICAgIHRva2VuX2lkOiAgICAodGhlIHByb2R1Y2VkIHRlcm1pbmFsIHRva2VuIG51bWVyaWMgSUQsIGlmIGFueSlcbiAqICAgIGxpbmU6ICAgICAgICAoeXlsaW5lbm8pXG4gKiAgICBsb2M6ICAgICAgICAgKHl5bGxvYylcbiAqICB9XG4gKlxuICogcGFyc2VyIChncmFtbWFyKSBlcnJvcnMgd2lsbCBhbHNvIHByb3ZpZGUgdGhlc2UgYWRkaXRpb25hbCBtZW1iZXJzOlxuICpcbiAqICB7XG4gKiAgICBleHBlY3RlZDogICAgKGFycmF5IGRlc2NyaWJpbmcgdGhlIHNldCBvZiBleHBlY3RlZCB0b2tlbnM7XG4gKiAgICAgICAgICAgICAgICAgIG1heSBiZSBVTkRFRklORUQgd2hlbiB3ZSBjYW5ub3QgZWFzaWx5IHByb2R1Y2Ugc3VjaCBhIHNldClcbiAqICAgIHN0YXRlOiAgICAgICAoaW50ZWdlciAob3IgYXJyYXkgd2hlbiB0aGUgdGFibGUgaW5jbHVkZXMgZ3JhbW1hciBjb2xsaXNpb25zKTtcbiAqICAgICAgICAgICAgICAgICAgcmVwcmVzZW50cyB0aGUgY3VycmVudCBpbnRlcm5hbCBzdGF0ZSBvZiB0aGUgcGFyc2VyIGtlcm5lbC5cbiAqICAgICAgICAgICAgICAgICAgY2FuLCBmb3IgZXhhbXBsZSwgYmUgdXNlZCB0byBwYXNzIHRvIHRoZSBgY29sbGVjdF9leHBlY3RlZF90b2tlbl9zZXQoKWBcbiAqICAgICAgICAgICAgICAgICAgQVBJIHRvIG9idGFpbiB0aGUgZXhwZWN0ZWQgdG9rZW4gc2V0KVxuICogICAgYWN0aW9uOiAgICAgIChpbnRlZ2VyOyByZXByZXNlbnRzIHRoZSBjdXJyZW50IGludGVybmFsIGFjdGlvbiB3aGljaCB3aWxsIGJlIGV4ZWN1dGVkKVxuICogICAgbmV3X3N0YXRlOiAgIChpbnRlZ2VyOyByZXByZXNlbnRzIHRoZSBuZXh0L3BsYW5uZWQgaW50ZXJuYWwgc3RhdGUsIG9uY2UgdGhlIGN1cnJlbnRcbiAqICAgICAgICAgICAgICAgICAgYWN0aW9uIGhhcyBleGVjdXRlZClcbiAqICAgIHJlY292ZXJhYmxlOiAoYm9vbGVhbjogVFJVRSB3aGVuIHRoZSBwYXJzZXIgTUFZIGhhdmUgYW4gZXJyb3IgcmVjb3ZlcnkgcnVsZVxuICogICAgICAgICAgICAgICAgICBhdmFpbGFibGUgZm9yIHRoaXMgcGFydGljdWxhciBlcnJvcilcbiAqICAgIHN0YXRlX3N0YWNrOiAoYXJyYXk6IHRoZSBjdXJyZW50IHBhcnNlciBMQUxSL0xSIGludGVybmFsIHN0YXRlIHN0YWNrOyB0aGlzIGNhbiBiZSB1c2VkLFxuICogICAgICAgICAgICAgICAgICBmb3IgaW5zdGFuY2UsIGZvciBhZHZhbmNlZCBlcnJvciBhbmFseXNpcyBhbmQgcmVwb3J0aW5nKVxuICogICAgdmFsdWVfc3RhY2s6IChhcnJheTogdGhlIGN1cnJlbnQgcGFyc2VyIExBTFIvTFIgaW50ZXJuYWwgYCQkYCB2YWx1ZSBzdGFjazsgdGhpcyBjYW4gYmUgdXNlZCxcbiAqICAgICAgICAgICAgICAgICAgZm9yIGluc3RhbmNlLCBmb3IgYWR2YW5jZWQgZXJyb3IgYW5hbHlzaXMgYW5kIHJlcG9ydGluZylcbiAqICAgIGxvY2F0aW9uX3N0YWNrOiAoYXJyYXk6IHRoZSBjdXJyZW50IHBhcnNlciBMQUxSL0xSIGludGVybmFsIGxvY2F0aW9uIHN0YWNrOyB0aGlzIGNhbiBiZSB1c2VkLFxuICogICAgICAgICAgICAgICAgICBmb3IgaW5zdGFuY2UsIGZvciBhZHZhbmNlZCBlcnJvciBhbmFseXNpcyBhbmQgcmVwb3J0aW5nKVxuICogICAgeXk6ICAgICAgICAgIChvYmplY3Q6IHRoZSBjdXJyZW50IHBhcnNlciBpbnRlcm5hbCBcInNoYXJlZCBzdGF0ZVwiIGB5eWBcbiAqICAgICAgICAgICAgICAgICAgYXMgaXMgYWxzbyBhdmFpbGFibGUgaW4gdGhlIHJ1bGUgYWN0aW9uczsgdGhpcyBjYW4gYmUgdXNlZCxcbiAqICAgICAgICAgICAgICAgICAgZm9yIGluc3RhbmNlLCBmb3IgYWR2YW5jZWQgZXJyb3IgYW5hbHlzaXMgYW5kIHJlcG9ydGluZylcbiAqICAgIGxleGVyOiAgICAgICAocmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGxleGVyIGluc3RhbmNlIHVzZWQgYnkgdGhlIHBhcnNlcilcbiAqICAgIHBhcnNlcjogICAgICAocmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IHBhcnNlciBpbnN0YW5jZSlcbiAqICB9XG4gKlxuICogd2hpbGUgYHRoaXNgIHdpbGwgcmVmZXJlbmNlIHRoZSBjdXJyZW50IHBhcnNlciBpbnN0YW5jZS5cbiAqXG4gKiBXaGVuIGBwYXJzZUVycm9yYCBpcyBpbnZva2VkIGJ5IHRoZSBsZXhlciwgYHRoaXNgIHdpbGwgc3RpbGwgcmVmZXJlbmNlIHRoZSByZWxhdGVkICpwYXJzZXIqXG4gKiBpbnN0YW5jZSwgd2hpbGUgdGhlc2UgYWRkaXRpb25hbCBgaGFzaGAgZmllbGRzIHdpbGwgYWxzbyBiZSBwcm92aWRlZDpcbiAqXG4gKiAge1xuICogICAgbGV4ZXI6ICAgICAgIChyZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgbGV4ZXIgaW5zdGFuY2Ugd2hpY2ggcmVwb3J0ZWQgdGhlIGVycm9yKVxuICogIH1cbiAqXG4gKiBXaGVuIGBwYXJzZUVycm9yYCBpcyBpbnZva2VkIGJ5IHRoZSBwYXJzZXIgZHVlIHRvIGEgKipKYXZhU2NyaXB0IGV4Y2VwdGlvbioqIGJlaW5nIGZpcmVkXG4gKiBmcm9tIGVpdGhlciB0aGUgcGFyc2VyIG9yIGxleGVyLCBgdGhpc2Agd2lsbCBzdGlsbCByZWZlcmVuY2UgdGhlIHJlbGF0ZWQgKnBhcnNlcipcbiAqIGluc3RhbmNlLCB3aGlsZSB0aGVzZSBhZGRpdGlvbmFsIGBoYXNoYCBmaWVsZHMgd2lsbCBhbHNvIGJlIHByb3ZpZGVkOlxuICpcbiAqICB7XG4gKiAgICBleGNlcHRpb246ICAgKHJlZmVyZW5jZSB0byB0aGUgZXhjZXB0aW9uIHRocm93bilcbiAqICB9XG4gKlxuICogUGxlYXNlIGRvIG5vdGUgdGhhdCBpbiB0aGUgbGF0dGVyIHNpdHVhdGlvbiwgdGhlIGBleHBlY3RlZGAgZmllbGQgd2lsbCBiZSBvbWl0dGVkIGFzXG4gKiB0aGlzIHR5cGUgb2YgZmFpbHVyZSBpcyBhc3N1bWVkIG5vdCB0byBiZSBkdWUgdG8gKnBhcnNlIGVycm9ycyogYnV0IHJhdGhlciBkdWUgdG8gdXNlclxuICogYWN0aW9uIGNvZGUgaW4gZWl0aGVyIHBhcnNlciBvciBsZXhlciBmYWlsaW5nIHVuZXhwZWN0ZWRseS5cbiAqXG4gKiAtLS1cbiAqXG4gKiBZb3UgY2FuIHNwZWNpZnkgcGFyc2VyIG9wdGlvbnMgYnkgc2V0dGluZyAvIG1vZGlmeWluZyB0aGUgYC55eWAgb2JqZWN0IG9mIHlvdXIgUGFyc2VyIGluc3RhbmNlLlxuICogVGhlc2Ugb3B0aW9ucyBhcmUgYXZhaWxhYmxlOlxuICpcbiAqICMjIyBvcHRpb25zIHdoaWNoIGFyZSBnbG9iYWwgZm9yIGFsbCBwYXJzZXIgaW5zdGFuY2VzXG4gKlxuICogIFBhcnNlci5wcmVfcGFyc2U6IGZ1bmN0aW9uKHl5KVxuICogICAgICAgICAgICAgICAgIG9wdGlvbmFsOiB5b3UgY2FuIHNwZWNpZnkgYSBwcmVfcGFyc2UoKSBmdW5jdGlvbiBpbiB0aGUgY2h1bmsgZm9sbG93aW5nXG4gKiAgICAgICAgICAgICAgICAgdGhlIGdyYW1tYXIsIGkuZS4gYWZ0ZXIgdGhlIGxhc3QgYCUlYC5cbiAqICBQYXJzZXIucG9zdF9wYXJzZTogZnVuY3Rpb24oeXksIHJldHZhbCwgcGFyc2VJbmZvKSB7IHJldHVybiByZXR2YWw7IH1cbiAqICAgICAgICAgICAgICAgICBvcHRpb25hbDogeW91IGNhbiBzcGVjaWZ5IGEgcG9zdF9wYXJzZSgpIGZ1bmN0aW9uIGluIHRoZSBjaHVuayBmb2xsb3dpbmdcbiAqICAgICAgICAgICAgICAgICB0aGUgZ3JhbW1hciwgaS5lLiBhZnRlciB0aGUgbGFzdCBgJSVgLiBXaGVuIGl0IGRvZXMgbm90IHJldHVybiBhbnkgdmFsdWUsXG4gKiAgICAgICAgICAgICAgICAgdGhlIHBhcnNlciB3aWxsIHJldHVybiB0aGUgb3JpZ2luYWwgYHJldHZhbGAuXG4gKlxuICogIyMjIG9wdGlvbnMgd2hpY2ggY2FuIGJlIHNldCB1cCBwZXIgcGFyc2VyIGluc3RhbmNlXG4gKlxuICogIHl5OiB7XG4gKiAgICAgIHByZV9wYXJzZTogIGZ1bmN0aW9uKHl5KVxuICogICAgICAgICAgICAgICAgIG9wdGlvbmFsOiBpcyBpbnZva2VkIGJlZm9yZSB0aGUgcGFyc2UgY3ljbGUgc3RhcnRzIChhbmQgYmVmb3JlIHRoZSBmaXJzdFxuICogICAgICAgICAgICAgICAgIGludm9jYXRpb24gb2YgYGxleCgpYCkgYnV0IGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBpbnZvY2F0aW9uIG9mXG4gKiAgICAgICAgICAgICAgICAgYHBhcnNlci5wcmVfcGFyc2UoKWApLlxuICogICAgICBwb3N0X3BhcnNlOiBmdW5jdGlvbih5eSwgcmV0dmFsLCBwYXJzZUluZm8pIHsgcmV0dXJuIHJldHZhbDsgfVxuICogICAgICAgICAgICAgICAgIG9wdGlvbmFsOiBpcyBpbnZva2VkIHdoZW4gdGhlIHBhcnNlIHRlcm1pbmF0ZXMgZHVlIHRvIHN1Y2Nlc3MgKCdhY2NlcHQnKVxuICogICAgICAgICAgICAgICAgIG9yIGZhaWx1cmUgKGV2ZW4gd2hlbiBleGNlcHRpb25zIGFyZSB0aHJvd24pLlxuICogICAgICAgICAgICAgICAgIGByZXR2YWxgIGNvbnRhaW5zIHRoZSByZXR1cm4gdmFsdWUgdG8gYmUgcHJvZHVjZWQgYnkgYFBhcnNlci5wYXJzZSgpYDtcbiAqICAgICAgICAgICAgICAgICB0aGlzIGZ1bmN0aW9uIGNhbiBvdmVycmlkZSB0aGUgcmV0dXJuIHZhbHVlIGJ5IHJldHVybmluZyBhbm90aGVyLlxuICogICAgICAgICAgICAgICAgIFdoZW4gaXQgZG9lcyBub3QgcmV0dXJuIGFueSB2YWx1ZSwgdGhlIHBhcnNlciB3aWxsIHJldHVybiB0aGUgb3JpZ2luYWxcbiAqICAgICAgICAgICAgICAgICBgcmV0dmFsYC5cbiAqICAgICAgICAgICAgICAgICBUaGlzIGZ1bmN0aW9uIGlzIGludm9rZWQgaW1tZWRpYXRlbHkgYmVmb3JlIGBwYXJzZXIucG9zdF9wYXJzZSgpYC5cbiAqXG4gKiAgICAgIHBhcnNlRXJyb3I6IGZ1bmN0aW9uKHN0ciwgaGFzaCwgRXhjZXB0aW9uQ2xhc3MpXG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IG92ZXJyaWRlcyB0aGUgZGVmYXVsdCBgcGFyc2VFcnJvcmAgZnVuY3Rpb24uXG4gKiAgICAgIHF1b3RlTmFtZTogZnVuY3Rpb24obmFtZSksXG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IG92ZXJyaWRlcyB0aGUgZGVmYXVsdCBgcXVvdGVOYW1lYCBmdW5jdGlvbi5cbiAqICB9XG4gKlxuICogIHBhcnNlci5sZXhlci5vcHRpb25zOiB7XG4gKiAgICAgIHByZV9sZXg6ICBmdW5jdGlvbigpXG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IGlzIGludm9rZWQgYmVmb3JlIHRoZSBsZXhlciBpcyBpbnZva2VkIHRvIHByb2R1Y2UgYW5vdGhlciB0b2tlbi5cbiAqICAgICAgICAgICAgICAgICBgdGhpc2AgcmVmZXJzIHRvIHRoZSBMZXhlciBvYmplY3QuXG4gKiAgICAgIHBvc3RfbGV4OiBmdW5jdGlvbih0b2tlbikgeyByZXR1cm4gdG9rZW47IH1cbiAqICAgICAgICAgICAgICAgICBvcHRpb25hbDogaXMgaW52b2tlZCB3aGVuIHRoZSBsZXhlciBoYXMgcHJvZHVjZWQgYSB0b2tlbiBgdG9rZW5gO1xuICogICAgICAgICAgICAgICAgIHRoaXMgZnVuY3Rpb24gY2FuIG92ZXJyaWRlIHRoZSByZXR1cm5lZCB0b2tlbiB2YWx1ZSBieSByZXR1cm5pbmcgYW5vdGhlci5cbiAqICAgICAgICAgICAgICAgICBXaGVuIGl0IGRvZXMgbm90IHJldHVybiBhbnkgKHRydXRoeSkgdmFsdWUsIHRoZSBsZXhlciB3aWxsIHJldHVyblxuICogICAgICAgICAgICAgICAgIHRoZSBvcmlnaW5hbCBgdG9rZW5gLlxuICogICAgICAgICAgICAgICAgIGB0aGlzYCByZWZlcnMgdG8gdGhlIExleGVyIG9iamVjdC5cbiAqXG4gKiAgICAgIHJhbmdlczogYm9vbGVhblxuICogICAgICAgICAgICAgICAgIG9wdGlvbmFsOiBgdHJ1ZWAgPT0+IHRva2VuIGxvY2F0aW9uIGluZm8gd2lsbCBpbmNsdWRlIGEgLnJhbmdlW10gbWVtYmVyLlxuICogICAgICBmbGV4OiBib29sZWFuXG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IGB0cnVlYCA9PT4gZmxleC1saWtlIGxleGluZyBiZWhhdmlvdXIgd2hlcmUgdGhlIHJ1bGVzIGFyZSB0ZXN0ZWRcbiAqICAgICAgICAgICAgICAgICBleGhhdXN0aXZlbHkgdG8gZmluZCB0aGUgbG9uZ2VzdCBtYXRjaC5cbiAqICAgICAgYmFja3RyYWNrX2xleGVyOiBib29sZWFuXG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IGB0cnVlYCA9PT4gbGV4ZXIgcmVnZXhlcyBhcmUgdGVzdGVkIGluIG9yZGVyIGFuZCBmb3IgaW52b2tlZDtcbiAqICAgICAgICAgICAgICAgICB0aGUgbGV4ZXIgdGVybWluYXRlcyB0aGUgc2NhbiB3aGVuIGEgdG9rZW4gaXMgcmV0dXJuZWQgYnkgdGhlIGFjdGlvbiBjb2RlLlxuICogICAgICB4cmVnZXhwOiBib29sZWFuXG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IGB0cnVlYCA9PT4gbGV4ZXIgcnVsZSByZWdleGVzIGFyZSBcImV4dGVuZGVkIHJlZ2V4IGZvcm1hdFwiIHJlcXVpcmluZyB0aGVcbiAqICAgICAgICAgICAgICAgICBgWFJlZ0V4cGAgbGlicmFyeS4gV2hlbiB0aGlzIGAlb3B0aW9uYCBoYXMgbm90IGJlZW4gc3BlY2lmaWVkIGF0IGNvbXBpbGUgdGltZSwgYWxsIGxleGVyXG4gKiAgICAgICAgICAgICAgICAgcnVsZSByZWdleGVzIGhhdmUgYmVlbiB3cml0dGVuIGFzIHN0YW5kYXJkIEphdmFTY3JpcHQgUmVnRXhwIGV4cHJlc3Npb25zLlxuICogIH1cbiAqL1xuXG4gICAgICAgIFxuICAgIFxuICAgICAgICAgICAgdmFyIHBhcnNlciA9IChmdW5jdGlvbiAoKSB7XG5cblxuLy8gU2VlIGFsc286XG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEzODIxMDcvd2hhdHMtYS1nb29kLXdheS10by1leHRlbmQtZXJyb3ItaW4tamF2YXNjcmlwdC8jMzU4ODE1MDhcbi8vIGJ1dCB3ZSBrZWVwIHRoZSBwcm90b3R5cGUuY29uc3RydWN0b3IgYW5kIHByb3RvdHlwZS5uYW1lIGFzc2lnbm1lbnQgbGluZXMgdG9vIGZvciBjb21wYXRpYmlsaXR5XG4vLyB3aXRoIHVzZXJsYW5kIGNvZGUgd2hpY2ggbWlnaHQgYWNjZXNzIHRoZSBkZXJpdmVkIGNsYXNzIGluIGEgJ2NsYXNzaWMnIHdheS5cbmZ1bmN0aW9uIEppc29uUGFyc2VyRXJyb3IobXNnLCBoYXNoKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICduYW1lJywge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogJ0ppc29uUGFyc2VyRXJyb3InXG4gICAgfSk7XG5cbiAgICBpZiAobXNnID09IG51bGwpIG1zZyA9ICc/Pz8nO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdtZXNzYWdlJywge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBtc2dcbiAgICB9KTtcblxuICAgIHRoaXMuaGFzaCA9IGhhc2g7XG5cbiAgICB2YXIgc3RhY2t0cmFjZTtcbiAgICBpZiAoaGFzaCAmJiBoYXNoLmV4Y2VwdGlvbiBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHZhciBleDIgPSBoYXNoLmV4Y2VwdGlvbjtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gZXgyLm1lc3NhZ2UgfHwgbXNnO1xuICAgICAgICBzdGFja3RyYWNlID0gZXgyLnN0YWNrO1xuICAgIH1cbiAgICBpZiAoIXN0YWNrdHJhY2UpIHtcbiAgICAgICAgaWYgKEVycm9yLmhhc093blByb3BlcnR5KCdjYXB0dXJlU3RhY2tUcmFjZScpKSB7ICAgICAgICAvLyBWOC9DaHJvbWUgZW5naW5lXG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YWNrdHJhY2UgPSAobmV3IEVycm9yKG1zZykpLnN0YWNrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzdGFja3RyYWNlKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc3RhY2snLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiBzdGFja3RyYWNlXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuaWYgKHR5cGVvZiBPYmplY3Quc2V0UHJvdG90eXBlT2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoSmlzb25QYXJzZXJFcnJvci5wcm90b3R5cGUsIEVycm9yLnByb3RvdHlwZSk7XG59IGVsc2Uge1xuICAgIEppc29uUGFyc2VyRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xufVxuSmlzb25QYXJzZXJFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBKaXNvblBhcnNlckVycm9yO1xuSmlzb25QYXJzZXJFcnJvci5wcm90b3R5cGUubmFtZSA9ICdKaXNvblBhcnNlckVycm9yJztcblxuXG5cblxuICAgICAgICAvLyBoZWxwZXI6IHJlY29uc3RydWN0IHRoZSBwcm9kdWN0aW9uc1tdIHRhYmxlXG4gICAgICAgIGZ1bmN0aW9uIGJwKHMpIHtcbiAgICAgICAgICAgIHZhciBydiA9IFtdO1xuICAgICAgICAgICAgdmFyIHAgPSBzLnBvcDtcbiAgICAgICAgICAgIHZhciByID0gcy5ydWxlO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHJ2LnB1c2goW1xuICAgICAgICAgICAgICAgICAgICBwW2ldLFxuICAgICAgICAgICAgICAgICAgICByW2ldXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcnY7XG4gICAgICAgIH1cbiAgICBcblxuXG4gICAgICAgIC8vIGhlbHBlcjogcmVjb25zdHJ1Y3QgdGhlIGRlZmF1bHRBY3Rpb25zW10gdGFibGVcbiAgICAgICAgZnVuY3Rpb24gYmRhKHMpIHtcbiAgICAgICAgICAgIHZhciBydiA9IHt9O1xuICAgICAgICAgICAgdmFyIGQgPSBzLmlkeDtcbiAgICAgICAgICAgIHZhciBnID0gcy5nb3RvO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBkLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBqID0gZFtpXTtcbiAgICAgICAgICAgICAgICBydltqXSA9IGdbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcnY7XG4gICAgICAgIH1cbiAgICBcblxuXG4gICAgICAgIC8vIGhlbHBlcjogcmVjb25zdHJ1Y3QgdGhlICdnb3RvJyB0YWJsZVxuICAgICAgICBmdW5jdGlvbiBidChzKSB7XG4gICAgICAgICAgICB2YXIgcnYgPSBbXTtcbiAgICAgICAgICAgIHZhciBkID0gcy5sZW47XG4gICAgICAgICAgICB2YXIgeSA9IHMuc3ltYm9sO1xuICAgICAgICAgICAgdmFyIHQgPSBzLnR5cGU7XG4gICAgICAgICAgICB2YXIgYSA9IHMuc3RhdGU7XG4gICAgICAgICAgICB2YXIgbSA9IHMubW9kZTtcbiAgICAgICAgICAgIHZhciBnID0gcy5nb3RvO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBkLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBuID0gZFtpXTtcbiAgICAgICAgICAgICAgICB2YXIgcSA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB6ID0geS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHQuc2hpZnQoKSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBxW3pdID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0uc2hpZnQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnLnNoaWZ0KClcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBxW3pdID0gYS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHR5cGUgPT09IDE6IGFjY2VwdFxuICAgICAgICAgICAgICAgICAgICAgICAgcVt6XSA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJ2LnB1c2gocSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcnY7XG4gICAgICAgIH1cbiAgICBcblxuXG4gICAgICAgIC8vIGhlbHBlcjogcnVubGVuZ3RoIGVuY29kaW5nIHdpdGggaW5jcmVtZW50IHN0ZXA6IGNvZGUsIGxlbmd0aDogc3RlcCAoZGVmYXVsdCBzdGVwID0gMClcbiAgICAgICAgLy8gYHRoaXNgIHJlZmVyZW5jZXMgYW4gYXJyYXlcbiAgICAgICAgZnVuY3Rpb24gcyhjLCBsLCBhKSB7XG4gICAgICAgICAgICBhID0gYSB8fCAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2goYyk7XG4gICAgICAgICAgICAgICAgYyArPSBhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGVscGVyOiBkdXBsaWNhdGUgc2VxdWVuY2UgZnJvbSAqcmVsYXRpdmUqIG9mZnNldCBhbmQgbGVuZ3RoLlxuICAgICAgICAvLyBgdGhpc2AgcmVmZXJlbmNlcyBhbiBhcnJheVxuICAgICAgICBmdW5jdGlvbiBjKGksIGwpIHtcbiAgICAgICAgICAgIGkgPSB0aGlzLmxlbmd0aCAtIGk7XG4gICAgICAgICAgICBmb3IgKGwgKz0gaTsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMucHVzaCh0aGlzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhlbHBlcjogdW5wYWNrIGFuIGFycmF5IHVzaW5nIGhlbHBlcnMgYW5kIGRhdGEsIGFsbCBwYXNzZWQgaW4gYW4gYXJyYXkgYXJndW1lbnQgJ2EnLlxuICAgICAgICBmdW5jdGlvbiB1KGEpIHtcbiAgICAgICAgICAgIHZhciBydiA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBlID0gYVtpXTtcbiAgICAgICAgICAgICAgICAvLyBJcyB0aGlzIGVudHJ5IGEgaGVscGVyIGZ1bmN0aW9uP1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIGUuYXBwbHkocnYsIGFbaV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJ2LnB1c2goZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgICB9XG4gICAgXG5cbnZhciBwYXJzZXIgPSB7XG4gICAgLy8gQ29kZSBHZW5lcmF0b3IgSW5mb3JtYXRpb24gUmVwb3J0XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyBPcHRpb25zOlxuICAgIC8vXG4gICAgLy8gICBkZWZhdWx0IGFjdGlvbiBtb2RlOiAuLi4uLi4uLi4uLi4uIFtcImNsYXNzaWNcIixcIm1lcmdlXCJdXG4gICAgLy8gICB0ZXN0LWNvbXBpbGUgYWN0aW9uIG1vZGU6IC4uLi4uLi4uIFwicGFyc2VyOiosbGV4ZXI6KlwiXG4gICAgLy8gICB0cnkuLmNhdGNoOiAuLi4uLi4uLi4uLi4uLi4uLi4uLi4uIHRydWVcbiAgICAvLyAgIGRlZmF1bHQgcmVzb2x2ZSBvbiBjb25mbGljdDogLi4uLi4gdHJ1ZVxuICAgIC8vICAgb24tZGVtYW5kIGxvb2stYWhlYWQ6IC4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vICAgZXJyb3IgcmVjb3ZlcnkgdG9rZW4gc2tpcCBtYXhpbXVtOiAzXG4gICAgLy8gICB5eWVycm9yIGluIHBhcnNlIGFjdGlvbnMgaXM6IC4uLi4uIE5PVCByZWNvdmVyYWJsZSxcbiAgICAvLyAgIHl5ZXJyb3IgaW4gbGV4ZXIgYWN0aW9ucyBhbmQgb3RoZXIgbm9uLWZhdGFsIGxleGVyIGFyZTpcbiAgICAvLyAgIC4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4gTk9UIHJlY292ZXJhYmxlLFxuICAgIC8vICAgZGVidWcgZ3JhbW1hci9vdXRwdXQ6IC4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vICAgaGFzIHBhcnRpYWwgTFIgY29uZmxpY3QgdXBncmFkZTogICB0cnVlXG4gICAgLy8gICBydWRpbWVudGFyeSB0b2tlbi1zdGFjayBzdXBwb3J0OiAgIGZhbHNlXG4gICAgLy8gICBwYXJzZXIgdGFibGUgY29tcHJlc3Npb24gbW9kZTogLi4uIDJcbiAgICAvLyAgIGV4cG9ydCBkZWJ1ZyB0YWJsZXM6IC4uLi4uLi4uLi4uLi4gZmFsc2VcbiAgICAvLyAgIGV4cG9ydCAqYWxsKiB0YWJsZXM6IC4uLi4uLi4uLi4uLi4gZmFsc2VcbiAgICAvLyAgIG1vZHVsZSB0eXBlOiAuLi4uLi4uLi4uLi4uLi4uLi4uLi4gY29tbW9uanNcbiAgICAvLyAgIHBhcnNlciBlbmdpbmUgdHlwZTogLi4uLi4uLi4uLi4uLi4gbGFsclxuICAgIC8vICAgb3V0cHV0IG1haW4oKSBpbiB0aGUgbW9kdWxlOiAuLi4uLiB0cnVlXG4gICAgLy8gICBoYXMgdXNlci1zcGVjaWZpZWQgbWFpbigpOiAuLi4uLi4uIGZhbHNlXG4gICAgLy8gICBoYXMgdXNlci1zcGVjaWZpZWQgcmVxdWlyZSgpL2ltcG9ydCBtb2R1bGVzIGZvciBtYWluKCk6XG4gICAgLy8gICAuLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uIGZhbHNlXG4gICAgLy8gICBudW1iZXIgb2YgZXhwZWN0ZWQgY29uZmxpY3RzOiAuLi4uIDBcbiAgICAvL1xuICAgIC8vXG4gICAgLy8gUGFyc2VyIEFuYWx5c2lzIGZsYWdzOlxuICAgIC8vXG4gICAgLy8gICBubyBzaWduaWZpY2FudCBhY3Rpb25zIChwYXJzZXIgaXMgYSBsYW5ndWFnZSBtYXRjaGVyIG9ubHkpOlxuICAgIC8vICAgLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vICAgdXNlcyB5eWxlbmc6IC4uLi4uLi4uLi4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vICAgdXNlcyB5eWxpbmVubzogLi4uLi4uLi4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vICAgdXNlcyB5eXRleHQ6IC4uLi4uLi4uLi4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vICAgdXNlcyB5eWxsb2M6IC4uLi4uLi4uLi4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vICAgdXNlcyBQYXJzZUVycm9yIEFQSTogLi4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vICAgdXNlcyBZWUVSUk9SOiAuLi4uLi4uLi4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vICAgdXNlcyBZWVJFQ09WRVJJTkc6IC4uLi4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vICAgdXNlcyBZWUVSUk9LOiAuLi4uLi4uLi4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vICAgdXNlcyBZWUNMRUFSSU46IC4uLi4uLi4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vICAgdHJhY2tzIHJ1bGUgdmFsdWVzOiAuLi4uLi4uLi4uLi4uLiB0cnVlXG4gICAgLy8gICBhc3NpZ25zIHJ1bGUgdmFsdWVzOiAuLi4uLi4uLi4uLi4uIHRydWVcbiAgICAvLyAgIHVzZXMgbG9jYXRpb24gdHJhY2tpbmc6IC4uLi4uLi4uLi4gZmFsc2VcbiAgICAvLyAgIGFzc2lnbnMgbG9jYXRpb246IC4uLi4uLi4uLi4uLi4uLi4gZmFsc2VcbiAgICAvLyAgIHVzZXMgeXlzdGFjazogLi4uLi4uLi4uLi4uLi4uLi4uLi4gZmFsc2VcbiAgICAvLyAgIHVzZXMgeXlzc3RhY2s6IC4uLi4uLi4uLi4uLi4uLi4uLi4gZmFsc2VcbiAgICAvLyAgIHVzZXMgeXlzcDogLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4gdHJ1ZVxuICAgIC8vICAgdXNlcyB5eXJ1bGVsZW5ndGg6IC4uLi4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vICAgdXNlcyB5eU1lcmdlTG9jYXRpb25JbmZvIEFQSTogLi4uLiBmYWxzZVxuICAgIC8vICAgaGFzIGVycm9yIHJlY292ZXJ5OiAuLi4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vICAgaGFzIGVycm9yIHJlcG9ydGluZzogLi4uLi4uLi4uLi4uLiBmYWxzZVxuICAgIC8vXG4gICAgLy8gLS0tLS0tLS0tIEVORCBPRiBSRVBPUlQgLS0tLS0tLS0tLS1cblxudHJhY2U6IGZ1bmN0aW9uIG5vX29wX3RyYWNlKCkgeyB9LFxuSmlzb25QYXJzZXJFcnJvcjogSmlzb25QYXJzZXJFcnJvcixcbnl5OiB7fSxcbm9wdGlvbnM6IHtcbiAgdHlwZTogXCJsYWxyXCIsXG4gIGhhc1BhcnRpYWxMclVwZ3JhZGVPbkNvbmZsaWN0OiB0cnVlLFxuICBlcnJvclJlY292ZXJ5VG9rZW5EaXNjYXJkQ291bnQ6IDNcbn0sXG5zeW1ib2xzXzoge1xuICBcIiRhY2NlcHRcIjogMCxcbiAgXCIkZW5kXCI6IDEsXG4gIFwiQUREXCI6IDMsXG4gIFwiQU5HTEVcIjogMTYsXG4gIFwiQ0hTXCI6IDIyLFxuICBcIkNPTU1BXCI6IDE0LFxuICBcIkNTU19DUFJPUFwiOiAxMyxcbiAgXCJDU1NfVkFSXCI6IDEyLFxuICBcIkRJVlwiOiA2LFxuICBcIkVNU1wiOiAyMCxcbiAgXCJFT0ZcIjogMSxcbiAgXCJFWFNcIjogMjEsXG4gIFwiRlJFUVwiOiAxOCxcbiAgXCJMRU5HVEhcIjogMTUsXG4gIFwiTFBBUkVOXCI6IDcsXG4gIFwiTVVMXCI6IDUsXG4gIFwiTkVTVEVEX0NBTENcIjogOSxcbiAgXCJOVU1CRVJcIjogMTEsXG4gIFwiUEVSQ0VOVEFHRVwiOiAyOCxcbiAgXCJQUkVGSVhcIjogMTAsXG4gIFwiUkVNU1wiOiAyMyxcbiAgXCJSRVNcIjogMTksXG4gIFwiUlBBUkVOXCI6IDgsXG4gIFwiU1VCXCI6IDQsXG4gIFwiVElNRVwiOiAxNyxcbiAgXCJWSFNcIjogMjQsXG4gIFwiVk1BWFNcIjogMjcsXG4gIFwiVk1JTlNcIjogMjYsXG4gIFwiVldTXCI6IDI1LFxuICBcImNzc192YWx1ZVwiOiAzMyxcbiAgXCJjc3NfdmFyaWFibGVcIjogMzIsXG4gIFwiZXJyb3JcIjogMixcbiAgXCJleHByZXNzaW9uXCI6IDI5LFxuICBcIm1hdGhfZXhwcmVzc2lvblwiOiAzMCxcbiAgXCJ2YWx1ZVwiOiAzMVxufSxcbnRlcm1pbmFsc186IHtcbiAgMTogXCJFT0ZcIixcbiAgMjogXCJlcnJvclwiLFxuICAzOiBcIkFERFwiLFxuICA0OiBcIlNVQlwiLFxuICA1OiBcIk1VTFwiLFxuICA2OiBcIkRJVlwiLFxuICA3OiBcIkxQQVJFTlwiLFxuICA4OiBcIlJQQVJFTlwiLFxuICA5OiBcIk5FU1RFRF9DQUxDXCIsXG4gIDEwOiBcIlBSRUZJWFwiLFxuICAxMTogXCJOVU1CRVJcIixcbiAgMTI6IFwiQ1NTX1ZBUlwiLFxuICAxMzogXCJDU1NfQ1BST1BcIixcbiAgMTQ6IFwiQ09NTUFcIixcbiAgMTU6IFwiTEVOR1RIXCIsXG4gIDE2OiBcIkFOR0xFXCIsXG4gIDE3OiBcIlRJTUVcIixcbiAgMTg6IFwiRlJFUVwiLFxuICAxOTogXCJSRVNcIixcbiAgMjA6IFwiRU1TXCIsXG4gIDIxOiBcIkVYU1wiLFxuICAyMjogXCJDSFNcIixcbiAgMjM6IFwiUkVNU1wiLFxuICAyNDogXCJWSFNcIixcbiAgMjU6IFwiVldTXCIsXG4gIDI2OiBcIlZNSU5TXCIsXG4gIDI3OiBcIlZNQVhTXCIsXG4gIDI4OiBcIlBFUkNFTlRBR0VcIlxufSxcblRFUlJPUjogMixcbiAgICBFT0Y6IDEsXG5cbiAgICAvLyBpbnRlcm5hbHM6IGRlZmluZWQgaGVyZSBzbyB0aGUgb2JqZWN0ICpzdHJ1Y3R1cmUqIGRvZXNuJ3QgZ2V0IG1vZGlmaWVkIGJ5IHBhcnNlKCkgZXQgYWwsXG4gICAgLy8gdGh1cyBoZWxwaW5nIEpJVCBjb21waWxlcnMgbGlrZSBDaHJvbWUgVjguXG4gICAgb3JpZ2luYWxRdW90ZU5hbWU6IG51bGwsXG4gICAgb3JpZ2luYWxQYXJzZUVycm9yOiBudWxsLFxuICAgIGNsZWFudXBBZnRlclBhcnNlOiBudWxsLFxuICAgIGNvbnN0cnVjdFBhcnNlRXJyb3JJbmZvOiBudWxsLFxuICAgIHl5TWVyZ2VMb2NhdGlvbkluZm86IG51bGwsXG5cbiAgICBfX3JlZW50cmFudF9jYWxsX2RlcHRoOiAwLCAgICAgIC8vIElOVEVSTkFMIFVTRSBPTkxZXG4gICAgX19lcnJvcl9pbmZvczogW10sICAgICAgICAgICAgICAvLyBJTlRFUk5BTCBVU0UgT05MWTogdGhlIHNldCBvZiBwYXJzZUVycm9ySW5mbyBvYmplY3RzIGNyZWF0ZWQgc2luY2UgdGhlIGxhc3QgY2xlYW51cFxuICAgIF9fZXJyb3JfcmVjb3ZlcnlfaW5mb3M6IFtdLCAgICAgLy8gSU5URVJOQUwgVVNFIE9OTFk6IHRoZSBzZXQgb2YgcGFyc2VFcnJvckluZm8gb2JqZWN0cyBjcmVhdGVkIHNpbmNlIHRoZSBsYXN0IGNsZWFudXBcblxuICAgIC8vIEFQSXMgd2hpY2ggd2lsbCBiZSBzZXQgdXAgZGVwZW5kaW5nIG9uIHVzZXIgYWN0aW9uIGNvZGUgYW5hbHlzaXM6XG4gICAgLy95eVJlY292ZXJpbmc6IDAsXG4gICAgLy95eUVyck9rOiAwLFxuICAgIC8veXlDbGVhckluOiAwLFxuXG4gICAgLy8gSGVscGVyIEFQSXNcbiAgICAvLyAtLS0tLS0tLS0tLVxuXG4gICAgLy8gSGVscGVyIGZ1bmN0aW9uIHdoaWNoIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHVzZXIgY29kZSBsYXRlciBvbjogcHV0IHN1aXRhYmxlIHF1b3RlcyBhcm91bmRcbiAgICAvLyBsaXRlcmFsIElEcyBpbiBhIGRlc2NyaXB0aW9uIHN0cmluZy5cbiAgICBxdW90ZU5hbWU6IGZ1bmN0aW9uIHBhcnNlcl9xdW90ZU5hbWUoaWRfc3RyKSB7XG4gICAgICAgIHJldHVybiAnXCInICsgaWRfc3RyICsgJ1wiJztcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJuIHRoZSBuYW1lIG9mIHRoZSBnaXZlbiBzeW1ib2wgKHRlcm1pbmFsIG9yIG5vbi10ZXJtaW5hbCkgYXMgYSBzdHJpbmcsIHdoZW4gYXZhaWxhYmxlLlxuICAgIC8vXG4gICAgLy8gUmV0dXJuIE5VTEwgd2hlbiB0aGUgc3ltYm9sIGlzIHVua25vd24gdG8gdGhlIHBhcnNlci5cbiAgICBnZXRTeW1ib2xOYW1lOiBmdW5jdGlvbiBwYXJzZXJfZ2V0U3ltYm9sTmFtZShzeW1ib2wpIHtcbiAgICAgICAgaWYgKHRoaXMudGVybWluYWxzX1tzeW1ib2xdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50ZXJtaW5hbHNfW3N5bWJvbF07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPdGhlcndpc2UuLi4gdGhpcyBtaWdodCByZWZlciB0byBhIFJVTEUgdG9rZW4gaS5lLiBhIG5vbi10ZXJtaW5hbDogc2VlIGlmIHdlIGNhbiBkaWcgdGhhdCBvbmUgdXAuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEFuIGV4YW1wbGUgb2YgdGhpcyBtYXkgYmUgd2hlcmUgYSBydWxlJ3MgYWN0aW9uIGNvZGUgY29udGFpbnMgYSBjYWxsIGxpa2UgdGhpczpcbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgICBwYXJzZXIuZ2V0U3ltYm9sTmFtZSgjJClcbiAgICAgICAgLy9cbiAgICAgICAgLy8gdG8gb2J0YWluIGEgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgY3VycmVudCBncmFtbWFyIHJ1bGUuXG4gICAgICAgIHZhciBzID0gdGhpcy5zeW1ib2xzXztcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHMpIHtcbiAgICAgICAgICAgIGlmIChzW2tleV0gPT09IHN5bWJvbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIC8vIFJldHVybiBhIG1vcmUtb3ItbGVzcyBodW1hbi1yZWFkYWJsZSBkZXNjcmlwdGlvbiBvZiB0aGUgZ2l2ZW4gc3ltYm9sLCB3aGVuIGF2YWlsYWJsZSxcbiAgICAvLyBvciB0aGUgc3ltYm9sIGl0c2VsZiwgc2VydmluZyBhcyBpdHMgb3duICdkZXNjcmlwdGlvbicgZm9yIGxhY2sgb2Ygc29tZXRoaW5nIGJldHRlciB0byBzZXJ2ZSB1cC5cbiAgICAvL1xuICAgIC8vIFJldHVybiBOVUxMIHdoZW4gdGhlIHN5bWJvbCBpcyB1bmtub3duIHRvIHRoZSBwYXJzZXIuXG4gICAgZGVzY3JpYmVTeW1ib2w6IGZ1bmN0aW9uIHBhcnNlcl9kZXNjcmliZVN5bWJvbChzeW1ib2wpIHtcbiAgICAgICAgaWYgKHN5bWJvbCAhPT0gdGhpcy5FT0YgJiYgdGhpcy50ZXJtaW5hbF9kZXNjcmlwdGlvbnNfICYmIHRoaXMudGVybWluYWxfZGVzY3JpcHRpb25zX1tzeW1ib2xdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50ZXJtaW5hbF9kZXNjcmlwdGlvbnNfW3N5bWJvbF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3ltYm9sID09PSB0aGlzLkVPRikge1xuICAgICAgICAgICAgcmV0dXJuICdlbmQgb2YgaW5wdXQnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpZCA9IHRoaXMuZ2V0U3ltYm9sTmFtZShzeW1ib2wpO1xuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnF1b3RlTmFtZShpZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIC8vIFByb2R1Y2UgYSAobW9yZSBvciBsZXNzKSBodW1hbi1yZWFkYWJsZSBsaXN0IG9mIGV4cGVjdGVkIHRva2VucyBhdCB0aGUgcG9pbnQgb2YgZmFpbHVyZS5cbiAgICAvL1xuICAgIC8vIFRoZSBwcm9kdWNlZCBsaXN0IG1heSBjb250YWluIHRva2VuIG9yIHRva2VuIHNldCBkZXNjcmlwdGlvbnMgaW5zdGVhZCBvZiB0aGUgdG9rZW5zXG4gICAgLy8gdGhlbXNlbHZlcyB0byBoZWxwIHR1cm5pbmcgdGhpcyBvdXRwdXQgaW50byBzb21ldGhpbmcgdGhhdCBlYXNpZXIgdG8gcmVhZCBieSBodW1hbnNcbiAgICAvLyB1bmxlc3MgYGRvX25vdF9kZXNjcmliZWAgcGFyYW1ldGVyIGlzIHNldCwgaW4gd2hpY2ggY2FzZSBhIGxpc3Qgb2YgdGhlIHJhdywgKm51bWVyaWMqLFxuICAgIC8vIGV4cGVjdGVkIHRlcm1pbmFscyBhbmQgbm9udGVybWluYWxzIGlzIHByb2R1Y2VkLlxuICAgIC8vXG4gICAgLy8gVGhlIHJldHVybmVkIGxpc3QgKGFycmF5KSB3aWxsIG5vdCBjb250YWluIGFueSBkdXBsaWNhdGUgZW50cmllcy5cbiAgICBjb2xsZWN0X2V4cGVjdGVkX3Rva2VuX3NldDogZnVuY3Rpb24gcGFyc2VyX2NvbGxlY3RfZXhwZWN0ZWRfdG9rZW5fc2V0KHN0YXRlLCBkb19ub3RfZGVzY3JpYmUpIHtcbiAgICAgICAgdmFyIFRFUlJPUiA9IHRoaXMuVEVSUk9SO1xuICAgICAgICB2YXIgdG9rZW5zZXQgPSBbXTtcbiAgICAgICAgdmFyIGNoZWNrID0ge307XG4gICAgICAgIC8vIEhhcyB0aGlzIChlcnJvcj8pIHN0YXRlIGJlZW4gb3V0Zml0dGVkIHdpdGggYSBjdXN0b20gZXhwZWN0YXRpb25zIGRlc2NyaXB0aW9uIHRleHQgZm9yIGh1bWFuIGNvbnN1bXB0aW9uP1xuICAgICAgICAvLyBJZiBzbywgdXNlIHRoYXQgb25lIGluc3RlYWQgb2YgdGhlIGxlc3MgcGFsYXRhYmxlIHRva2VuIHNldC5cbiAgICAgICAgaWYgKCFkb19ub3RfZGVzY3JpYmUgJiYgdGhpcy5zdGF0ZV9kZXNjcmlwdGlvbnNfICYmIHRoaXMuc3RhdGVfZGVzY3JpcHRpb25zX1tzdGF0ZV0pIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZV9kZXNjcmlwdGlvbnNfW3N0YXRlXVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBwIGluIHRoaXMudGFibGVbc3RhdGVdKSB7XG4gICAgICAgICAgICBwID0gK3A7XG4gICAgICAgICAgICBpZiAocCAhPT0gVEVSUk9SKSB7XG4gICAgICAgICAgICAgICAgdmFyIGQgPSBkb19ub3RfZGVzY3JpYmUgPyBwIDogdGhpcy5kZXNjcmliZVN5bWJvbChwKTtcbiAgICAgICAgICAgICAgICBpZiAoZCAmJiAhY2hlY2tbZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zZXQucHVzaChkKTtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tbZF0gPSB0cnVlOyAgICAgICAgLy8gTWFyayB0aGlzIHRva2VuIGRlc2NyaXB0aW9uIGFzIGFscmVhZHkgbWVudGlvbmVkIHRvIHByZXZlbnQgb3V0cHV0dGluZyBkdXBsaWNhdGUgZW50cmllcy5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRva2Vuc2V0O1xuICAgIH0sXG5wcm9kdWN0aW9uc186IGJwKHtcbiAgcG9wOiB1KFtcbiAgMjksXG4gIHMsXG4gIFszMCwgMTBdLFxuICAzMSxcbiAgMzEsXG4gIDMyLFxuICAzMixcbiAgcyxcbiAgWzMzLCAxNV1cbl0pLFxuICBydWxlOiB1KFtcbiAgMixcbiAgcyxcbiAgWzMsIDVdLFxuICA0LFxuICA3LFxuICBzLFxuICBbMSwgNF0sXG4gIDIsXG4gIDQsXG4gIDYsXG4gIHMsXG4gIFsxLCAxNF0sXG4gIDJcbl0pXG59KSxcbnBlcmZvcm1BY3Rpb246IGZ1bmN0aW9uIHBhcnNlcl9fUGVyZm9ybUFjdGlvbih5eXN0YXRlIC8qIGFjdGlvblsxXSAqLywgeXlzcCwgeXl2c3RhY2spIHtcblxuICAgICAgICAgIC8qIHRoaXMgPT0geXl2YWwgKi9cblxuICAgICAgICAgIC8vIHRoZSBKUyBlbmdpbmUgaXRzZWxmIGNhbiBnbyBhbmQgcmVtb3ZlIHRoZXNlIHN0YXRlbWVudHMgd2hlbiBgeXlgIHR1cm5zIG91dCB0byBiZSB1bnVzZWQgaW4gYW55IGFjdGlvbiBjb2RlIVxuICAgICAgICAgIHZhciB5eSA9IHRoaXMueXk7XG4gICAgICAgICAgdmFyIHl5cGFyc2VyID0geXkucGFyc2VyO1xuICAgICAgICAgIHZhciB5eWxleGVyID0geXkubGV4ZXI7XG5cbiAgICAgICAgICBcblxuICAgICAgICAgIHN3aXRjaCAoeXlzdGF0ZSkge1xuY2FzZSAwOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgJGFjY2VwdCA6IGV4cHJlc3Npb24gJGVuZCAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogMSxWVCxWQSwtLC0sLSwtLC0sLSk6XG4gICAgdGhpcy4kID0geXl2c3RhY2tbeXlzcCAtIDFdO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiAxLFZULFZBLC0sLSwtLC0sLSwtKVxuICAgIGJyZWFrO1xuXG5jYXNlIDE6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBleHByZXNzaW9uIDogbWF0aF9leHByZXNzaW9uIEVPRiAqL1xuXG4gICAgLy8gZGVmYXVsdCBhY3Rpb24gKGdlbmVyYXRlZCBieSBKSVNPTiBtb2RlIGNsYXNzaWMvbWVyZ2UgOjogMixWVCxWQSwtLC0sLSwtLC0sLSk6XG4gICAgdGhpcy4kID0geXl2c3RhY2tbeXlzcCAtIDFdO1xuICAgIC8vIEVORCBvZiBkZWZhdWx0IGFjdGlvbiAoZ2VuZXJhdGVkIGJ5IEpJU09OIG1vZGUgY2xhc3NpYy9tZXJnZSA6OiAyLFZULFZBLC0sLSwtLC0sLSwtKVxuICAgIFxuICAgIFxuICAgIHJldHVybiB5eXZzdGFja1t5eXNwIC0gMV07XG4gICAgYnJlYWs7XG5cbmNhc2UgMjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG1hdGhfZXhwcmVzc2lvbiA6IG1hdGhfZXhwcmVzc2lvbiBBREQgbWF0aF9leHByZXNzaW9uICovXG5jYXNlIDM6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtYXRoX2V4cHJlc3Npb24gOiBtYXRoX2V4cHJlc3Npb24gU1VCIG1hdGhfZXhwcmVzc2lvbiAqL1xuY2FzZSA0OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgbWF0aF9leHByZXNzaW9uIDogbWF0aF9leHByZXNzaW9uIE1VTCBtYXRoX2V4cHJlc3Npb24gKi9cbmNhc2UgNTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG1hdGhfZXhwcmVzc2lvbiA6IG1hdGhfZXhwcmVzc2lvbiBESVYgbWF0aF9leHByZXNzaW9uICovXG5cbiAgICB0aGlzLiQgPSB7IHR5cGU6ICdNYXRoRXhwcmVzc2lvbicsIG9wZXJhdG9yOiB5eXZzdGFja1t5eXNwIC0gMV0sIGxlZnQ6IHl5dnN0YWNrW3l5c3AgLSAyXSwgcmlnaHQ6IHl5dnN0YWNrW3l5c3BdIH07XG4gICAgYnJlYWs7XG5cbmNhc2UgNjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG1hdGhfZXhwcmVzc2lvbiA6IExQQVJFTiBtYXRoX2V4cHJlc3Npb24gUlBBUkVOICovXG5cbiAgICB0aGlzLiQgPSB5eXZzdGFja1t5eXNwIC0gMV07XG4gICAgYnJlYWs7XG5cbmNhc2UgNzpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG1hdGhfZXhwcmVzc2lvbiA6IE5FU1RFRF9DQUxDIExQQVJFTiBtYXRoX2V4cHJlc3Npb24gUlBBUkVOICovXG5cbiAgICB0aGlzLiQgPSB7IHR5cGU6ICdDYWxjJywgdmFsdWU6IHl5dnN0YWNrW3l5c3AgLSAxXSB9O1xuICAgIGJyZWFrO1xuXG5jYXNlIDg6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBtYXRoX2V4cHJlc3Npb24gOiBTVUIgUFJFRklYIFNVQiBORVNURURfQ0FMQyBMUEFSRU4gbWF0aF9leHByZXNzaW9uIFJQQVJFTiAqL1xuXG4gICAgdGhpcy4kID0geyB0eXBlOiAnQ2FsYycsIHZhbHVlOiB5eXZzdGFja1t5eXNwIC0gMV0sIHByZWZpeDogeXl2c3RhY2tbeXlzcCAtIDVdIH07XG4gICAgYnJlYWs7XG5cbmNhc2UgOTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG1hdGhfZXhwcmVzc2lvbiA6IGNzc192YXJpYWJsZSAqL1xuY2FzZSAxMDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG1hdGhfZXhwcmVzc2lvbiA6IGNzc192YWx1ZSAqL1xuY2FzZSAxMTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIG1hdGhfZXhwcmVzc2lvbiA6IHZhbHVlICovXG5cbiAgICB0aGlzLiQgPSB5eXZzdGFja1t5eXNwXTtcbiAgICBicmVhaztcblxuY2FzZSAxMjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIHZhbHVlIDogTlVNQkVSICovXG5cbiAgICB0aGlzLiQgPSB7IHR5cGU6ICdWYWx1ZScsIHZhbHVlOiBwYXJzZUZsb2F0KHl5dnN0YWNrW3l5c3BdKSB9O1xuICAgIGJyZWFrO1xuXG5jYXNlIDEzOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgdmFsdWUgOiBTVUIgTlVNQkVSICovXG5cbiAgICB0aGlzLiQgPSB7IHR5cGU6ICdWYWx1ZScsIHZhbHVlOiBwYXJzZUZsb2F0KHl5dnN0YWNrW3l5c3BdKSAqIC0xIH07XG4gICAgYnJlYWs7XG5cbmNhc2UgMTQ6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjc3NfdmFyaWFibGUgOiBDU1NfVkFSIExQQVJFTiBDU1NfQ1BST1AgUlBBUkVOICovXG5cbiAgICB0aGlzLiQgPSB7IHR5cGU6ICdDc3NWYXJpYWJsZScsIHZhbHVlOiB5eXZzdGFja1t5eXNwIC0gMV0gfTtcbiAgICBicmVhaztcblxuY2FzZSAxNTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNzc192YXJpYWJsZSA6IENTU19WQVIgTFBBUkVOIENTU19DUFJPUCBDT01NQSBtYXRoX2V4cHJlc3Npb24gUlBBUkVOICovXG5cbiAgICB0aGlzLiQgPSB7IHR5cGU6ICdDc3NWYXJpYWJsZScsIHZhbHVlOiB5eXZzdGFja1t5eXNwIC0gM10sIGZhbGxiYWNrOiB5eXZzdGFja1t5eXNwIC0gMV0gfTtcbiAgICBicmVhaztcblxuY2FzZSAxNjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNzc192YWx1ZSA6IExFTkdUSCAqL1xuXG4gICAgdGhpcy4kID0geyB0eXBlOiAnTGVuZ3RoVmFsdWUnLCB2YWx1ZTogcGFyc2VGbG9hdCh5eXZzdGFja1t5eXNwXSksIHVuaXQ6IC9bYS16XSsvLmV4ZWMoeXl2c3RhY2tbeXlzcF0pWzBdIH07XG4gICAgYnJlYWs7XG5cbmNhc2UgMTc6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjc3NfdmFsdWUgOiBBTkdMRSAqL1xuXG4gICAgdGhpcy4kID0geyB0eXBlOiAnQW5nbGVWYWx1ZScsIHZhbHVlOiBwYXJzZUZsb2F0KHl5dnN0YWNrW3l5c3BdKSwgdW5pdDogL1thLXpdKy8uZXhlYyh5eXZzdGFja1t5eXNwXSlbMF0gfTtcbiAgICBicmVhaztcblxuY2FzZSAxODpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNzc192YWx1ZSA6IFRJTUUgKi9cblxuICAgIHRoaXMuJCA9IHsgdHlwZTogJ1RpbWVWYWx1ZScsIHZhbHVlOiBwYXJzZUZsb2F0KHl5dnN0YWNrW3l5c3BdKSwgdW5pdDogL1thLXpdKy8uZXhlYyh5eXZzdGFja1t5eXNwXSlbMF0gfTtcbiAgICBicmVhaztcblxuY2FzZSAxOTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNzc192YWx1ZSA6IEZSRVEgKi9cblxuICAgIHRoaXMuJCA9IHsgdHlwZTogJ0ZyZXF1ZW5jeVZhbHVlJywgdmFsdWU6IHBhcnNlRmxvYXQoeXl2c3RhY2tbeXlzcF0pLCB1bml0OiAvW2Etel0rLy5leGVjKHl5dnN0YWNrW3l5c3BdKVswXSB9O1xuICAgIGJyZWFrO1xuXG5jYXNlIDIwOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgY3NzX3ZhbHVlIDogUkVTICovXG5cbiAgICB0aGlzLiQgPSB7IHR5cGU6ICdSZXNvbHV0aW9uVmFsdWUnLCB2YWx1ZTogcGFyc2VGbG9hdCh5eXZzdGFja1t5eXNwXSksIHVuaXQ6IC9bYS16XSsvLmV4ZWMoeXl2c3RhY2tbeXlzcF0pWzBdIH07XG4gICAgYnJlYWs7XG5cbmNhc2UgMjE6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjc3NfdmFsdWUgOiBFTVMgKi9cblxuICAgIHRoaXMuJCA9IHsgdHlwZTogJ0VtVmFsdWUnLCB2YWx1ZTogcGFyc2VGbG9hdCh5eXZzdGFja1t5eXNwXSksIHVuaXQ6ICdlbScgfTtcbiAgICBicmVhaztcblxuY2FzZSAyMjpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNzc192YWx1ZSA6IEVYUyAqL1xuXG4gICAgdGhpcy4kID0geyB0eXBlOiAnRXhWYWx1ZScsIHZhbHVlOiBwYXJzZUZsb2F0KHl5dnN0YWNrW3l5c3BdKSwgdW5pdDogJ2V4JyB9O1xuICAgIGJyZWFrO1xuXG5jYXNlIDIzOlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgY3NzX3ZhbHVlIDogQ0hTICovXG5cbiAgICB0aGlzLiQgPSB7IHR5cGU6ICdDaFZhbHVlJywgdmFsdWU6IHBhcnNlRmxvYXQoeXl2c3RhY2tbeXlzcF0pLCB1bml0OiAnY2gnIH07XG4gICAgYnJlYWs7XG5cbmNhc2UgMjQ6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjc3NfdmFsdWUgOiBSRU1TICovXG5cbiAgICB0aGlzLiQgPSB7IHR5cGU6ICdSZW1WYWx1ZScsIHZhbHVlOiBwYXJzZUZsb2F0KHl5dnN0YWNrW3l5c3BdKSwgdW5pdDogJ3JlbScgfTtcbiAgICBicmVhaztcblxuY2FzZSAyNTpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNzc192YWx1ZSA6IFZIUyAqL1xuXG4gICAgdGhpcy4kID0geyB0eXBlOiAnVmhWYWx1ZScsIHZhbHVlOiBwYXJzZUZsb2F0KHl5dnN0YWNrW3l5c3BdKSwgdW5pdDogJ3ZoJyB9O1xuICAgIGJyZWFrO1xuXG5jYXNlIDI2OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgY3NzX3ZhbHVlIDogVldTICovXG5cbiAgICB0aGlzLiQgPSB7IHR5cGU6ICdWd1ZhbHVlJywgdmFsdWU6IHBhcnNlRmxvYXQoeXl2c3RhY2tbeXlzcF0pLCB1bml0OiAndncnIH07XG4gICAgYnJlYWs7XG5cbmNhc2UgMjc6XG4gICAgLyohIFByb2R1Y3Rpb246OiAgICBjc3NfdmFsdWUgOiBWTUlOUyAqL1xuXG4gICAgdGhpcy4kID0geyB0eXBlOiAnVm1pblZhbHVlJywgdmFsdWU6IHBhcnNlRmxvYXQoeXl2c3RhY2tbeXlzcF0pLCB1bml0OiAndm1pbicgfTtcbiAgICBicmVhaztcblxuY2FzZSAyODpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNzc192YWx1ZSA6IFZNQVhTICovXG5cbiAgICB0aGlzLiQgPSB7IHR5cGU6ICdWbWF4VmFsdWUnLCB2YWx1ZTogcGFyc2VGbG9hdCh5eXZzdGFja1t5eXNwXSksIHVuaXQ6ICd2bWF4JyB9O1xuICAgIGJyZWFrO1xuXG5jYXNlIDI5OlxuICAgIC8qISBQcm9kdWN0aW9uOjogICAgY3NzX3ZhbHVlIDogUEVSQ0VOVEFHRSAqL1xuXG4gICAgdGhpcy4kID0geyB0eXBlOiAnUGVyY2VudGFnZVZhbHVlJywgdmFsdWU6IHBhcnNlRmxvYXQoeXl2c3RhY2tbeXlzcF0pLCB1bml0OiAnJScgfTtcbiAgICBicmVhaztcblxuY2FzZSAzMDpcbiAgICAvKiEgUHJvZHVjdGlvbjo6ICAgIGNzc192YWx1ZSA6IFNVQiBjc3NfdmFsdWUgKi9cblxuICAgIHZhciBwcmV2ID0geXl2c3RhY2tbeXlzcF07IHByZXYudmFsdWUgKj0gLTE7IHRoaXMuJCA9IHByZXY7XG4gICAgYnJlYWs7XG5cbn1cbn0sXG50YWJsZTogYnQoe1xuICBsZW46IHUoW1xuICAyNCxcbiAgMSxcbiAgNSxcbiAgMjMsXG4gIDEsXG4gIDE4LFxuICBzLFxuICBbMCwgM10sXG4gIDEsXG4gIHMsXG4gIFswLCAxNl0sXG4gIHMsXG4gIFsyMywgNF0sXG4gIGMsXG4gIFsyOCwgM10sXG4gIDAsXG4gIDAsXG4gIDE2LFxuICAxLFxuICA2LFxuICA2LFxuICBzLFxuICBbMCwgM10sXG4gIDUsXG4gIDEsXG4gIDIsXG4gIGMsXG4gIFszNywgM10sXG4gIGMsXG4gIFsyMCwgM10sXG4gIDUsXG4gIDAsXG4gIDBcbl0pLFxuICBzeW1ib2w6IHUoW1xuICA0LFxuICA3LFxuICA5LFxuICAxMSxcbiAgMTIsXG4gIHMsXG4gIFsxNSwgMTksIDFdLFxuICAxLFxuICAxLFxuICBzLFxuICBbMywgNCwgMV0sXG4gIGMsXG4gIFszMCwgMTldLFxuICBjLFxuICBbMjksIDRdLFxuICA3LFxuICA0LFxuICAxMCxcbiAgMTEsXG4gIGMsXG4gIFsyMiwgMTRdLFxuICBjLFxuICBbMTksIDNdLFxuICBjLFxuICBbNDMsIDIyXSxcbiAgYyxcbiAgWzIzLCA2OV0sXG4gIGMsXG4gIFsxMzksIDRdLFxuICA4LFxuICBjLFxuICBbNTEsIDI0XSxcbiAgNCxcbiAgYyxcbiAgWzEzOCwgMTVdLFxuICAxMyxcbiAgYyxcbiAgWzE4NiwgNV0sXG4gIDgsXG4gIGMsXG4gIFs2LCA2XSxcbiAgYyxcbiAgWzUsIDVdLFxuICA5LFxuICA4LFxuICAxNCxcbiAgYyxcbiAgWzE1OSwgNDddLFxuICBjLFxuICBbNjAsIDEwXVxuXSksXG4gIHR5cGU6IHUoW1xuICBzLFxuICBbMiwgMTldLFxuICBzLFxuICBbMCwgNV0sXG4gIDEsXG4gIHMsXG4gIFsyLCAyNF0sXG4gIHMsXG4gIFswLCA0XSxcbiAgYyxcbiAgWzIyLCAxOV0sXG4gIGMsXG4gIFs0MywgNDJdLFxuICBjLFxuICBbMjMsIDcwXSxcbiAgYyxcbiAgWzI4LCAyNV0sXG4gIGMsXG4gIFs0NSwgMjVdLFxuICBjLFxuICBbMTEzLCA1NF1cbl0pLFxuICBzdGF0ZTogdShbXG4gIDEsXG4gIDIsXG4gIDgsXG4gIDYsXG4gIDcsXG4gIDMwLFxuICBjLFxuICBbNCwgM10sXG4gIDMzLFxuICAzNyxcbiAgYyxcbiAgWzUsIDNdLFxuICAzOCxcbiAgYyxcbiAgWzQsIDNdLFxuICAzOSxcbiAgYyxcbiAgWzQsIDNdLFxuICA0MCxcbiAgYyxcbiAgWzQsIDNdLFxuICA0MixcbiAgYyxcbiAgWzIxLCA0XSxcbiAgNTAsXG4gIGMsXG4gIFs1LCAzXSxcbiAgNTEsXG4gIGMsXG4gIFs0LCAzXVxuXSksXG4gIG1vZGU6IHUoW1xuICBzLFxuICBbMSwgMTc5XSxcbiAgcyxcbiAgWzIsIDNdLFxuICBjLFxuICBbNSwgNV0sXG4gIGMsXG4gIFs2LCA0XSxcbiAgcyxcbiAgWzEsIDU3XVxuXSksXG4gIGdvdG86IHUoW1xuICA1LFxuICAzLFxuICA0LFxuICAyNCxcbiAgcyxcbiAgWzksIDE1LCAxXSxcbiAgcyxcbiAgWzI1LCA1LCAxXSxcbiAgYyxcbiAgWzI0LCAxOV0sXG4gIDMxLFxuICAzNSxcbiAgMzIsXG4gIDM0LFxuICBjLFxuICBbMTgsIDE0XSxcbiAgMzYsXG4gIGMsXG4gIFszOCwgMTldLFxuICBjLFxuICBbMTksIDU3XSxcbiAgYyxcbiAgWzExOCwgNF0sXG4gIDQxLFxuICBjLFxuICBbMjQsIDE5XSxcbiAgNDMsXG4gIDM1LFxuICBjLFxuICBbMTYsIDE0XSxcbiAgNDQsXG4gIHMsXG4gIFsyLCAzXSxcbiAgMjgsXG4gIDI5LFxuICAyLFxuICBzLFxuICBbMywgM10sXG4gIDI4LFxuICAyOSxcbiAgMyxcbiAgYyxcbiAgWzUzLCA0XSxcbiAgcyxcbiAgWzQ1LCA1LCAxXSxcbiAgYyxcbiAgWzEwMCwgNDJdLFxuICA1MixcbiAgYyxcbiAgWzUsIDRdLFxuICA1M1xuXSlcbn0pLFxuZGVmYXVsdEFjdGlvbnM6IGJkYSh7XG4gIGlkeDogdShbXG4gIDYsXG4gIDcsXG4gIDgsXG4gIHMsXG4gIFsxMCwgMTYsIDFdLFxuICAzMyxcbiAgMzQsXG4gIDM5LFxuICA0MCxcbiAgNDEsXG4gIDQ1LFxuICA0NyxcbiAgNTIsXG4gIDUzXG5dKSxcbiAgZ290bzogdShbXG4gIDksXG4gIDEwLFxuICAxMSxcbiAgcyxcbiAgWzE2LCAxNCwgMV0sXG4gIDEyLFxuICAxLFxuICAzMCxcbiAgMTMsXG4gIHMsXG4gIFs0LCA0LCAxXSxcbiAgMTQsXG4gIDE1LFxuICA4XG5dKVxufSksXG5wYXJzZUVycm9yOiBmdW5jdGlvbiBwYXJzZUVycm9yKHN0ciwgaGFzaCwgRXhjZXB0aW9uQ2xhc3MpIHtcbiAgICBpZiAoaGFzaC5yZWNvdmVyYWJsZSkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2Uoc3RyKTtcbiAgICAgICAgfVxuICAgICAgICBoYXNoLmRlc3Ryb3koKTsgICAgICAgICAgICAgLy8gZGVzdHJveS4uLiB3ZWxsLCAqYWxtb3N0KiFcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2Uoc3RyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUV4Y2VwdGlvbkNsYXNzKSB7XG4gICAgICAgICAgICBFeGNlcHRpb25DbGFzcyA9IHRoaXMuSmlzb25QYXJzZXJFcnJvcjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uQ2xhc3Moc3RyLCBoYXNoKTtcbiAgICB9XG59LFxucGFyc2U6IGZ1bmN0aW9uIHBhcnNlKGlucHV0KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBzdGFjayA9IG5ldyBBcnJheSgxMjgpOyAgICAgICAgIC8vIHRva2VuIHN0YWNrOiBzdG9yZXMgdG9rZW4gd2hpY2ggbGVhZHMgdG8gc3RhdGUgYXQgdGhlIHNhbWUgaW5kZXggKGNvbHVtbiBzdG9yYWdlKVxuICAgIHZhciBzc3RhY2sgPSBuZXcgQXJyYXkoMTI4KTsgICAgICAgIC8vIHN0YXRlIHN0YWNrOiBzdG9yZXMgc3RhdGVzIChjb2x1bW4gc3RvcmFnZSlcblxuICAgIHZhciB2c3RhY2sgPSBuZXcgQXJyYXkoMTI4KTsgICAgICAgIC8vIHNlbWFudGljIHZhbHVlIHN0YWNrXG5cbiAgICB2YXIgdGFibGUgPSB0aGlzLnRhYmxlO1xuICAgIHZhciBzcCA9IDA7ICAgICAgICAgICAgICAgICAgICAgICAgIC8vICdzdGFjayBwb2ludGVyJzogaW5kZXggaW50byB0aGUgc3RhY2tzXG5cblxuICAgIFxuXG5cbiAgICB2YXIgc3ltYm9sID0gMDtcblxuXG5cbiAgICB2YXIgVEVSUk9SID0gdGhpcy5URVJST1I7XG4gICAgdmFyIEVPRiA9IHRoaXMuRU9GO1xuICAgIHZhciBFUlJPUl9SRUNPVkVSWV9UT0tFTl9ESVNDQVJEX0NPVU5UID0gKHRoaXMub3B0aW9ucy5lcnJvclJlY292ZXJ5VG9rZW5EaXNjYXJkQ291bnQgfCAwKSB8fCAzO1xuICAgIHZhciBOT19BQ1RJT04gPSBbMCwgNTQgLyogPT09IHRhYmxlLmxlbmd0aCA6OiBlbnN1cmVzIHRoYXQgYW55b25lIHVzaW5nIHRoaXMgbmV3IHN0YXRlIHdpbGwgZmFpbCBkcmFtYXRpY2FsbHkhICovXTtcblxuICAgIHZhciBsZXhlcjtcbiAgICBpZiAodGhpcy5fX2xleGVyX18pIHtcbiAgICAgICAgbGV4ZXIgPSB0aGlzLl9fbGV4ZXJfXztcbiAgICB9IGVsc2Uge1xuICAgICAgICBsZXhlciA9IHRoaXMuX19sZXhlcl9fID0gT2JqZWN0LmNyZWF0ZSh0aGlzLmxleGVyKTtcbiAgICB9XG5cbiAgICB2YXIgc2hhcmVkU3RhdGVfeXkgPSB7XG4gICAgICAgIHBhcnNlRXJyb3I6IHVuZGVmaW5lZCxcbiAgICAgICAgcXVvdGVOYW1lOiB1bmRlZmluZWQsXG4gICAgICAgIGxleGVyOiB1bmRlZmluZWQsXG4gICAgICAgIHBhcnNlcjogdW5kZWZpbmVkLFxuICAgICAgICBwcmVfcGFyc2U6IHVuZGVmaW5lZCxcbiAgICAgICAgcG9zdF9wYXJzZTogdW5kZWZpbmVkLFxuICAgICAgICBwcmVfbGV4OiB1bmRlZmluZWQsXG4gICAgICAgIHBvc3RfbGV4OiB1bmRlZmluZWQgICAgICAvLyBXQVJOSU5HOiBtdXN0IGJlIHdyaXR0ZW4gdGhpcyB3YXkgZm9yIHRoZSBjb2RlIGV4cGFuZGVycyB0byB3b3JrIGNvcnJlY3RseSBpbiBib3RoIEVTNSBhbmQgRVM2IG1vZGVzIVxuICAgIH07XG5cbiAgICB2YXIgQVNTRVJUO1xuICAgIGlmICh0eXBlb2YgYXNzZXJ0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIEFTU0VSVCA9IGZ1bmN0aW9uIEppc29uQXNzZXJ0KGNvbmQsIG1zZykge1xuICAgICAgICAgICAgaWYgKCFjb25kKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NlcnRpb24gZmFpbGVkOiAnICsgKG1zZyB8fCAnKioqJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIEFTU0VSVCA9IGFzc2VydDtcbiAgICB9XG5cbiAgICB0aGlzLnl5R2V0U2hhcmVkU3RhdGUgPSBmdW5jdGlvbiB5eUdldFNoYXJlZFN0YXRlKCkge1xuICAgICAgICByZXR1cm4gc2hhcmVkU3RhdGVfeXk7XG4gICAgfTtcblxuXG5cblxuXG5cblxuXG4gICAgZnVuY3Rpb24gc2hhbGxvd19jb3B5X25vY2xvYmJlcihkc3QsIHNyYykge1xuICAgICAgICBmb3IgKHZhciBrIGluIHNyYykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkc3Rba10gPT09ICd1bmRlZmluZWQnICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzcmMsIGspKSB7XG4gICAgICAgICAgICAgICAgZHN0W2tdID0gc3JjW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gY29weSBzdGF0ZVxuICAgIHNoYWxsb3dfY29weV9ub2Nsb2JiZXIoc2hhcmVkU3RhdGVfeXksIHRoaXMueXkpO1xuXG4gICAgc2hhcmVkU3RhdGVfeXkubGV4ZXIgPSBsZXhlcjtcbiAgICBzaGFyZWRTdGF0ZV95eS5wYXJzZXIgPSB0aGlzO1xuXG5cblxuXG5cblxuICAgIC8vIERvZXMgdGhlIHNoYXJlZCBzdGF0ZSBvdmVycmlkZSB0aGUgZGVmYXVsdCBgcGFyc2VFcnJvcmAgdGhhdCBhbHJlYWR5IGNvbWVzIHdpdGggdGhpcyBpbnN0YW5jZT9cbiAgICBpZiAodHlwZW9mIHNoYXJlZFN0YXRlX3l5LnBhcnNlRXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5wYXJzZUVycm9yID0gZnVuY3Rpb24gcGFyc2VFcnJvckFsdChzdHIsIGhhc2gsIEV4Y2VwdGlvbkNsYXNzKSB7XG4gICAgICAgICAgICBpZiAoIUV4Y2VwdGlvbkNsYXNzKSB7XG4gICAgICAgICAgICAgICAgRXhjZXB0aW9uQ2xhc3MgPSB0aGlzLkppc29uUGFyc2VyRXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2hhcmVkU3RhdGVfeXkucGFyc2VFcnJvci5jYWxsKHRoaXMsIHN0ciwgaGFzaCwgRXhjZXB0aW9uQ2xhc3MpO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucGFyc2VFcnJvciA9IHRoaXMub3JpZ2luYWxQYXJzZUVycm9yO1xuICAgIH1cblxuICAgIC8vIERvZXMgdGhlIHNoYXJlZCBzdGF0ZSBvdmVycmlkZSB0aGUgZGVmYXVsdCBgcXVvdGVOYW1lYCB0aGF0IGFscmVhZHkgY29tZXMgd2l0aCB0aGlzIGluc3RhbmNlP1xuICAgIGlmICh0eXBlb2Ygc2hhcmVkU3RhdGVfeXkucXVvdGVOYW1lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucXVvdGVOYW1lID0gZnVuY3Rpb24gcXVvdGVOYW1lQWx0KGlkX3N0cikge1xuICAgICAgICAgICAgcmV0dXJuIHNoYXJlZFN0YXRlX3l5LnF1b3RlTmFtZS5jYWxsKHRoaXMsIGlkX3N0cik7XG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5xdW90ZU5hbWUgPSB0aGlzLm9yaWdpbmFsUXVvdGVOYW1lO1xuICAgIH1cblxuICAgIC8vIHNldCB1cCB0aGUgY2xlYW51cCBmdW5jdGlvbjsgbWFrZSBpdCBhbiBBUEkgc28gdGhhdCBleHRlcm5hbCBjb2RlIGNhbiByZS11c2UgdGhpcyBvbmUgaW4gY2FzZSBvZlxuICAgIC8vIGNhbGFtaXRpZXMgb3Igd2hlbiB0aGUgYCVvcHRpb25zIG5vLXRyeS1jYXRjaGAgb3B0aW9uIGhhcyBiZWVuIHNwZWNpZmllZCBmb3IgdGhlIGdyYW1tYXIsIGluIHdoaWNoXG4gICAgLy8gY2FzZSB0aGlzIHBhcnNlKCkgQVBJIG1ldGhvZCBkb2Vzbid0IGNvbWUgd2l0aCBhIGBmaW5hbGx5IHsgLi4uIH1gIGJsb2NrIGFueSBtb3JlIVxuICAgIC8vXG4gICAgLy8gTk9URTogYXMgdGhpcyBBUEkgdXNlcyBwYXJzZSgpIGFzIGEgY2xvc3VyZSwgaXQgTVVTVCBiZSBzZXQgYWdhaW4gb24gZXZlcnkgcGFyc2UoKSBpbnZvY2F0aW9uLFxuICAgIC8vICAgICAgIG9yIGVsc2UgeW91ciBgc2hhcmVkU3RhdGVgLCBldGMuIHJlZmVyZW5jZXMgd2lsbCBiZSAqd3JvbmcqIVxuICAgIHRoaXMuY2xlYW51cEFmdGVyUGFyc2UgPSBmdW5jdGlvbiBwYXJzZXJfY2xlYW51cEFmdGVyUGFyc2UocmVzdWx0VmFsdWUsIGludm9rZV9wb3N0X21ldGhvZHMsIGRvX25vdF9udWtlX2Vycm9yaW5mb3MpIHtcbiAgICAgICAgdmFyIHJ2O1xuXG4gICAgICAgIGlmIChpbnZva2VfcG9zdF9tZXRob2RzKSB7XG4gICAgICAgICAgICB2YXIgaGFzaDtcblxuICAgICAgICAgICAgaWYgKHNoYXJlZFN0YXRlX3l5LnBvc3RfcGFyc2UgfHwgdGhpcy5wb3N0X3BhcnNlKSB7XG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIGFuIGVycm9yIGhhc2ggaW5mbyBpbnN0YW5jZTogd2UgcmUtdXNlIHRoaXMgQVBJIGluIGEgKipub24tZXJyb3Igc2l0dWF0aW9uKipcbiAgICAgICAgICAgICAgICAvLyBhcyB0aGlzIG9uZSBkZWxpdmVycyBhbGwgcGFyc2VyIGludGVybmFscyByZWFkeSBmb3IgYWNjZXNzIGJ5IHVzZXJsYW5kIGNvZGUuXG4gICAgICAgICAgICAgICAgaGFzaCA9IHRoaXMuY29uc3RydWN0UGFyc2VFcnJvckluZm8obnVsbCAvKiBubyBlcnJvciEgKi8sIG51bGwgLyogbm8gZXhjZXB0aW9uISAqLywgbnVsbCwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2hhcmVkU3RhdGVfeXkucG9zdF9wYXJzZSkge1xuICAgICAgICAgICAgICAgIHJ2ID0gc2hhcmVkU3RhdGVfeXkucG9zdF9wYXJzZS5jYWxsKHRoaXMsIHNoYXJlZFN0YXRlX3l5LCByZXN1bHRWYWx1ZSwgaGFzaCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBydiAhPT0gJ3VuZGVmaW5lZCcpIHJlc3VsdFZhbHVlID0gcnY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wb3N0X3BhcnNlKSB7XG4gICAgICAgICAgICAgICAgcnYgPSB0aGlzLnBvc3RfcGFyc2UuY2FsbCh0aGlzLCBzaGFyZWRTdGF0ZV95eSwgcmVzdWx0VmFsdWUsIGhhc2gpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcnYgIT09ICd1bmRlZmluZWQnKSByZXN1bHRWYWx1ZSA9IHJ2O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjbGVhbnVwOlxuICAgICAgICAgICAgaWYgKGhhc2ggJiYgaGFzaC5kZXN0cm95KSB7XG4gICAgICAgICAgICAgICAgaGFzaC5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fX3JlZW50cmFudF9jYWxsX2RlcHRoID4gMSkgcmV0dXJuIHJlc3VsdFZhbHVlOyAgICAgICAgLy8gZG8gbm90ICh5ZXQpIGtpbGwgdGhlIHNoYXJlZFN0YXRlIHdoZW4gdGhpcyBpcyBhIHJlZW50cmFudCBydW4uXG5cbiAgICAgICAgLy8gY2xlYW4gdXAgdGhlIGxpbmdlcmluZyBsZXhlciBzdHJ1Y3R1cmVzIGFzIHdlbGw6XG4gICAgICAgIGlmIChsZXhlci5jbGVhbnVwQWZ0ZXJMZXgpIHtcbiAgICAgICAgICAgIGxleGVyLmNsZWFudXBBZnRlckxleChkb19ub3RfbnVrZV9lcnJvcmluZm9zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHByZXZlbnQgbGluZ2VyaW5nIGNpcmN1bGFyIHJlZmVyZW5jZXMgZnJvbSBjYXVzaW5nIG1lbW9yeSBsZWFrczpcbiAgICAgICAgaWYgKHNoYXJlZFN0YXRlX3l5KSB7XG4gICAgICAgICAgICBzaGFyZWRTdGF0ZV95eS5sZXhlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHNoYXJlZFN0YXRlX3l5LnBhcnNlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChsZXhlci55eSA9PT0gc2hhcmVkU3RhdGVfeXkpIHtcbiAgICAgICAgICAgICAgICBsZXhlci55eSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzaGFyZWRTdGF0ZV95eSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5wYXJzZUVycm9yID0gdGhpcy5vcmlnaW5hbFBhcnNlRXJyb3I7XG4gICAgICAgIHRoaXMucXVvdGVOYW1lID0gdGhpcy5vcmlnaW5hbFF1b3RlTmFtZTtcblxuICAgICAgICAvLyBudWtlIHRoZSB2c3RhY2tbXSBhcnJheSBhdCBsZWFzdCBhcyB0aGF0IG9uZSB3aWxsIHN0aWxsIHJlZmVyZW5jZSBvYnNvbGV0ZWQgdXNlciB2YWx1ZXMuXG4gICAgICAgIC8vIFRvIGJlIHNhZmUsIHdlIG51a2UgdGhlIG90aGVyIGludGVybmFsIHN0YWNrIGNvbHVtbnMgYXMgd2VsbC4uLlxuICAgICAgICBzdGFjay5sZW5ndGggPSAwOyAgICAgICAgICAgICAgIC8vIGZhc3Rlc3Qgd2F5IHRvIG51a2UgYW4gYXJyYXkgd2l0aG91dCBvdmVybHkgYm90aGVyaW5nIHRoZSBHQ1xuICAgICAgICBzc3RhY2subGVuZ3RoID0gMDtcblxuICAgICAgICB2c3RhY2subGVuZ3RoID0gMDtcbiAgICAgICAgc3AgPSAwO1xuXG4gICAgICAgIC8vIG51a2UgdGhlIGVycm9yIGhhc2ggaW5mbyBpbnN0YW5jZXMgY3JlYXRlZCBkdXJpbmcgdGhpcyBydW4uXG4gICAgICAgIC8vIFVzZXJsYW5kIGNvZGUgbXVzdCBDT1BZIGFueSBkYXRhL3JlZmVyZW5jZXNcbiAgICAgICAgLy8gaW4gdGhlIGVycm9yIGhhc2ggaW5zdGFuY2UocykgaXQgaXMgbW9yZSBwZXJtYW5lbnRseSBpbnRlcmVzdGVkIGluLlxuICAgICAgICBpZiAoIWRvX25vdF9udWtlX2Vycm9yaW5mb3MpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9fZXJyb3JfaW5mb3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSB0aGlzLl9fZXJyb3JfaW5mb3NbaV07XG4gICAgICAgICAgICAgICAgaWYgKGVsICYmIHR5cGVvZiBlbC5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9fZXJyb3JfaW5mb3MubGVuZ3RoID0gMDtcblxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0VmFsdWU7XG4gICAgfTtcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4gICAgLy8gTk9URTogYXMgdGhpcyBBUEkgdXNlcyBwYXJzZSgpIGFzIGEgY2xvc3VyZSwgaXQgTVVTVCBiZSBzZXQgYWdhaW4gb24gZXZlcnkgcGFyc2UoKSBpbnZvY2F0aW9uLFxuICAgIC8vICAgICAgIG9yIGVsc2UgeW91ciBgbGV4ZXJgLCBgc2hhcmVkU3RhdGVgLCBldGMuIHJlZmVyZW5jZXMgd2lsbCBiZSAqd3JvbmcqIVxuICAgIHRoaXMuY29uc3RydWN0UGFyc2VFcnJvckluZm8gPSBmdW5jdGlvbiBwYXJzZXJfY29uc3RydWN0UGFyc2VFcnJvckluZm8obXNnLCBleCwgZXhwZWN0ZWQsIHJlY292ZXJhYmxlKSB7XG4gICAgICAgIHZhciBwZWkgPSB7XG4gICAgICAgICAgICBlcnJTdHI6IG1zZyxcbiAgICAgICAgICAgIGV4Y2VwdGlvbjogZXgsXG4gICAgICAgICAgICB0ZXh0OiBsZXhlci5tYXRjaCxcbiAgICAgICAgICAgIHZhbHVlOiBsZXhlci55eXRleHQsXG4gICAgICAgICAgICB0b2tlbjogdGhpcy5kZXNjcmliZVN5bWJvbChzeW1ib2wpIHx8IHN5bWJvbCxcbiAgICAgICAgICAgIHRva2VuX2lkOiBzeW1ib2wsXG4gICAgICAgICAgICBsaW5lOiBsZXhlci55eWxpbmVubyxcblxuICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgICAgICAgcmVjb3ZlcmFibGU6IHJlY292ZXJhYmxlLFxuICAgICAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgICAgICBuZXdfc3RhdGU6IG5ld1N0YXRlLFxuICAgICAgICAgICAgc3ltYm9sX3N0YWNrOiBzdGFjayxcbiAgICAgICAgICAgIHN0YXRlX3N0YWNrOiBzc3RhY2ssXG4gICAgICAgICAgICB2YWx1ZV9zdGFjazogdnN0YWNrLFxuXG4gICAgICAgICAgICBzdGFja19wb2ludGVyOiBzcCxcbiAgICAgICAgICAgIHl5OiBzaGFyZWRTdGF0ZV95eSxcbiAgICAgICAgICAgIGxleGVyOiBsZXhlcixcbiAgICAgICAgICAgIHBhcnNlcjogdGhpcyxcblxuICAgICAgICAgICAgLy8gYW5kIG1ha2Ugc3VyZSB0aGUgZXJyb3IgaW5mbyBkb2Vzbid0IHN0YXkgZHVlIHRvIHBvdGVudGlhbFxuICAgICAgICAgICAgLy8gcmVmIGN5Y2xlIHZpYSB1c2VybGFuZCBjb2RlIG1hbmlwdWxhdGlvbnMuXG4gICAgICAgICAgICAvLyBUaGVzZSB3b3VsZCBvdGhlcndpc2UgYWxsIGJlIG1lbW9yeSBsZWFrIG9wcG9ydHVuaXRpZXMhXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gTm90ZSB0aGF0IG9ubHkgYXJyYXkgYW5kIG9iamVjdCByZWZlcmVuY2VzIGFyZSBudWtlZCBhcyB0aG9zZVxuICAgICAgICAgICAgLy8gY29uc3RpdHV0ZSB0aGUgc2V0IG9mIGVsZW1lbnRzIHdoaWNoIGNhbiBwcm9kdWNlIGEgY3ljbGljIHJlZi5cbiAgICAgICAgICAgIC8vIFRoZSByZXN0IG9mIHRoZSBtZW1iZXJzIGlzIGtlcHQgaW50YWN0IGFzIHRoZXkgYXJlIGhhcm1sZXNzLlxuICAgICAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJ1Y3RQYXJzZUVycm9ySW5mbygpIHtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgY3ljbGljIHJlZmVyZW5jZXMgYWRkZWQgdG8gZXJyb3IgaW5mbzpcbiAgICAgICAgICAgICAgICAvLyBpbmZvLnl5ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvLyBpbmZvLmxleGVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvLyBpbmZvLnZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvLyBpbmZvLnZhbHVlX3N0YWNrID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvLyAuLi5cbiAgICAgICAgICAgICAgICB2YXIgcmVjID0gISF0aGlzLnJlY292ZXJhYmxlO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KGtleSkgJiYgdHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJlY292ZXJhYmxlID0gcmVjO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyB0cmFjayB0aGlzIGluc3RhbmNlIHNvIHdlIGNhbiBgZGVzdHJveSgpYCBpdCBvbmNlIHdlIGRlZW0gaXQgc3VwZXJmbHVvdXMgYW5kIHJlYWR5IGZvciBnYXJiYWdlIGNvbGxlY3Rpb24hXG4gICAgICAgIHRoaXMuX19lcnJvcl9pbmZvcy5wdXNoKHBlaSk7XG4gICAgICAgIHJldHVybiBwZWk7XG4gICAgfTtcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuICAgIGZ1bmN0aW9uIGdldE5vblRlcm1pbmFsRnJvbUNvZGUoc3ltYm9sKSB7XG4gICAgICAgIHZhciB0b2tlbk5hbWUgPSBzZWxmLmdldFN5bWJvbE5hbWUoc3ltYm9sKTtcbiAgICAgICAgaWYgKCF0b2tlbk5hbWUpIHtcbiAgICAgICAgICAgIHRva2VuTmFtZSA9IHN5bWJvbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9rZW5OYW1lO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gc3RkTGV4KCkge1xuICAgICAgICB2YXIgdG9rZW4gPSBsZXhlci5sZXgoKTtcbiAgICAgICAgLy8gaWYgdG9rZW4gaXNuJ3QgaXRzIG51bWVyaWMgdmFsdWUsIGNvbnZlcnRcbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRva2VuID0gc2VsZi5zeW1ib2xzX1t0b2tlbl0gfHwgdG9rZW47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG9rZW4gfHwgRU9GO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZhc3RMZXgoKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IGxleGVyLmZhc3RMZXgoKTtcbiAgICAgICAgLy8gaWYgdG9rZW4gaXNuJ3QgaXRzIG51bWVyaWMgdmFsdWUsIGNvbnZlcnRcbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRva2VuID0gc2VsZi5zeW1ib2xzX1t0b2tlbl0gfHwgdG9rZW47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG9rZW4gfHwgRU9GO1xuICAgIH1cblxuICAgIHZhciBsZXggPSBzdGRMZXg7XG5cblxuICAgIHZhciBzdGF0ZSwgYWN0aW9uLCByLCB0O1xuICAgIHZhciB5eXZhbCA9IHtcbiAgICAgICAgJDogdHJ1ZSxcbiAgICAgICAgXyQ6IHVuZGVmaW5lZCxcbiAgICAgICAgeXk6IHNoYXJlZFN0YXRlX3l5XG4gICAgfTtcbiAgICB2YXIgcDtcbiAgICB2YXIgeXlydWxlbGVuO1xuICAgIHZhciB0aGlzX3Byb2R1Y3Rpb247XG4gICAgdmFyIG5ld1N0YXRlO1xuICAgIHZhciByZXR2YWwgPSBmYWxzZTtcblxuXG4gICAgdHJ5IHtcbiAgICAgICAgdGhpcy5fX3JlZW50cmFudF9jYWxsX2RlcHRoKys7XG5cbiAgICAgICAgbGV4ZXIuc2V0SW5wdXQoaW5wdXQsIHNoYXJlZFN0YXRlX3l5KTtcblxuICAgICAgICAvLyBOT1RFOiB3ZSAqYXNzdW1lKiBubyBsZXhlciBwcmUvcG9zdCBoYW5kbGVycyBhcmUgc2V0IHVwICphZnRlciogXG4gICAgICAgIC8vIHRoaXMgaW5pdGlhbCBgc2V0SW5wdXQoKWAgY2FsbDogaGVuY2Ugd2UgY2FuIG5vdyBjaGVjayBhbmQgZGVjaWRlXG4gICAgICAgIC8vIHdoZXRoZXIgd2UnbGwgZ28gd2l0aCB0aGUgc3RhbmRhcmQsIHNsb3dlciwgbGV4KCkgQVBJIG9yIHRoZVxuICAgICAgICAvLyBgZmFzdF9sZXgoKWAgb25lOlxuICAgICAgICBpZiAodHlwZW9mIGxleGVyLmNhbklVc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBsZXhlckluZm8gPSBsZXhlci5jYW5JVXNlKCk7XG4gICAgICAgICAgICBpZiAobGV4ZXJJbmZvLmZhc3RMZXggJiYgdHlwZW9mIGZhc3RMZXggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBsZXggPSBmYXN0TGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IFxuXG5cblxuICAgICAgICB2c3RhY2tbc3BdID0gbnVsbDtcbiAgICAgICAgc3N0YWNrW3NwXSA9IDA7XG4gICAgICAgIHN0YWNrW3NwXSA9IDA7XG4gICAgICAgICsrc3A7XG5cblxuXG5cblxuICAgICAgICBpZiAodGhpcy5wcmVfcGFyc2UpIHtcbiAgICAgICAgICAgIHRoaXMucHJlX3BhcnNlLmNhbGwodGhpcywgc2hhcmVkU3RhdGVfeXkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaGFyZWRTdGF0ZV95eS5wcmVfcGFyc2UpIHtcbiAgICAgICAgICAgIHNoYXJlZFN0YXRlX3l5LnByZV9wYXJzZS5jYWxsKHRoaXMsIHNoYXJlZFN0YXRlX3l5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld1N0YXRlID0gc3N0YWNrW3NwIC0gMV07XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIC8vIHJldHJpZXZlIHN0YXRlIG51bWJlciBmcm9tIHRvcCBvZiBzdGFja1xuICAgICAgICAgICAgc3RhdGUgPSBuZXdTdGF0ZTsgICAgICAgICAgICAgICAvLyBzc3RhY2tbc3AgLSAxXTtcblxuICAgICAgICAgICAgLy8gdXNlIGRlZmF1bHQgYWN0aW9ucyBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgIGlmICh0aGlzLmRlZmF1bHRBY3Rpb25zW3N0YXRlXSkge1xuICAgICAgICAgICAgICAgIGFjdGlvbiA9IDI7XG4gICAgICAgICAgICAgICAgbmV3U3RhdGUgPSB0aGlzLmRlZmF1bHRBY3Rpb25zW3N0YXRlXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHNpbmdsZSBgPT1gIGNvbmRpdGlvbiBiZWxvdyBjb3ZlcnMgYm90aCB0aGVzZSBgPT09YCBjb21wYXJpc29ucyBpbiBhIHNpbmdsZVxuICAgICAgICAgICAgICAgIC8vIG9wZXJhdGlvbjpcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vICAgICBpZiAoc3ltYm9sID09PSBudWxsIHx8IHR5cGVvZiBzeW1ib2wgPT09ICd1bmRlZmluZWQnKSAuLi5cbiAgICAgICAgICAgICAgICBpZiAoIXN5bWJvbCkge1xuICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcmVhZCBhY3Rpb24gZm9yIGN1cnJlbnQgc3RhdGUgYW5kIGZpcnN0IGlucHV0XG4gICAgICAgICAgICAgICAgdCA9ICh0YWJsZVtzdGF0ZV0gJiYgdGFibGVbc3RhdGVdW3N5bWJvbF0pIHx8IE5PX0FDVElPTjtcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IHRbMV07XG4gICAgICAgICAgICAgICAgYWN0aW9uID0gdFswXTtcblxuXG5cblxuXG5cblxuXG5cblxuXG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIHBhcnNlIGVycm9yXG4gICAgICAgICAgICAgICAgaWYgKCFhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVyclN0cjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVyclN5bWJvbERlc2NyID0gKHRoaXMuZGVzY3JpYmVTeW1ib2woc3ltYm9sKSB8fCBzeW1ib2wpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXhwZWN0ZWQgPSB0aGlzLmNvbGxlY3RfZXhwZWN0ZWRfdG9rZW5fc2V0KHN0YXRlKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBSZXBvcnQgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsZXhlci55eWxpbmVubyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyclN0ciA9ICdQYXJzZSBlcnJvciBvbiBsaW5lICcgKyAobGV4ZXIueXlsaW5lbm8gKyAxKSArICc6ICc7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJTdHIgPSAnUGFyc2UgZXJyb3I6ICc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsZXhlci5zaG93UG9zaXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyclN0ciArPSAnXFxuJyArIGxleGVyLnNob3dQb3NpdGlvbig3OSAtIDEwLCAxMCkgKyAnXFxuJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXhwZWN0ZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJTdHIgKz0gJ0V4cGVjdGluZyAnICsgZXhwZWN0ZWQuam9pbignLCAnKSArICcsIGdvdCB1bmV4cGVjdGVkICcgKyBlcnJTeW1ib2xEZXNjcjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyclN0ciArPSAnVW5leHBlY3RlZCAnICsgZXJyU3ltYm9sRGVzY3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgY2Fubm90IHJlY292ZXIgZnJvbSB0aGUgZXJyb3IhXG4gICAgICAgICAgICAgICAgICAgIHAgPSB0aGlzLmNvbnN0cnVjdFBhcnNlRXJyb3JJbmZvKGVyclN0ciwgbnVsbCwgZXhwZWN0ZWQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgciA9IHRoaXMucGFyc2VFcnJvcihwLmVyclN0ciwgcCwgdGhpcy5KaXNvblBhcnNlckVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgfVxuXG5cblxuXG5cblxuXG5cblxuXG4gICAgICAgICAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgICAgICAgLy8gY2F0Y2ggbWlzYy4gcGFyc2UgZmFpbHVyZXM6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIHRoaXMgc2hvdWxkbid0IGhhcHBlbiwgdW5sZXNzIHJlc29sdmUgZGVmYXVsdHMgYXJlIG9mZlxuICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBwID0gdGhpcy5jb25zdHJ1Y3RQYXJzZUVycm9ySW5mbygnUGFyc2UgRXJyb3I6IG11bHRpcGxlIGFjdGlvbnMgcG9zc2libGUgYXQgc3RhdGU6ICcgKyBzdGF0ZSArICcsIHRva2VuOiAnICsgc3ltYm9sLCBudWxsLCBudWxsLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHIgPSB0aGlzLnBhcnNlRXJyb3IocC5lcnJTdHIsIHAsIHRoaXMuSmlzb25QYXJzZXJFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IHI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEFub3RoZXIgY2FzZSBvZiBiZXR0ZXIgc2FmZSB0aGFuIHNvcnJ5OiBpbiBjYXNlIHN0YXRlIHRyYW5zaXRpb25zIGNvbWUgb3V0IG9mIGFub3RoZXIgZXJyb3IgcmVjb3ZlcnkgcHJvY2Vzc1xuICAgICAgICAgICAgICAgIC8vIG9yIGEgYnVnZ3kgTFVUIChMb29rVXAgVGFibGUpOlxuICAgICAgICAgICAgICAgIHAgPSB0aGlzLmNvbnN0cnVjdFBhcnNlRXJyb3JJbmZvKCdQYXJzaW5nIGhhbHRlZC4gTm8gdmlhYmxlIGVycm9yIHJlY292ZXJ5IGFwcHJvYWNoIGF2YWlsYWJsZSBkdWUgdG8gaW50ZXJuYWwgc3lzdGVtIGZhaWx1cmUuJywgbnVsbCwgbnVsbCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHIgPSB0aGlzLnBhcnNlRXJyb3IocC5lcnJTdHIsIHAsIHRoaXMuSmlzb25QYXJzZXJFcnJvcik7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSByO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgLy8gc2hpZnQ6XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgc3RhY2tbc3BdID0gc3ltYm9sO1xuICAgICAgICAgICAgICAgIHZzdGFja1tzcF0gPSBsZXhlci55eXRleHQ7XG5cbiAgICAgICAgICAgICAgICBzc3RhY2tbc3BdID0gbmV3U3RhdGU7IC8vIHB1c2ggc3RhdGVcblxuICAgICAgICAgICAgICAgICsrc3A7XG4gICAgICAgICAgICAgICAgc3ltYm9sID0gMDtcblxuXG5cblxuICAgICAgICAgICAgICAgIC8vIFBpY2sgdXAgdGhlIGxleGVyIGRldGFpbHMgZm9yIHRoZSBjdXJyZW50IHN5bWJvbCBhcyB0aGF0IG9uZSBpcyBub3QgJ2xvb2stYWhlYWQnIGFueSBtb3JlOlxuXG5cblxuXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIC8vIHJlZHVjZTpcbiAgICAgICAgICAgIGNhc2UgMjpcblxuXG5cbiAgICAgICAgICAgICAgICB0aGlzX3Byb2R1Y3Rpb24gPSB0aGlzLnByb2R1Y3Rpb25zX1tuZXdTdGF0ZSAtIDFdOyAgLy8gYHRoaXMucHJvZHVjdGlvbnNfW11gIGlzIHplcm8tYmFzZWQgaW5kZXhlZCB3aGlsZSBzdGF0ZXMgc3RhcnQgZnJvbSAxIHVwd2FyZHMuLi5cbiAgICAgICAgICAgICAgICB5eXJ1bGVsZW4gPSB0aGlzX3Byb2R1Y3Rpb25bMV07XG5cblxuXG5cblxuXG5cblxuXG5cbiAgICAgICAgICAgICAgICByID0gdGhpcy5wZXJmb3JtQWN0aW9uLmNhbGwoeXl2YWwsIG5ld1N0YXRlLCBzcCAtIDEsIHZzdGFjayk7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IHI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHBvcCBvZmYgc3RhY2tcbiAgICAgICAgICAgICAgICBzcCAtPSB5eXJ1bGVsZW47XG5cbiAgICAgICAgICAgICAgICAvLyBkb24ndCBvdmVyd3JpdGUgdGhlIGBzeW1ib2xgIHZhcmlhYmxlOiB1c2UgYSBsb2NhbCB2YXIgdG8gc3BlZWQgdGhpbmdzIHVwOlxuICAgICAgICAgICAgICAgIHZhciBudHN5bWJvbCA9IHRoaXNfcHJvZHVjdGlvblswXTsgICAgLy8gcHVzaCBub250ZXJtaW5hbCAocmVkdWNlKVxuICAgICAgICAgICAgICAgIHN0YWNrW3NwXSA9IG50c3ltYm9sO1xuICAgICAgICAgICAgICAgIHZzdGFja1tzcF0gPSB5eXZhbC4kO1xuXG4gICAgICAgICAgICAgICAgLy8gZ290byBuZXcgc3RhdGUgPSB0YWJsZVtTVEFURV1bTk9OVEVSTUlOQUxdXG4gICAgICAgICAgICAgICAgbmV3U3RhdGUgPSB0YWJsZVtzc3RhY2tbc3AgLSAxXV1bbnRzeW1ib2xdO1xuICAgICAgICAgICAgICAgIHNzdGFja1tzcF0gPSBuZXdTdGF0ZTtcbiAgICAgICAgICAgICAgICArK3NwO1xuXG5cblxuXG5cblxuXG5cblxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAvLyBhY2NlcHQ6XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgaWYgKHNwICE9PSAtMikge1xuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGAkYWNjZXB0YCBydWxlJ3MgYCQkYCByZXN1bHQsIGlmIGF2YWlsYWJsZS5cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gQWxzbyBub3RlIHRoYXQgSklTT04gYWx3YXlzIGFkZHMgdGhpcyB0b3AtbW9zdCBgJGFjY2VwdGAgcnVsZSAod2l0aCBpbXBsaWNpdCxcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVmYXVsdCwgYWN0aW9uKTpcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICRhY2NlcHQ6IDxzdGFydFN5bWJvbD4gJGVuZFxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICV7ICQkID0gJDE7IEAkID0gQDE7ICV9XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoaWNoLCBjb21iaW5lZCB3aXRoIHRoZSBwYXJzZSBrZXJuZWwncyBgJGFjY2VwdGAgc3RhdGUgYmVoYXZpb3VyIGNvZGVkIGJlbG93LFxuICAgICAgICAgICAgICAgICAgICAvLyB3aWxsIHByb2R1Y2UgdGhlIGAkJGAgdmFsdWUgb3V0cHV0IG9mIHRoZSA8c3RhcnRTeW1ib2w+IHJ1bGUgYXMgdGhlIHBhcnNlIHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgLy8gSUZGIHRoYXQgcmVzdWx0IGlzICpub3QqIGB1bmRlZmluZWRgLiAoU2VlIGFsc28gdGhlIHBhcnNlciBrZXJuZWwgY29kZS4pXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIEluIGNvZGU6XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgJXtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgQCQgPSBAMTsgICAgICAgICAgICAvLyBpZiBsb2NhdGlvbiB0cmFja2luZyBzdXBwb3J0IGlzIGluY2x1ZGVkXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgJDEgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQxO1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgICAgICAgICAgIC8vIHRoZSBkZWZhdWx0IHBhcnNlIHJlc3VsdCBpZiB0aGUgcnVsZSBhY3Rpb25zIGRvbid0IHByb2R1Y2UgYW55dGhpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAlfVxuICAgICAgICAgICAgICAgICAgICBzcC0tO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZzdGFja1tzcF0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSB2c3RhY2tbc3BdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBicmVhayBvdXQgb2YgbG9vcDogd2UgYWNjZXB0IG9yIGZhaWwgd2l0aCBlcnJvclxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAvLyByZXBvcnQgZXhjZXB0aW9ucyB0aHJvdWdoIHRoZSBwYXJzZUVycm9yIGNhbGxiYWNrIHRvbywgYnV0IGtlZXAgdGhlIGV4Y2VwdGlvbiBpbnRhY3RcbiAgICAgICAgLy8gaWYgaXQgaXMgYSBrbm93biBwYXJzZXIgb3IgbGV4ZXIgZXJyb3Igd2hpY2ggaGFzIGJlZW4gdGhyb3duIGJ5IHBhcnNlRXJyb3IoKSBhbHJlYWR5OlxuICAgICAgICBpZiAoZXggaW5zdGFuY2VvZiB0aGlzLkppc29uUGFyc2VyRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IGV4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxleGVyICYmIHR5cGVvZiBsZXhlci5KaXNvbkxleGVyRXJyb3IgPT09ICdmdW5jdGlvbicgJiYgZXggaW5zdGFuY2VvZiBsZXhlci5KaXNvbkxleGVyRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgcCA9IHRoaXMuY29uc3RydWN0UGFyc2VFcnJvckluZm8oJ1BhcnNpbmcgYWJvcnRlZCBkdWUgdG8gZXhjZXB0aW9uLicsIGV4LCBudWxsLCBmYWxzZSk7XG4gICAgICAgIHJldHZhbCA9IGZhbHNlO1xuICAgICAgICByID0gdGhpcy5wYXJzZUVycm9yKHAuZXJyU3RyLCBwLCB0aGlzLkppc29uUGFyc2VyRXJyb3IpO1xuICAgICAgICBpZiAodHlwZW9mIHIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR2YWwgPSByO1xuICAgICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgcmV0dmFsID0gdGhpcy5jbGVhbnVwQWZ0ZXJQYXJzZShyZXR2YWwsIHRydWUsIHRydWUpO1xuICAgICAgICB0aGlzLl9fcmVlbnRyYW50X2NhbGxfZGVwdGgtLTtcbiAgICB9ICAgLy8gL2ZpbmFsbHlcblxuICAgIHJldHVybiByZXR2YWw7XG59XG59O1xucGFyc2VyLm9yaWdpbmFsUGFyc2VFcnJvciA9IHBhcnNlci5wYXJzZUVycm9yO1xucGFyc2VyLm9yaWdpbmFsUXVvdGVOYW1lID0gcGFyc2VyLnF1b3RlTmFtZTtcbi8qIGxleGVyIGdlbmVyYXRlZCBieSBqaXNvbi1sZXggMC42LjEtMjE1ICovXG5cbi8qXG4gKiBSZXR1cm5zIGEgTGV4ZXIgb2JqZWN0IG9mIHRoZSBmb2xsb3dpbmcgc3RydWN0dXJlOlxuICpcbiAqICBMZXhlcjoge1xuICogICAgeXk6IHt9ICAgICBUaGUgc28tY2FsbGVkIFwic2hhcmVkIHN0YXRlXCIgb3IgcmF0aGVyIHRoZSAqc291cmNlKiBvZiBpdDtcbiAqICAgICAgICAgICAgICAgdGhlIHJlYWwgXCJzaGFyZWQgc3RhdGVcIiBgeXlgIHBhc3NlZCBhcm91bmQgdG9cbiAqICAgICAgICAgICAgICAgdGhlIHJ1bGUgYWN0aW9ucywgZXRjLiBpcyBhIGRpcmVjdCByZWZlcmVuY2UhXG4gKlxuICogICAgICAgICAgICAgICBUaGlzIFwic2hhcmVkIGNvbnRleHRcIiBvYmplY3Qgd2FzIHBhc3NlZCB0byB0aGUgbGV4ZXIgYnkgd2F5IG9mIFxuICogICAgICAgICAgICAgICB0aGUgYGxleGVyLnNldElucHV0KHN0ciwgeXkpYCBBUEkgYmVmb3JlIHlvdSBtYXkgdXNlIGl0LlxuICpcbiAqICAgICAgICAgICAgICAgVGhpcyBcInNoYXJlZCBjb250ZXh0XCIgb2JqZWN0IGlzIHBhc3NlZCB0byB0aGUgbGV4ZXIgYWN0aW9uIGNvZGUgaW4gYHBlcmZvcm1BY3Rpb24oKWBcbiAqICAgICAgICAgICAgICAgc28gdXNlcmxhbmQgY29kZSBpbiB0aGUgbGV4ZXIgYWN0aW9ucyBtYXkgY29tbXVuaWNhdGUgd2l0aCB0aGUgb3V0c2lkZSB3b3JsZCBcbiAqICAgICAgICAgICAgICAgYW5kL29yIG90aGVyIGxleGVyIHJ1bGVzJyBhY3Rpb25zIGluIG1vcmUgb3IgbGVzcyBjb21wbGV4IHdheXMuXG4gKlxuICogIH1cbiAqXG4gKiAgTGV4ZXIucHJvdG90eXBlOiB7XG4gKiAgICBFT0Y6IDEsXG4gKiAgICBFUlJPUjogMixcbiAqXG4gKiAgICB5eTogICAgICAgIFRoZSBvdmVyYWxsIFwic2hhcmVkIGNvbnRleHRcIiBvYmplY3QgcmVmZXJlbmNlLlxuICpcbiAqICAgIEppc29uTGV4ZXJFcnJvcjogZnVuY3Rpb24obXNnLCBoYXNoKSxcbiAqXG4gKiAgICBwZXJmb3JtQWN0aW9uOiBmdW5jdGlvbiBsZXhlcl9fcGVyZm9ybUFjdGlvbih5eSwgeXlydWxlbnVtYmVyLCBZWV9TVEFSVCksXG4gKlxuICogICAgICAgICAgICAgICBUaGUgZnVuY3Rpb24gcGFyYW1ldGVycyBhbmQgYHRoaXNgIGhhdmUgdGhlIGZvbGxvd2luZyB2YWx1ZS9tZWFuaW5nOlxuICogICAgICAgICAgICAgICAtIGB0aGlzYCAgICA6IHJlZmVyZW5jZSB0byB0aGUgYGxleGVyYCBpbnN0YW5jZS4gXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgeXlfYCBpcyBhbiBhbGlhcyBmb3IgYHRoaXNgIGxleGVyIGluc3RhbmNlIHJlZmVyZW5jZSB1c2VkIGludGVybmFsbHkuXG4gKlxuICogICAgICAgICAgICAgICAtIGB5eWAgICAgICA6IGEgcmVmZXJlbmNlIHRvIHRoZSBgeXlgIFwic2hhcmVkIHN0YXRlXCIgb2JqZWN0IHdoaWNoIHdhcyBwYXNzZWQgdG8gdGhlIGxleGVyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnkgd2F5IG9mIHRoZSBgbGV4ZXIuc2V0SW5wdXQoc3RyLCB5eSlgIEFQSSBiZWZvcmUuXG4gKlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5vdGU6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGV4dHJhIGFyZ3VtZW50cyB5b3Ugc3BlY2lmaWVkIGluIHRoZSBgJXBhcnNlLXBhcmFtYCBzdGF0ZW1lbnQgaW4geW91clxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICoqcGFyc2VyKiogZ3JhbW1hciBkZWZpbml0aW9uIGZpbGUgYXJlIHBhc3NlZCB0byB0aGUgbGV4ZXIgdmlhIHRoaXMgb2JqZWN0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlIGFzIG1lbWJlciB2YXJpYWJsZXMuXG4gKlxuICogICAgICAgICAgICAgICAtIGB5eXJ1bGVudW1iZXJgICAgOiBpbmRleCBvZiB0aGUgbWF0Y2hlZCBsZXhlciBydWxlIChyZWdleCksIHVzZWQgaW50ZXJuYWxseS5cbiAqXG4gKiAgICAgICAgICAgICAgIC0gYFlZX1NUQVJUYDogdGhlIGN1cnJlbnQgbGV4ZXIgXCJzdGFydCBjb25kaXRpb25cIiBzdGF0ZS5cbiAqXG4gKiAgICBwYXJzZUVycm9yOiBmdW5jdGlvbihzdHIsIGhhc2gsIEV4Y2VwdGlvbkNsYXNzKSxcbiAqXG4gKiAgICBjb25zdHJ1Y3RMZXhFcnJvckluZm86IGZ1bmN0aW9uKGVycm9yX21lc3NhZ2UsIGlzX3JlY292ZXJhYmxlKSxcbiAqICAgICAgICAgICAgICAgSGVscGVyIGZ1bmN0aW9uLlxuICogICAgICAgICAgICAgICBQcm9kdWNlcyBhIG5ldyBlcnJvckluZm8gJ2hhc2ggb2JqZWN0JyB3aGljaCBjYW4gYmUgcGFzc2VkIGludG8gYHBhcnNlRXJyb3IoKWAuXG4gKiAgICAgICAgICAgICAgIFNlZSBpdCdzIHVzZSBpbiB0aGlzIGxleGVyIGtlcm5lbCBpbiBtYW55IHBsYWNlczsgZXhhbXBsZSB1c2FnZTpcbiAqXG4gKiAgICAgICAgICAgICAgICAgICB2YXIgaW5mb09iaiA9IGxleGVyLmNvbnN0cnVjdFBhcnNlRXJyb3JJbmZvKCdmYWlsIScsIHRydWUpO1xuICogICAgICAgICAgICAgICAgICAgdmFyIHJldFZhbCA9IGxleGVyLnBhcnNlRXJyb3IoaW5mb09iai5lcnJTdHIsIGluZm9PYmosIGxleGVyLkppc29uTGV4ZXJFcnJvcik7XG4gKlxuICogICAgb3B0aW9uczogeyAuLi4gbGV4ZXIgJW9wdGlvbnMgLi4uIH0sXG4gKlxuICogICAgbGV4OiBmdW5jdGlvbigpLFxuICogICAgICAgICAgICAgICBQcm9kdWNlIG9uZSB0b2tlbiBvZiBsZXhlZCBpbnB1dCwgd2hpY2ggd2FzIHBhc3NlZCBpbiBlYXJsaWVyIHZpYSB0aGUgYGxleGVyLnNldElucHV0KClgIEFQSS5cbiAqICAgICAgICAgICAgICAgWW91IE1BWSB1c2UgdGhlIGFkZGl0aW9uYWwgYGFyZ3MuLi5gIHBhcmFtZXRlcnMgYXMgcGVyIGAlcGFyc2UtcGFyYW1gIHNwZWMgb2YgdGhlICoqbGV4ZXIqKiBncmFtbWFyOlxuICogICAgICAgICAgICAgICB0aGVzZSBleHRyYSBgYXJncy4uLmAgYXJlIGFkZGVkIHZlcmJhdGltIHRvIHRoZSBgeXlgIG9iamVjdCByZWZlcmVuY2UgYXMgbWVtYmVyIHZhcmlhYmxlcy5cbiAqXG4gKiAgICAgICAgICAgICAgIFdBUk5JTkc6XG4gKiAgICAgICAgICAgICAgIExleGVyJ3MgYWRkaXRpb25hbCBgYXJncy4uLmAgcGFyYW1ldGVycyAodmlhIGxleGVyJ3MgYCVwYXJzZS1wYXJhbWApIE1BWSBjb25mbGljdCB3aXRoXG4gKiAgICAgICAgICAgICAgIGFueSBhdHRyaWJ1dGVzIGFscmVhZHkgYWRkZWQgdG8gYHl5YCBieSB0aGUgKipwYXJzZXIqKiBvciB0aGUgamlzb24gcnVuLXRpbWU7IFxuICogICAgICAgICAgICAgICB3aGVuIHN1Y2ggYSBjb2xsaXNpb24gaXMgZGV0ZWN0ZWQgYW4gZXhjZXB0aW9uIGlzIHRocm93biB0byBwcmV2ZW50IHRoZSBnZW5lcmF0ZWQgcnVuLXRpbWUgXG4gKiAgICAgICAgICAgICAgIGZyb20gc2lsZW50bHkgYWNjZXB0aW5nIHRoaXMgY29uZnVzaW5nIGFuZCBwb3RlbnRpYWxseSBoYXphcmRvdXMgc2l0dWF0aW9uISBcbiAqXG4gKiAgICBjbGVhbnVwQWZ0ZXJMZXg6IGZ1bmN0aW9uKGRvX25vdF9udWtlX2Vycm9yaW5mb3MpLFxuICogICAgICAgICAgICAgICBIZWxwZXIgZnVuY3Rpb24uXG4gKlxuICogICAgICAgICAgICAgICBUaGlzIGhlbHBlciBBUEkgaXMgaW52b2tlZCB3aGVuIHRoZSAqKnBhcnNlIHByb2Nlc3MqKiBoYXMgY29tcGxldGVkOiBpdCBpcyB0aGUgcmVzcG9uc2liaWxpdHlcbiAqICAgICAgICAgICAgICAgb2YgdGhlICoqcGFyc2VyKiogKG9yIHRoZSBjYWxsaW5nIHVzZXJsYW5kIGNvZGUpIHRvIGludm9rZSB0aGlzIG1ldGhvZCBvbmNlIGNsZWFudXAgaXMgZGVzaXJlZC4gXG4gKlxuICogICAgICAgICAgICAgICBUaGlzIGhlbHBlciBtYXkgYmUgaW52b2tlZCBieSB1c2VyIGNvZGUgdG8gZW5zdXJlIHRoZSBpbnRlcm5hbCBsZXhlciBnZXRzIHByb3Blcmx5IGdhcmJhZ2UgY29sbGVjdGVkLlxuICpcbiAqICAgIHNldElucHV0OiBmdW5jdGlvbihpbnB1dCwgW3l5XSksXG4gKlxuICpcbiAqICAgIGlucHV0OiBmdW5jdGlvbigpLFxuICpcbiAqXG4gKiAgICB1bnB1dDogZnVuY3Rpb24oc3RyKSxcbiAqXG4gKlxuICogICAgbW9yZTogZnVuY3Rpb24oKSxcbiAqXG4gKlxuICogICAgcmVqZWN0OiBmdW5jdGlvbigpLFxuICpcbiAqXG4gKiAgICBsZXNzOiBmdW5jdGlvbihuKSxcbiAqXG4gKlxuICogICAgcGFzdElucHV0OiBmdW5jdGlvbihuKSxcbiAqXG4gKlxuICogICAgdXBjb21pbmdJbnB1dDogZnVuY3Rpb24obiksXG4gKlxuICpcbiAqICAgIHNob3dQb3NpdGlvbjogZnVuY3Rpb24oKSxcbiAqXG4gKlxuICogICAgdGVzdF9tYXRjaDogZnVuY3Rpb24ocmVnZXhfbWF0Y2hfYXJyYXksIHJ1bGVfaW5kZXgpLFxuICpcbiAqXG4gKiAgICBuZXh0OiBmdW5jdGlvbigpLFxuICpcbiAqXG4gKiAgICBiZWdpbjogZnVuY3Rpb24oY29uZGl0aW9uKSxcbiAqXG4gKlxuICogICAgcHVzaFN0YXRlOiBmdW5jdGlvbihjb25kaXRpb24pLFxuICpcbiAqXG4gKiAgICBwb3BTdGF0ZTogZnVuY3Rpb24oKSxcbiAqXG4gKlxuICogICAgdG9wU3RhdGU6IGZ1bmN0aW9uKCksXG4gKlxuICpcbiAqICAgIF9jdXJyZW50UnVsZXM6IGZ1bmN0aW9uKCksXG4gKlxuICpcbiAqICAgIHN0YXRlU3RhY2tTaXplOiBmdW5jdGlvbigpLFxuICpcbiAqXG4gKiAgICBwZXJmb3JtQWN0aW9uOiBmdW5jdGlvbih5eSwgeXlfLCB5eXJ1bGVudW1iZXIsIFlZX1NUQVJUKSxcbiAqXG4gKlxuICogICAgcnVsZXM6IFsuLi5dLFxuICpcbiAqXG4gKiAgICBjb25kaXRpb25zOiB7YXNzb2NpYXRpdmUgbGlzdDogbmFtZSA9PT4gc2V0fSxcbiAqICB9XG4gKlxuICpcbiAqICB0b2tlbiBsb2NhdGlvbiBpbmZvIChgeXlsbG9jYCk6IHtcbiAqICAgIGZpcnN0X2xpbmU6IG4sXG4gKiAgICBsYXN0X2xpbmU6IG4sXG4gKiAgICBmaXJzdF9jb2x1bW46IG4sXG4gKiAgICBsYXN0X2NvbHVtbjogbixcbiAqICAgIHJhbmdlOiBbc3RhcnRfbnVtYmVyLCBlbmRfbnVtYmVyXVxuICogICAgICAgICAgICAgICAod2hlcmUgdGhlIG51bWJlcnMgYXJlIGluZGV4ZXMgaW50byB0aGUgaW5wdXQgc3RyaW5nLCB6ZXJvLWJhc2VkKVxuICogIH1cbiAqXG4gKiAtLS1cbiAqXG4gKiBUaGUgYHBhcnNlRXJyb3JgIGZ1bmN0aW9uIHJlY2VpdmVzIGEgJ2hhc2gnIG9iamVjdCB3aXRoIHRoZXNlIG1lbWJlcnMgZm9yIGxleGVyIGVycm9yczpcbiAqXG4gKiAge1xuICogICAgdGV4dDogICAgICAgIChtYXRjaGVkIHRleHQpXG4gKiAgICB0b2tlbjogICAgICAgKHRoZSBwcm9kdWNlZCB0ZXJtaW5hbCB0b2tlbiwgaWYgYW55KVxuICogICAgdG9rZW5faWQ6ICAgICh0aGUgcHJvZHVjZWQgdGVybWluYWwgdG9rZW4gbnVtZXJpYyBJRCwgaWYgYW55KVxuICogICAgbGluZTogICAgICAgICh5eWxpbmVubylcbiAqICAgIGxvYzogICAgICAgICAoeXlsbG9jKVxuICogICAgcmVjb3ZlcmFibGU6IChib29sZWFuOiBUUlVFIHdoZW4gdGhlIHBhcnNlciBNQVkgaGF2ZSBhbiBlcnJvciByZWNvdmVyeSBydWxlXG4gKiAgICAgICAgICAgICAgICAgIGF2YWlsYWJsZSBmb3IgdGhpcyBwYXJ0aWN1bGFyIGVycm9yKVxuICogICAgeXk6ICAgICAgICAgIChvYmplY3Q6IHRoZSBjdXJyZW50IHBhcnNlciBpbnRlcm5hbCBcInNoYXJlZCBzdGF0ZVwiIGB5eWBcbiAqICAgICAgICAgICAgICAgICAgYXMgaXMgYWxzbyBhdmFpbGFibGUgaW4gdGhlIHJ1bGUgYWN0aW9uczsgdGhpcyBjYW4gYmUgdXNlZCxcbiAqICAgICAgICAgICAgICAgICAgZm9yIGluc3RhbmNlLCBmb3IgYWR2YW5jZWQgZXJyb3IgYW5hbHlzaXMgYW5kIHJlcG9ydGluZylcbiAqICAgIGxleGVyOiAgICAgICAocmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGxleGVyIGluc3RhbmNlIHVzZWQgYnkgdGhlIHBhcnNlcilcbiAqICB9XG4gKlxuICogd2hpbGUgYHRoaXNgIHdpbGwgcmVmZXJlbmNlIHRoZSBjdXJyZW50IGxleGVyIGluc3RhbmNlLlxuICpcbiAqIFdoZW4gYHBhcnNlRXJyb3JgIGlzIGludm9rZWQgYnkgdGhlIGxleGVyLCB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiB3aWxsXG4gKiBhdHRlbXB0IHRvIGludm9rZSBgeXkucGFyc2VyLnBhcnNlRXJyb3IoKWA7IHdoZW4gdGhpcyBjYWxsYmFjayBpcyBub3QgcHJvdmlkZWRcbiAqIGl0IHdpbGwgdHJ5IHRvIGludm9rZSBgeXkucGFyc2VFcnJvcigpYCBpbnN0ZWFkLiBXaGVuIHRoYXQgY2FsbGJhY2sgaXMgYWxzbyBub3RcbiAqIHByb3ZpZGVkLCBhIGBKaXNvbkxleGVyRXJyb3JgIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93biBjb250YWluaW5nIHRoZSBlcnJvclxuICogbWVzc2FnZSBhbmQgYGhhc2hgLCBhcyBjb25zdHJ1Y3RlZCBieSB0aGUgYGNvbnN0cnVjdExleEVycm9ySW5mbygpYCBBUEkuXG4gKlxuICogTm90ZSB0aGF0IHRoZSBsZXhlcidzIGBKaXNvbkxleGVyRXJyb3JgIGVycm9yIGNsYXNzIGlzIHBhc3NlZCB2aWEgdGhlXG4gKiBgRXhjZXB0aW9uQ2xhc3NgIGFyZ3VtZW50LCB3aGljaCBpcyBpbnZva2VkIHRvIGNvbnN0cnVjdCB0aGUgZXhjZXB0aW9uXG4gKiBpbnN0YW5jZSB0byBiZSB0aHJvd24sIHNvIHRlY2huaWNhbGx5IGBwYXJzZUVycm9yYCB3aWxsIHRocm93IHRoZSBvYmplY3RcbiAqIHByb2R1Y2VkIGJ5IHRoZSBgbmV3IEV4Y2VwdGlvbkNsYXNzKHN0ciwgaGFzaClgIEphdmFTY3JpcHQgZXhwcmVzc2lvbi5cbiAqXG4gKiAtLS1cbiAqXG4gKiBZb3UgY2FuIHNwZWNpZnkgbGV4ZXIgb3B0aW9ucyBieSBzZXR0aW5nIC8gbW9kaWZ5aW5nIHRoZSBgLm9wdGlvbnNgIG9iamVjdCBvZiB5b3VyIExleGVyIGluc3RhbmNlLlxuICogVGhlc2Ugb3B0aW9ucyBhcmUgYXZhaWxhYmxlOlxuICpcbiAqIChPcHRpb25zIGFyZSBwZXJtYW5lbnQuKVxuICogIFxuICogIHl5OiB7XG4gKiAgICAgIHBhcnNlRXJyb3I6IGZ1bmN0aW9uKHN0ciwgaGFzaCwgRXhjZXB0aW9uQ2xhc3MpXG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IG92ZXJyaWRlcyB0aGUgZGVmYXVsdCBgcGFyc2VFcnJvcmAgZnVuY3Rpb24uXG4gKiAgfVxuICpcbiAqICBsZXhlci5vcHRpb25zOiB7XG4gKiAgICAgIHByZV9sZXg6ICBmdW5jdGlvbigpXG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IGlzIGludm9rZWQgYmVmb3JlIHRoZSBsZXhlciBpcyBpbnZva2VkIHRvIHByb2R1Y2UgYW5vdGhlciB0b2tlbi5cbiAqICAgICAgICAgICAgICAgICBgdGhpc2AgcmVmZXJzIHRvIHRoZSBMZXhlciBvYmplY3QuXG4gKiAgICAgIHBvc3RfbGV4OiBmdW5jdGlvbih0b2tlbikgeyByZXR1cm4gdG9rZW47IH1cbiAqICAgICAgICAgICAgICAgICBvcHRpb25hbDogaXMgaW52b2tlZCB3aGVuIHRoZSBsZXhlciBoYXMgcHJvZHVjZWQgYSB0b2tlbiBgdG9rZW5gO1xuICogICAgICAgICAgICAgICAgIHRoaXMgZnVuY3Rpb24gY2FuIG92ZXJyaWRlIHRoZSByZXR1cm5lZCB0b2tlbiB2YWx1ZSBieSByZXR1cm5pbmcgYW5vdGhlci5cbiAqICAgICAgICAgICAgICAgICBXaGVuIGl0IGRvZXMgbm90IHJldHVybiBhbnkgKHRydXRoeSkgdmFsdWUsIHRoZSBsZXhlciB3aWxsIHJldHVyblxuICogICAgICAgICAgICAgICAgIHRoZSBvcmlnaW5hbCBgdG9rZW5gLlxuICogICAgICAgICAgICAgICAgIGB0aGlzYCByZWZlcnMgdG8gdGhlIExleGVyIG9iamVjdC5cbiAqXG4gKiBXQVJOSU5HOiB0aGUgbmV4dCBzZXQgb2Ygb3B0aW9ucyBhcmUgbm90IG1lYW50IHRvIGJlIGNoYW5nZWQuIFRoZXkgZWNobyB0aGUgYWJpbGl0aWVzIG9mXG4gKiB0aGUgbGV4ZXIgYXMgcGVyIHdoZW4gaXQgd2FzIGNvbXBpbGVkIVxuICpcbiAqICAgICAgcmFuZ2VzOiBib29sZWFuXG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IGB0cnVlYCA9PT4gdG9rZW4gbG9jYXRpb24gaW5mbyB3aWxsIGluY2x1ZGUgYSAucmFuZ2VbXSBtZW1iZXIuXG4gKiAgICAgIGZsZXg6IGJvb2xlYW5cbiAqICAgICAgICAgICAgICAgICBvcHRpb25hbDogYHRydWVgID09PiBmbGV4LWxpa2UgbGV4aW5nIGJlaGF2aW91ciB3aGVyZSB0aGUgcnVsZXMgYXJlIHRlc3RlZFxuICogICAgICAgICAgICAgICAgIGV4aGF1c3RpdmVseSB0byBmaW5kIHRoZSBsb25nZXN0IG1hdGNoLlxuICogICAgICBiYWNrdHJhY2tfbGV4ZXI6IGJvb2xlYW5cbiAqICAgICAgICAgICAgICAgICBvcHRpb25hbDogYHRydWVgID09PiBsZXhlciByZWdleGVzIGFyZSB0ZXN0ZWQgaW4gb3JkZXIgYW5kIGZvciBpbnZva2VkO1xuICogICAgICAgICAgICAgICAgIHRoZSBsZXhlciB0ZXJtaW5hdGVzIHRoZSBzY2FuIHdoZW4gYSB0b2tlbiBpcyByZXR1cm5lZCBieSB0aGUgYWN0aW9uIGNvZGUuXG4gKiAgICAgIHhyZWdleHA6IGJvb2xlYW5cbiAqICAgICAgICAgICAgICAgICBvcHRpb25hbDogYHRydWVgID09PiBsZXhlciBydWxlIHJlZ2V4ZXMgYXJlIFwiZXh0ZW5kZWQgcmVnZXggZm9ybWF0XCIgcmVxdWlyaW5nIHRoZVxuICogICAgICAgICAgICAgICAgIGBYUmVnRXhwYCBsaWJyYXJ5LiBXaGVuIHRoaXMgJW9wdGlvbiBoYXMgbm90IGJlZW4gc3BlY2lmaWVkIGF0IGNvbXBpbGUgdGltZSwgYWxsIGxleGVyXG4gKiAgICAgICAgICAgICAgICAgcnVsZSByZWdleGVzIGhhdmUgYmVlbiB3cml0dGVuIGFzIHN0YW5kYXJkIEphdmFTY3JpcHQgUmVnRXhwIGV4cHJlc3Npb25zLlxuICogIH1cbiAqL1xuXG5cbnZhciBsZXhlciA9IGZ1bmN0aW9uKCkge1xuICAvKipcbiAgICogU2VlIGFsc286XG4gICAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTM4MjEwNy93aGF0cy1hLWdvb2Qtd2F5LXRvLWV4dGVuZC1lcnJvci1pbi1qYXZhc2NyaXB0LyMzNTg4MTUwOFxuICAgKiBidXQgd2Uga2VlcCB0aGUgcHJvdG90eXBlLmNvbnN0cnVjdG9yIGFuZCBwcm90b3R5cGUubmFtZSBhc3NpZ25tZW50IGxpbmVzIHRvbyBmb3IgY29tcGF0aWJpbGl0eVxuICAgKiB3aXRoIHVzZXJsYW5kIGNvZGUgd2hpY2ggbWlnaHQgYWNjZXNzIHRoZSBkZXJpdmVkIGNsYXNzIGluIGEgJ2NsYXNzaWMnIHdheS5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKiBAY29uc3RydWN0b3JcbiAgICogQG5vY29sbGFwc2VcbiAgICovXG4gIGZ1bmN0aW9uIEppc29uTGV4ZXJFcnJvcihtc2csIGhhc2gpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ25hbWUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiAnSmlzb25MZXhlckVycm9yJ1xuICAgIH0pO1xuXG4gICAgaWYgKG1zZyA9PSBudWxsKVxuICAgICAgbXNnID0gJz8/Pyc7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ21lc3NhZ2UnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IG1zZ1xuICAgIH0pO1xuXG4gICAgdGhpcy5oYXNoID0gaGFzaDtcbiAgICB2YXIgc3RhY2t0cmFjZTtcblxuICAgIGlmIChoYXNoICYmIGhhc2guZXhjZXB0aW9uIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHZhciBleDIgPSBoYXNoLmV4Y2VwdGlvbjtcbiAgICAgIHRoaXMubWVzc2FnZSA9IGV4Mi5tZXNzYWdlIHx8IG1zZztcbiAgICAgIHN0YWNrdHJhY2UgPSBleDIuc3RhY2s7XG4gICAgfVxuXG4gICAgaWYgKCFzdGFja3RyYWNlKSB7XG4gICAgICBpZiAoRXJyb3IuaGFzT3duUHJvcGVydHkoJ2NhcHR1cmVTdGFja1RyYWNlJykpIHtcbiAgICAgICAgLy8gVjhcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFja3RyYWNlID0gbmV3IEVycm9yKG1zZykuc3RhY2s7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0YWNrdHJhY2UpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc3RhY2snLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBzdGFja3RyYWNlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIE9iamVjdC5zZXRQcm90b3R5cGVPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihKaXNvbkxleGVyRXJyb3IucHJvdG90eXBlLCBFcnJvci5wcm90b3R5cGUpO1xuICB9IGVsc2Uge1xuICAgIEppc29uTGV4ZXJFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG4gIH1cblxuICBKaXNvbkxleGVyRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSmlzb25MZXhlckVycm9yO1xuICBKaXNvbkxleGVyRXJyb3IucHJvdG90eXBlLm5hbWUgPSAnSmlzb25MZXhlckVycm9yJztcblxuICB2YXIgbGV4ZXIgPSB7XG4gICAgXG4vLyBDb2RlIEdlbmVyYXRvciBJbmZvcm1hdGlvbiBSZXBvcnRcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy9cbi8vIE9wdGlvbnM6XG4vL1xuLy8gICBiYWNrdHJhY2tpbmc6IC4uLi4uLi4uLi4uLi4uLi4uLi4uIGZhbHNlXG4vLyAgIGxvY2F0aW9uLnJhbmdlczogLi4uLi4uLi4uLi4uLi4uLi4gZmFsc2Vcbi8vICAgbG9jYXRpb24gbGluZStjb2x1bW4gdHJhY2tpbmc6IC4uLiB0cnVlXG4vL1xuLy9cbi8vIEZvcndhcmRlZCBQYXJzZXIgQW5hbHlzaXMgZmxhZ3M6XG4vL1xuLy8gICB1c2VzIHl5bGVuZzogLi4uLi4uLi4uLi4uLi4uLi4uLi4uIGZhbHNlXG4vLyAgIHVzZXMgeXlsaW5lbm86IC4uLi4uLi4uLi4uLi4uLi4uLi4gZmFsc2Vcbi8vICAgdXNlcyB5eXRleHQ6IC4uLi4uLi4uLi4uLi4uLi4uLi4uLiBmYWxzZVxuLy8gICB1c2VzIHl5bGxvYzogLi4uLi4uLi4uLi4uLi4uLi4uLi4uIGZhbHNlXG4vLyAgIHVzZXMgbGV4ZXIgdmFsdWVzOiAuLi4uLi4uLi4uLi4uLi4gdHJ1ZSAvIHRydWVcbi8vICAgbG9jYXRpb24gdHJhY2tpbmc6IC4uLi4uLi4uLi4uLi4uLiBmYWxzZVxuLy8gICBsb2NhdGlvbiBhc3NpZ25tZW50OiAuLi4uLi4uLi4uLi4uIGZhbHNlXG4vL1xuLy9cbi8vIExleGVyIEFuYWx5c2lzIGZsYWdzOlxuLy9cbi8vICAgdXNlcyB5eWxlbmc6IC4uLi4uLi4uLi4uLi4uLi4uLi4uLiA/Pz9cbi8vICAgdXNlcyB5eWxpbmVubzogLi4uLi4uLi4uLi4uLi4uLi4uLiA/Pz9cbi8vICAgdXNlcyB5eXRleHQ6IC4uLi4uLi4uLi4uLi4uLi4uLi4uLiA/Pz9cbi8vICAgdXNlcyB5eWxsb2M6IC4uLi4uLi4uLi4uLi4uLi4uLi4uLiA/Pz9cbi8vICAgdXNlcyBQYXJzZUVycm9yIEFQSTogLi4uLi4uLi4uLi4uLiA/Pz9cbi8vICAgdXNlcyB5eWVycm9yOiAuLi4uLi4uLi4uLi4uLi4uLi4uLiA/Pz9cbi8vICAgdXNlcyBsb2NhdGlvbiB0cmFja2luZyAmIGVkaXRpbmc6ICA/Pz9cbi8vICAgdXNlcyBtb3JlKCkgQVBJOiAuLi4uLi4uLi4uLi4uLi4uLiA/Pz9cbi8vICAgdXNlcyB1bnB1dCgpIEFQSTogLi4uLi4uLi4uLi4uLi4uLiA/Pz9cbi8vICAgdXNlcyByZWplY3QoKSBBUEk6IC4uLi4uLi4uLi4uLi4uLiA/Pz9cbi8vICAgdXNlcyBsZXNzKCkgQVBJOiAuLi4uLi4uLi4uLi4uLi4uLiA/Pz9cbi8vICAgdXNlcyBkaXNwbGF5IEFQSXMgcGFzdElucHV0KCksIHVwY29taW5nSW5wdXQoKSwgc2hvd1Bvc2l0aW9uKCk6XG4vLyAgICAgICAgLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4gPz8/XG4vLyAgIHVzZXMgZGVzY3JpYmVZWUxMT0MoKSBBUEk6IC4uLi4uLi4gPz8/XG4vL1xuLy8gLS0tLS0tLS0tIEVORCBPRiBSRVBPUlQgLS0tLS0tLS0tLS1cblxuRU9GOiAxLFxuICAgIEVSUk9SOiAyLFxuXG4gICAgLy8gSmlzb25MZXhlckVycm9yOiBKaXNvbkxleGVyRXJyb3IsICAgICAgICAvLy8gPC0tIGluamVjdGVkIGJ5IHRoZSBjb2RlIGdlbmVyYXRvclxuXG4gICAgLy8gb3B0aW9uczoge30sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8gPC0tIGluamVjdGVkIGJ5IHRoZSBjb2RlIGdlbmVyYXRvclxuXG4gICAgLy8geXk6IC4uLiwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8gPC0tIGluamVjdGVkIGJ5IHNldElucHV0KClcblxuICAgIF9fY3VycmVudFJ1bGVTZXRfXzogbnVsbCwgICAgICAgICAgICAgICAgICAgLy8vIElOVEVSTkFMIFVTRSBPTkxZOiBpbnRlcm5hbCBydWxlIHNldCBjYWNoZSBmb3IgdGhlIGN1cnJlbnQgbGV4ZXIgc3RhdGUgIFxuXG4gICAgX19lcnJvcl9pbmZvczogW10sICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8gSU5URVJOQUwgVVNFIE9OTFk6IHRoZSBzZXQgb2YgbGV4RXJyb3JJbmZvIG9iamVjdHMgY3JlYXRlZCBzaW5jZSB0aGUgbGFzdCBjbGVhbnVwICBcbiAgICBfX2RlY29tcHJlc3NlZDogZmFsc2UsICAgICAgICAgICAgICAgICAgICAgIC8vLyBJTlRFUk5BTCBVU0UgT05MWTogbWFyayB3aGV0aGVyIHRoZSBsZXhlciBpbnN0YW5jZSBoYXMgYmVlbiAndW5mb2xkZWQnIGNvbXBsZXRlbHkgYW5kIGlzIG5vdyByZWFkeSBmb3IgdXNlICBcbiAgICBkb25lOiBmYWxzZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLyBJTlRFUk5BTCBVU0UgT05MWSAgXG4gICAgX2JhY2t0cmFjazogZmFsc2UsICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8gSU5URVJOQUwgVVNFIE9OTFkgIFxuICAgIF9pbnB1dDogJycsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vIElOVEVSTkFMIFVTRSBPTkxZICBcbiAgICBfbW9yZTogZmFsc2UsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLyBJTlRFUk5BTCBVU0UgT05MWSAgXG4gICAgX3NpZ25hbGVkX2Vycm9yX3Rva2VuOiBmYWxzZSwgICAgICAgICAgICAgICAvLy8gSU5URVJOQUwgVVNFIE9OTFkgIFxuICAgIGNvbmRpdGlvblN0YWNrOiBbXSwgICAgICAgICAgICAgICAgICAgICAgICAgLy8vIElOVEVSTkFMIFVTRSBPTkxZOyBtYW5hZ2VkIHZpYSBgcHVzaFN0YXRlKClgLCBgcG9wU3RhdGUoKWAsIGB0b3BTdGF0ZSgpYCBhbmQgYHN0YXRlU3RhY2tTaXplKClgICBcbiAgICBtYXRjaDogJycsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLyBSRUFELU9OTFkgRVhURVJOQUwgQUNDRVNTIC0gQURWQU5DRUQgVVNFIE9OTFk6IHRyYWNrcyBpbnB1dCB3aGljaCBoYXMgYmVlbiBtYXRjaGVkIHNvIGZhciBmb3IgdGhlIGxleGVyIHRva2VuIHVuZGVyIGNvbnN0cnVjdGlvbi4gYG1hdGNoYCBpcyBpZGVudGljYWwgdG8gYHl5dGV4dGAgZXhjZXB0IHRoYXQgdGhpcyBvbmUgc3RpbGwgY29udGFpbnMgdGhlIG1hdGNoZWQgaW5wdXQgc3RyaW5nIGFmdGVyIGBsZXhlci5wZXJmb3JtQWN0aW9uKClgIGhhcyBiZWVuIGludm9rZWQsIHdoZXJlIHVzZXJsYW5kIGNvZGUgTUFZIGhhdmUgY2hhbmdlZC9yZXBsYWNlZCB0aGUgYHl5dGV4dGAgdmFsdWUgZW50aXJlbHkhICBcbiAgICBtYXRjaGVkOiAnJywgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLyBSRUFELU9OTFkgRVhURVJOQUwgQUNDRVNTIC0gQURWQU5DRUQgVVNFIE9OTFk6IHRyYWNrcyBlbnRpcmUgaW5wdXQgd2hpY2ggaGFzIGJlZW4gbWF0Y2hlZCBzbyBmYXIgIFxuICAgIG1hdGNoZXM6IGZhbHNlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vIFJFQUQtT05MWSBFWFRFUk5BTCBBQ0NFU1MgLSBBRFZBTkNFRCBVU0UgT05MWTogdHJhY2tzIFJFIG1hdGNoIHJlc3VsdCBmb3IgbGFzdCAoc3VjY2Vzc2Z1bCkgbWF0Y2ggYXR0ZW1wdCAgXG4gICAgeXl0ZXh0OiAnJywgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8gQURWQU5DRUQgVVNFIE9OTFk6IHRyYWNrcyBpbnB1dCB3aGljaCBoYXMgYmVlbiBtYXRjaGVkIHNvIGZhciBmb3IgdGhlIGxleGVyIHRva2VuIHVuZGVyIGNvbnN0cnVjdGlvbjsgdGhpcyB2YWx1ZSBpcyB0cmFuc2ZlcnJlZCB0byB0aGUgcGFyc2VyIGFzIHRoZSAndG9rZW4gdmFsdWUnIHdoZW4gdGhlIHBhcnNlciBjb25zdW1lcyB0aGUgbGV4ZXIgdG9rZW4gcHJvZHVjZWQgdGhyb3VnaCBhIGNhbGwgdG8gdGhlIGBsZXgoKWAgQVBJLiAgXG4gICAgb2Zmc2V0OiAwLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8gUkVBRC1PTkxZIEVYVEVSTkFMIEFDQ0VTUyAtIEFEVkFOQ0VEIFVTRSBPTkxZOiB0cmFja3MgdGhlICdjdXJzb3IgcG9zaXRpb24nIGluIHRoZSBpbnB1dCBzdHJpbmcsIGkuZS4gdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIG1hdGNoZWQgc28gZmFyICBcbiAgICB5eWxlbmc6IDAsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLyBSRUFELU9OTFkgRVhURVJOQUwgQUNDRVNTIC0gQURWQU5DRUQgVVNFIE9OTFk6IGxlbmd0aCBvZiBtYXRjaGVkIGlucHV0IGZvciB0aGUgdG9rZW4gdW5kZXIgY29uc3RydWN0aW9uIChgeXl0ZXh0YCkgIFxuICAgIHl5bGluZW5vOiAwLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vIFJFQUQtT05MWSBFWFRFUk5BTCBBQ0NFU1MgLSBBRFZBTkNFRCBVU0UgT05MWTogJ2xpbmUgbnVtYmVyJyBhdCB3aGljaCB0aGUgdG9rZW4gdW5kZXIgY29uc3RydWN0aW9uIGlzIGxvY2F0ZWQgIFxuICAgIHl5bGxvYzogbnVsbCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vIFJFQUQtT05MWSBFWFRFUk5BTCBBQ0NFU1MgLSBBRFZBTkNFRCBVU0UgT05MWTogdHJhY2tzIGxvY2F0aW9uIGluZm8gKGxpbmVzICsgY29sdW1ucykgZm9yIHRoZSB0b2tlbiB1bmRlciBjb25zdHJ1Y3Rpb24gIFxuXG4gICAgLyoqXG4gICAgICogSU5URVJOQUwgVVNFOiBjb25zdHJ1Y3QgYSBzdWl0YWJsZSBlcnJvciBpbmZvIGhhc2ggb2JqZWN0IGluc3RhbmNlIGZvciBgcGFyc2VFcnJvcmAuXG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RMZXhFcnJvckluZm86IGZ1bmN0aW9uIGxleGVyX2NvbnN0cnVjdExleEVycm9ySW5mbyhtc2csIHJlY292ZXJhYmxlLCBzaG93X2lucHV0X3Bvc2l0aW9uKSB7XG4gICAgICBtc2cgPSAnJyArIG1zZztcblxuICAgICAgLy8gaGV1cmlzdGljIHRvIGRldGVybWluZSBpZiB0aGUgZXJyb3IgbWVzc2FnZSBhbHJlYWR5IGNvbnRhaW5zIGEgKHBhcnRpYWwpIHNvdXJjZSBjb2RlIGR1bXBcbiAgICAgIC8vIGFzIHByb2R1Y2VkIGJ5IGVpdGhlciBgc2hvd1Bvc2l0aW9uKClgIG9yIGBwcmV0dHlQcmludFJhbmdlKClgOlxuICAgICAgaWYgKHNob3dfaW5wdXRfcG9zaXRpb24gPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNob3dfaW5wdXRfcG9zaXRpb24gPSAhKG1zZy5pbmRleE9mKCdcXG4nKSA+IDAgJiYgbXNnLmluZGV4T2YoJ14nKSA+IDApO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy55eWxsb2MgJiYgc2hvd19pbnB1dF9wb3NpdGlvbikge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMucHJldHR5UHJpbnRSYW5nZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciBwcmV0dHlfc3JjID0gdGhpcy5wcmV0dHlQcmludFJhbmdlKHRoaXMueXlsbG9jKTtcblxuICAgICAgICAgIGlmICghL1xcblxccyokLy50ZXN0KG1zZykpIHtcbiAgICAgICAgICAgIG1zZyArPSAnXFxuJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtc2cgKz0gJ1xcbiAgRXJyb25lb3VzIGFyZWE6XFxuJyArIHRoaXMucHJldHR5UHJpbnRSYW5nZSh0aGlzLnl5bGxvYyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuc2hvd1Bvc2l0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFyIHBvc19zdHIgPSB0aGlzLnNob3dQb3NpdGlvbigpO1xuXG4gICAgICAgICAgaWYgKHBvc19zdHIpIHtcbiAgICAgICAgICAgIGlmIChtc2cubGVuZ3RoICYmIG1zZ1ttc2cubGVuZ3RoIC0gMV0gIT09ICdcXG4nICYmIHBvc19zdHJbMF0gIT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgIG1zZyArPSAnXFxuJyArIHBvc19zdHI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtc2cgKz0gcG9zX3N0cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqIEBjb25zdHJ1Y3RvciAqL1xuICAgICAgdmFyIHBlaSA9IHtcbiAgICAgICAgZXJyU3RyOiBtc2csXG4gICAgICAgIHJlY292ZXJhYmxlOiAhIXJlY292ZXJhYmxlLFxuICAgICAgICB0ZXh0OiB0aGlzLm1hdGNoLCAgICAgICAgICAgLy8gVGhpcyBvbmUgTUFZIGJlIGVtcHR5OyB1c2VybGFuZCBjb2RlIHNob3VsZCB1c2UgdGhlIGB1cGNvbWluZ0lucHV0YCBBUEkgdG8gb2J0YWluIG1vcmUgdGV4dCB3aGljaCBmb2xsb3dzIHRoZSAnbGV4ZXIgY3Vyc29yIHBvc2l0aW9uJy4uLiAgXG4gICAgICAgIHRva2VuOiBudWxsLFxuICAgICAgICBsaW5lOiB0aGlzLnl5bGluZW5vLFxuICAgICAgICBsb2M6IHRoaXMueXlsbG9jLFxuICAgICAgICB5eTogdGhpcy55eSxcbiAgICAgICAgbGV4ZXI6IHRoaXMsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGFuZCBtYWtlIHN1cmUgdGhlIGVycm9yIGluZm8gZG9lc24ndCBzdGF5IGR1ZSB0byBwb3RlbnRpYWxcbiAgICAgICAgICogcmVmIGN5Y2xlIHZpYSB1c2VybGFuZCBjb2RlIG1hbmlwdWxhdGlvbnMuXG4gICAgICAgICAqIFRoZXNlIHdvdWxkIG90aGVyd2lzZSBhbGwgYmUgbWVtb3J5IGxlYWsgb3Bwb3J0dW5pdGllcyFcbiAgICAgICAgICogXG4gICAgICAgICAqIE5vdGUgdGhhdCBvbmx5IGFycmF5IGFuZCBvYmplY3QgcmVmZXJlbmNlcyBhcmUgbnVrZWQgYXMgdGhvc2VcbiAgICAgICAgICogY29uc3RpdHV0ZSB0aGUgc2V0IG9mIGVsZW1lbnRzIHdoaWNoIGNhbiBwcm9kdWNlIGEgY3ljbGljIHJlZi5cbiAgICAgICAgICogVGhlIHJlc3Qgb2YgdGhlIG1lbWJlcnMgaXMga2VwdCBpbnRhY3QgYXMgdGhleSBhcmUgaGFybWxlc3MuXG4gICAgICAgICAqIFxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEB0aGlzIHtMZXhFcnJvckluZm99XG4gICAgICAgICAqL1xuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cnVjdExleEVycm9ySW5mbygpIHtcbiAgICAgICAgICAvLyByZW1vdmUgY3ljbGljIHJlZmVyZW5jZXMgYWRkZWQgdG8gZXJyb3IgaW5mbzpcbiAgICAgICAgICAvLyBpbmZvLnl5ID0gbnVsbDtcbiAgICAgICAgICAvLyBpbmZvLmxleGVyID0gbnVsbDtcbiAgICAgICAgICAvLyAuLi5cbiAgICAgICAgICB2YXIgcmVjID0gISF0aGlzLnJlY292ZXJhYmxlO1xuXG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KGtleSkgJiYgdHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgdGhpc1trZXldID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMucmVjb3ZlcmFibGUgPSByZWM7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIHRyYWNrIHRoaXMgaW5zdGFuY2Ugc28gd2UgY2FuIGBkZXN0cm95KClgIGl0IG9uY2Ugd2UgZGVlbSBpdCBzdXBlcmZsdW91cyBhbmQgcmVhZHkgZm9yIGdhcmJhZ2UgY29sbGVjdGlvbiFcbiAgICAgIHRoaXMuX19lcnJvcl9pbmZvcy5wdXNoKHBlaSk7XG5cbiAgICAgIHJldHVybiBwZWk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGhhbmRsZXIgd2hpY2ggaXMgaW52b2tlZCB3aGVuIGEgbGV4ZXIgZXJyb3Igb2NjdXJzLlxuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgcGFyc2VFcnJvcjogZnVuY3Rpb24gbGV4ZXJfcGFyc2VFcnJvcihzdHIsIGhhc2gsIEV4Y2VwdGlvbkNsYXNzKSB7XG4gICAgICBpZiAoIUV4Y2VwdGlvbkNsYXNzKSB7XG4gICAgICAgIEV4Y2VwdGlvbkNsYXNzID0gdGhpcy5KaXNvbkxleGVyRXJyb3I7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnl5KSB7XG4gICAgICAgIGlmICh0aGlzLnl5LnBhcnNlciAmJiB0eXBlb2YgdGhpcy55eS5wYXJzZXIucGFyc2VFcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiB0aGlzLnl5LnBhcnNlci5wYXJzZUVycm9yLmNhbGwodGhpcywgc3RyLCBoYXNoLCBFeGNlcHRpb25DbGFzcykgfHwgdGhpcy5FUlJPUjtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy55eS5wYXJzZUVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMueXkucGFyc2VFcnJvci5jYWxsKHRoaXMsIHN0ciwgaGFzaCwgRXhjZXB0aW9uQ2xhc3MpIHx8IHRoaXMuRVJST1I7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbkNsYXNzKHN0ciwgaGFzaCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIG1ldGhvZCB3aGljaCBpbXBsZW1lbnRzIGB5eWVycm9yKHN0ciwgLi4uYXJncylgIGZ1bmN0aW9uYWxpdHkgZm9yIHVzZSBpbnNpZGUgbGV4ZXIgYWN0aW9ucy5cbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIHl5ZXJyb3I6IGZ1bmN0aW9uIHl5RXJyb3Ioc3RyIC8qLCAuLi5hcmdzICovKSB7XG4gICAgICB2YXIgbGluZW5vX21zZyA9ICcnO1xuXG4gICAgICBpZiAodGhpcy55eWxsb2MpIHtcbiAgICAgICAgbGluZW5vX21zZyA9ICcgb24gbGluZSAnICsgKHRoaXMueXlsaW5lbm8gKyAxKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHAgPSB0aGlzLmNvbnN0cnVjdExleEVycm9ySW5mbyhcbiAgICAgICAgJ0xleGljYWwgZXJyb3InICsgbGluZW5vX21zZyArICc6ICcgKyBzdHIsXG4gICAgICAgIHRoaXMub3B0aW9ucy5sZXhlckVycm9yc0FyZVJlY292ZXJhYmxlXG4gICAgICApO1xuXG4gICAgICAvLyBBZGQgYW55IGV4dHJhIGFyZ3MgdG8gdGhlIGhhc2ggdW5kZXIgdGhlIG5hbWUgYGV4dHJhX2Vycm9yX2F0dHJpYnV0ZXNgOlxuICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gICAgICBpZiAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgcC5leHRyYV9lcnJvcl9hdHRyaWJ1dGVzID0gYXJncztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VFcnJvcihwLmVyclN0ciwgcCwgdGhpcy5KaXNvbkxleGVyRXJyb3IpIHx8IHRoaXMuRVJST1I7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGZpbmFsIGNsZWFudXAgZnVuY3Rpb24gZm9yIHdoZW4gd2UgaGF2ZSBjb21wbGV0ZWQgbGV4aW5nIHRoZSBpbnB1dDtcbiAgICAgKiBtYWtlIGl0IGFuIEFQSSBzbyB0aGF0IGV4dGVybmFsIGNvZGUgY2FuIHVzZSB0aGlzIG9uZSBvbmNlIHVzZXJsYW5kXG4gICAgICogY29kZSBoYXMgZGVjaWRlZCBpdCdzIHRpbWUgdG8gZGVzdHJveSBhbnkgbGluZ2VyaW5nIGxleGVyIGVycm9yXG4gICAgICogaGFzaCBvYmplY3QgaW5zdGFuY2VzIGFuZCB0aGUgbGlrZTogdGhpcyBmdW5jdGlvbiBoZWxwcyB0byBjbGVhblxuICAgICAqIHVwIHRoZXNlIGNvbnN0cnVjdHMsIHdoaWNoICptYXkqIGNhcnJ5IGN5Y2xpYyByZWZlcmVuY2VzIHdoaWNoIHdvdWxkXG4gICAgICogb3RoZXJ3aXNlIHByZXZlbnQgdGhlIGluc3RhbmNlcyBmcm9tIGJlaW5nIHByb3Blcmx5IGFuZCB0aW1lbHlcbiAgICAgKiBnYXJiYWdlLWNvbGxlY3RlZCwgaS5lLiB0aGlzIGZ1bmN0aW9uIGhlbHBzIHByZXZlbnQgbWVtb3J5IGxlYWtzIVxuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgY2xlYW51cEFmdGVyTGV4OiBmdW5jdGlvbiBsZXhlcl9jbGVhbnVwQWZ0ZXJMZXgoZG9fbm90X251a2VfZXJyb3JpbmZvcykge1xuICAgICAgLy8gcHJldmVudCBsaW5nZXJpbmcgY2lyY3VsYXIgcmVmZXJlbmNlcyBmcm9tIGNhdXNpbmcgbWVtb3J5IGxlYWtzOlxuICAgICAgdGhpcy5zZXRJbnB1dCgnJywge30pO1xuXG4gICAgICAvLyBudWtlIHRoZSBlcnJvciBoYXNoIGluZm8gaW5zdGFuY2VzIGNyZWF0ZWQgZHVyaW5nIHRoaXMgcnVuLlxuICAgICAgLy8gVXNlcmxhbmQgY29kZSBtdXN0IENPUFkgYW55IGRhdGEvcmVmZXJlbmNlc1xuICAgICAgLy8gaW4gdGhlIGVycm9yIGhhc2ggaW5zdGFuY2UocykgaXQgaXMgbW9yZSBwZXJtYW5lbnRseSBpbnRlcmVzdGVkIGluLlxuICAgICAgaWYgKCFkb19ub3RfbnVrZV9lcnJvcmluZm9zKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9fZXJyb3JfaW5mb3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB2YXIgZWwgPSB0aGlzLl9fZXJyb3JfaW5mb3NbaV07XG5cbiAgICAgICAgICBpZiAoZWwgJiYgdHlwZW9mIGVsLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGVsLmRlc3Ryb3koKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9fZXJyb3JfaW5mb3MubGVuZ3RoID0gMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNsZWFyIHRoZSBsZXhlciB0b2tlbiBjb250ZXh0OyBpbnRlbmRlZCBmb3IgaW50ZXJuYWwgdXNlIG9ubHlcbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIGNsZWFyOiBmdW5jdGlvbiBsZXhlcl9jbGVhcigpIHtcbiAgICAgIHRoaXMueXl0ZXh0ID0gJyc7XG4gICAgICB0aGlzLnl5bGVuZyA9IDA7XG4gICAgICB0aGlzLm1hdGNoID0gJyc7XG5cbiAgICAgIC8vIC0gRE8gTk9UIHJlc2V0IGB0aGlzLm1hdGNoZWRgXG4gICAgICB0aGlzLm1hdGNoZXMgPSBmYWxzZTtcblxuICAgICAgdGhpcy5fbW9yZSA9IGZhbHNlO1xuICAgICAgdGhpcy5fYmFja3RyYWNrID0gZmFsc2U7XG4gICAgICB2YXIgY29sID0gKHRoaXMueXlsbG9jID8gdGhpcy55eWxsb2MubGFzdF9jb2x1bW4gOiAwKTtcblxuICAgICAgdGhpcy55eWxsb2MgPSB7XG4gICAgICAgIGZpcnN0X2xpbmU6IHRoaXMueXlsaW5lbm8gKyAxLFxuICAgICAgICBmaXJzdF9jb2x1bW46IGNvbCxcbiAgICAgICAgbGFzdF9saW5lOiB0aGlzLnl5bGluZW5vICsgMSxcbiAgICAgICAgbGFzdF9jb2x1bW46IGNvbCxcbiAgICAgICAgcmFuZ2U6IFt0aGlzLm9mZnNldCwgdGhpcy5vZmZzZXRdXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXNldHMgdGhlIGxleGVyLCBzZXRzIG5ldyBpbnB1dFxuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgc2V0SW5wdXQ6IGZ1bmN0aW9uIGxleGVyX3NldElucHV0KGlucHV0LCB5eSkge1xuICAgICAgdGhpcy55eSA9IHl5IHx8IHRoaXMueXkgfHwge307XG5cbiAgICAgIC8vIGFsc28gY2hlY2sgaWYgd2UndmUgZnVsbHkgaW5pdGlhbGl6ZWQgdGhlIGxleGVyIGluc3RhbmNlLFxuICAgICAgLy8gaW5jbHVkaW5nIGV4cGFuc2lvbiB3b3JrIHRvIGJlIGRvbmUgdG8gZ28gZnJvbSBhIGxvYWRlZFxuICAgICAgLy8gbGV4ZXIgdG8gYSB1c2FibGUgbGV4ZXI6XG4gICAgICBpZiAoIXRoaXMuX19kZWNvbXByZXNzZWQpIHtcbiAgICAgICAgLy8gc3RlcCAxOiBkZWNvbXByZXNzIHRoZSByZWdleCBsaXN0OlxuICAgICAgICB2YXIgcnVsZXMgPSB0aGlzLnJ1bGVzO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBydWxlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHZhciBydWxlX3JlID0gcnVsZXNbaV07XG5cbiAgICAgICAgICAvLyBjb21wcmVzc2lvbjogaXMgdGhlIFJFIGFuIHhyZWYgdG8gYW5vdGhlciBSRSBzbG90IGluIHRoZSBydWxlc1tdIHRhYmxlP1xuICAgICAgICAgIGlmICh0eXBlb2YgcnVsZV9yZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJ1bGVzW2ldID0gcnVsZXNbcnVsZV9yZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3RlcCAyOiB1bmZvbGQgdGhlIGNvbmRpdGlvbnNbXSBzZXQgdG8gbWFrZSB0aGVzZSByZWFkeSBmb3IgdXNlOlxuICAgICAgICB2YXIgY29uZGl0aW9ucyA9IHRoaXMuY29uZGl0aW9ucztcblxuICAgICAgICBmb3IgKHZhciBrIGluIGNvbmRpdGlvbnMpIHtcbiAgICAgICAgICB2YXIgc3BlYyA9IGNvbmRpdGlvbnNba107XG4gICAgICAgICAgdmFyIHJ1bGVfaWRzID0gc3BlYy5ydWxlcztcbiAgICAgICAgICB2YXIgbGVuID0gcnVsZV9pZHMubGVuZ3RoO1xuICAgICAgICAgIHZhciBydWxlX3JlZ2V4ZXMgPSBuZXcgQXJyYXkobGVuICsgMSk7ICAgICAgICAgICAgIC8vIHNsb3QgMCBpcyB1bnVzZWQ7IHdlIHVzZSBhIDEtYmFzZWQgaW5kZXggYXBwcm9hY2ggaGVyZSB0byBrZWVwIHRoZSBob3R0ZXN0IGNvZGUgaW4gYGxleGVyX25leHQoKWAgZmFzdCBhbmQgc2ltcGxlISBcbiAgICAgICAgICB2YXIgcnVsZV9uZXdfaWRzID0gbmV3IEFycmF5KGxlbiArIDEpO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGlkeCA9IHJ1bGVfaWRzW2ldO1xuICAgICAgICAgICAgdmFyIHJ1bGVfcmUgPSBydWxlc1tpZHhdO1xuICAgICAgICAgICAgcnVsZV9yZWdleGVzW2kgKyAxXSA9IHJ1bGVfcmU7XG4gICAgICAgICAgICBydWxlX25ld19pZHNbaSArIDFdID0gaWR4O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNwZWMucnVsZXMgPSBydWxlX25ld19pZHM7XG4gICAgICAgICAgc3BlYy5fX3J1bGVfcmVnZXhlcyA9IHJ1bGVfcmVnZXhlcztcbiAgICAgICAgICBzcGVjLl9fcnVsZV9jb3VudCA9IGxlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX19kZWNvbXByZXNzZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9pbnB1dCA9IGlucHV0IHx8ICcnO1xuICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgdGhpcy5fc2lnbmFsZWRfZXJyb3JfdG9rZW4gPSBmYWxzZTtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy55eWxpbmVubyA9IDA7XG4gICAgICB0aGlzLm1hdGNoZWQgPSAnJztcbiAgICAgIHRoaXMuY29uZGl0aW9uU3RhY2sgPSBbJ0lOSVRJQUwnXTtcbiAgICAgIHRoaXMuX19jdXJyZW50UnVsZVNldF9fID0gbnVsbDtcblxuICAgICAgdGhpcy55eWxsb2MgPSB7XG4gICAgICAgIGZpcnN0X2xpbmU6IDEsXG4gICAgICAgIGZpcnN0X2NvbHVtbjogMCxcbiAgICAgICAgbGFzdF9saW5lOiAxLFxuICAgICAgICBsYXN0X2NvbHVtbjogMCxcbiAgICAgICAgcmFuZ2U6IFswLCAwXVxuICAgICAgfTtcblxuICAgICAgdGhpcy5vZmZzZXQgPSAwO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGVkaXQgdGhlIHJlbWFpbmluZyBpbnB1dCB2aWEgdXNlci1zcGVjaWZpZWQgY2FsbGJhY2suXG4gICAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBmb3J3YXJkLWFkanVzdCB0aGUgaW5wdXQtdG8tcGFyc2UsIFxuICAgICAqIGUuZy4gaW5zZXJ0aW5nIG1hY3JvIGV4cGFuc2lvbnMgYW5kIGFsaWtlIGluIHRoZVxuICAgICAqIGlucHV0IHdoaWNoIGhhcyB5ZXQgdG8gYmUgbGV4ZWQuXG4gICAgICogVGhlIGJlaGF2aW91ciBvZiB0aGlzIEFQSSBjb250cmFzdHMgdGhlIGB1bnB1dCgpYCBldCBhbFxuICAgICAqIEFQSXMgYXMgdGhvc2UgYWN0IG9uIHRoZSAqY29uc3VtZWQqIGlucHV0LCB3aGlsZSB0aGlzXG4gICAgICogb25lIGFsbG93cyBvbmUgdG8gbWFuaXB1bGF0ZSB0aGUgZnV0dXJlLCB3aXRob3V0IGltcGFjdGluZ1xuICAgICAqIHRoZSBjdXJyZW50IGB5eWxvY2AgY3Vyc29yIGxvY2F0aW9uIG9yIGFueSBoaXN0b3J5LiBcbiAgICAgKiBcbiAgICAgKiBVc2UgdGhpcyBBUEkgdG8gaGVscCBpbXBsZW1lbnQgQy1wcmVwcm9jZXNzb3ItbGlrZVxuICAgICAqIGAjaW5jbHVkZWAgc3RhdGVtZW50cywgZXRjLlxuICAgICAqIFxuICAgICAqIFRoZSBwcm92aWRlZCBjYWxsYmFjayBtdXN0IGJlIHN5bmNocm9ub3VzIGFuZCBpc1xuICAgICAqIGV4cGVjdGVkIHRvIHJldHVybiB0aGUgZWRpdGVkIGlucHV0IChzdHJpbmcpLlxuICAgICAqXG4gICAgICogVGhlIGBjcHNBcmdgIGFyZ3VtZW50IHZhbHVlIGlzIHBhc3NlZCB0byB0aGUgY2FsbGJhY2tcbiAgICAgKiBhcy1pcy5cbiAgICAgKlxuICAgICAqIGBjYWxsYmFja2AgaW50ZXJmYWNlOiBcbiAgICAgKiBgZnVuY3Rpb24gY2FsbGJhY2soaW5wdXQsIGNwc0FyZylgXG4gICAgICogXG4gICAgICogLSBgaW5wdXRgIHdpbGwgY2FycnkgdGhlIHJlbWFpbmluZy1pbnB1dC10by1sZXggc3RyaW5nXG4gICAgICogICBmcm9tIHRoZSBsZXhlci5cbiAgICAgKiAtIGBjcHNBcmdgIGlzIGBjcHNBcmdgIHBhc3NlZCBpbnRvIHRoaXMgQVBJLlxuICAgICAqIFxuICAgICAqIFRoZSBgdGhpc2AgcmVmZXJlbmNlIGZvciB0aGUgY2FsbGJhY2sgd2lsbCBiZSBzZXQgdG9cbiAgICAgKiByZWZlcmVuY2UgdGhpcyBsZXhlciBpbnN0YW5jZSBzbyB0aGF0IHVzZXJsYW5kIGNvZGVcbiAgICAgKiBpbiB0aGUgY2FsbGJhY2sgY2FuIGVhc2lseSBhbmQgcXVpY2tseSBhY2Nlc3MgYW55IGxleGVyXG4gICAgICogQVBJLiBcbiAgICAgKlxuICAgICAqIFdoZW4gdGhlIGNhbGxiYWNrIHJldHVybnMgYSBub24tc3RyaW5nLXR5cGUgZmFsc2V5IHZhbHVlLFxuICAgICAqIHdlIGFzc3VtZSB0aGUgY2FsbGJhY2sgZGlkIG5vdCBlZGl0IHRoZSBpbnB1dCBhbmQgd2VcbiAgICAgKiB3aWxsIHVzaW5nIHRoZSBpbnB1dCBhcy1pcy5cbiAgICAgKlxuICAgICAqIFdoZW4gdGhlIGNhbGxiYWNrIHJldHVybnMgYSBub24tc3RyaW5nLXR5cGUgdmFsdWUsIGl0XG4gICAgICogaXMgY29udmVydGVkIHRvIGEgc3RyaW5nIGZvciBsZXhpbmcgdmlhIHRoZSBgXCJcIiArIHJldHZhbGBcbiAgICAgKiBvcGVyYXRpb24uIChTZWUgYWxzbyB3aHk6IGh0dHA6Ly8yYWxpdHkuY29tLzIwMTIvMDMvY29udmVydGluZy10by1zdHJpbmcuaHRtbCBcbiAgICAgKiAtLSB0aGF0IHdheSBhbnkgcmV0dXJuZWQgb2JqZWN0J3MgYHRvVmFsdWUoKWAgYW5kIGB0b1N0cmluZygpYFxuICAgICAqIG1ldGhvZHMgd2lsbCBiZSBpbnZva2VkIGluIGEgcHJvcGVyL2Rlc2lyYWJsZSBvcmRlci4pXG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICBlZGl0UmVtYWluaW5nSW5wdXQ6IGZ1bmN0aW9uIGxleGVyX2VkaXRSZW1haW5pbmdJbnB1dChjYWxsYmFjaywgY3BzQXJnKSB7XG4gICAgICB2YXIgcnYgPSBjYWxsYmFjay5jYWxsKHRoaXMsIHRoaXMuX2lucHV0LCBjcHNBcmcpO1xuXG4gICAgICBpZiAodHlwZW9mIHJ2ICE9PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAocnYpIHtcbiAgICAgICAgICB0aGlzLl9pbnB1dCA9ICcnICsgcnY7XG4gICAgICAgIH0gXG4gICAgICAgIC8vIGVsc2U6IGtlZXAgYHRoaXMuX2lucHV0YCBhcyBpcy4gIFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faW5wdXQgPSBydjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNvbnN1bWVzIGFuZCByZXR1cm5zIG9uZSBjaGFyIGZyb20gdGhlIGlucHV0XG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICBpbnB1dDogZnVuY3Rpb24gbGV4ZXJfaW5wdXQoKSB7XG4gICAgICBpZiAoIXRoaXMuX2lucHV0KSB7XG4gICAgICAgIC8vdGhpcy5kb25lID0gdHJ1ZTsgICAgLS0gZG9uJ3Qgc2V0IGBkb25lYCBhcyB3ZSB3YW50IHRoZSBsZXgoKS9uZXh0KCkgQVBJIHRvIGJlIGFibGUgdG8gcHJvZHVjZSBvbmUgY3VzdG9tIEVPRiB0b2tlbiBtYXRjaCBhZnRlciB0aGlzIGFueWhvdy4gKGxleGVyIGNhbiBtYXRjaCBzcGVjaWFsIDw8RU9GPj4gdG9rZW5zIGFuZCBwZXJmb3JtIHVzZXIgYWN0aW9uIGNvZGUgZm9yIGEgPDxFT0Y+PiBtYXRjaCwgYnV0IG9ubHkgZG9lcyBzbyAqb25jZSopXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2ggPSB0aGlzLl9pbnB1dFswXTtcbiAgICAgIHRoaXMueXl0ZXh0ICs9IGNoO1xuICAgICAgdGhpcy55eWxlbmcrKztcbiAgICAgIHRoaXMub2Zmc2V0Kys7XG4gICAgICB0aGlzLm1hdGNoICs9IGNoO1xuICAgICAgdGhpcy5tYXRjaGVkICs9IGNoO1xuXG4gICAgICAvLyBDb3VudCB0aGUgbGluZW51bWJlciB1cCB3aGVuIHdlIGhpdCB0aGUgTEYgKG9yIGEgc3RhbmQtYWxvbmUgQ1IpLlxuICAgICAgLy8gT24gQ1JMRiwgdGhlIGxpbmVudW1iZXIgaXMgaW5jcmVtZW50ZWQgd2hlbiB5b3UgZmV0Y2ggdGhlIENSIG9yIHRoZSBDUkxGIGNvbWJvXG4gICAgICAvLyBhbmQgd2UgYWR2YW5jZSBpbW1lZGlhdGVseSBwYXN0IHRoZSBMRiBhcyB3ZWxsLCByZXR1cm5pbmcgYm90aCB0b2dldGhlciBhcyBpZlxuICAgICAgLy8gaXQgd2FzIGFsbCBhIHNpbmdsZSAnY2hhcmFjdGVyJyBvbmx5LlxuICAgICAgdmFyIHNsaWNlX2xlbiA9IDE7XG5cbiAgICAgIHZhciBsaW5lcyA9IGZhbHNlO1xuXG4gICAgICBpZiAoY2ggPT09ICdcXG4nKSB7XG4gICAgICAgIGxpbmVzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICdcXHInKSB7XG4gICAgICAgIGxpbmVzID0gdHJ1ZTtcbiAgICAgICAgdmFyIGNoMiA9IHRoaXMuX2lucHV0WzFdO1xuXG4gICAgICAgIGlmIChjaDIgPT09ICdcXG4nKSB7XG4gICAgICAgICAgc2xpY2VfbGVuKys7XG4gICAgICAgICAgY2ggKz0gY2gyO1xuICAgICAgICAgIHRoaXMueXl0ZXh0ICs9IGNoMjtcbiAgICAgICAgICB0aGlzLnl5bGVuZysrO1xuICAgICAgICAgIHRoaXMub2Zmc2V0Kys7XG4gICAgICAgICAgdGhpcy5tYXRjaCArPSBjaDI7XG4gICAgICAgICAgdGhpcy5tYXRjaGVkICs9IGNoMjtcbiAgICAgICAgICB0aGlzLnl5bGxvYy5yYW5nZVsxXSsrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChsaW5lcykge1xuICAgICAgICB0aGlzLnl5bGluZW5vKys7XG4gICAgICAgIHRoaXMueXlsbG9jLmxhc3RfbGluZSsrO1xuICAgICAgICB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbiA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbisrO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnl5bGxvYy5yYW5nZVsxXSsrO1xuICAgICAgdGhpcy5faW5wdXQgPSB0aGlzLl9pbnB1dC5zbGljZShzbGljZV9sZW4pO1xuICAgICAgcmV0dXJuIGNoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB1bnNoaWZ0cyBvbmUgY2hhciAob3IgYW4gZW50aXJlIHN0cmluZykgaW50byB0aGUgaW5wdXRcbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIHVucHV0OiBmdW5jdGlvbiBsZXhlcl91bnB1dChjaCkge1xuICAgICAgdmFyIGxlbiA9IGNoLmxlbmd0aDtcbiAgICAgIHZhciBsaW5lcyA9IGNoLnNwbGl0KC8oPzpcXHJcXG4/fFxcbikvZyk7XG4gICAgICB0aGlzLl9pbnB1dCA9IGNoICsgdGhpcy5faW5wdXQ7XG4gICAgICB0aGlzLnl5dGV4dCA9IHRoaXMueXl0ZXh0LnN1YnN0cigwLCB0aGlzLnl5dGV4dC5sZW5ndGggLSBsZW4pO1xuICAgICAgdGhpcy55eWxlbmcgPSB0aGlzLnl5dGV4dC5sZW5ndGg7XG4gICAgICB0aGlzLm9mZnNldCAtPSBsZW47XG4gICAgICB0aGlzLm1hdGNoID0gdGhpcy5tYXRjaC5zdWJzdHIoMCwgdGhpcy5tYXRjaC5sZW5ndGggLSBsZW4pO1xuICAgICAgdGhpcy5tYXRjaGVkID0gdGhpcy5tYXRjaGVkLnN1YnN0cigwLCB0aGlzLm1hdGNoZWQubGVuZ3RoIC0gbGVuKTtcblxuICAgICAgaWYgKGxpbmVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhpcy55eWxpbmVubyAtPSBsaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICB0aGlzLnl5bGxvYy5sYXN0X2xpbmUgPSB0aGlzLnl5bGluZW5vICsgMTtcblxuICAgICAgICAvLyBHZXQgbGFzdCBlbnRpcmVseSBtYXRjaGVkIGxpbmUgaW50byB0aGUgYHByZV9saW5lc1tdYCBhcnJheSdzXG4gICAgICAgIC8vIGxhc3QgaW5kZXggc2xvdDsgd2UgZG9uJ3QgbWluZCB3aGVuIG90aGVyIHByZXZpb3VzbHkgXG4gICAgICAgIC8vIG1hdGNoZWQgbGluZXMgZW5kIHVwIGluIHRoZSBhcnJheSB0b28uIFxuICAgICAgICB2YXIgcHJlID0gdGhpcy5tYXRjaDtcblxuICAgICAgICB2YXIgcHJlX2xpbmVzID0gcHJlLnNwbGl0KC8oPzpcXHJcXG4/fFxcbikvZyk7XG5cbiAgICAgICAgaWYgKHByZV9saW5lcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBwcmUgPSB0aGlzLm1hdGNoZWQ7XG4gICAgICAgICAgcHJlX2xpbmVzID0gcHJlLnNwbGl0KC8oPzpcXHJcXG4/fFxcbikvZyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbiA9IHByZV9saW5lc1twcmVfbGluZXMubGVuZ3RoIC0gMV0ubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy55eWxsb2MubGFzdF9jb2x1bW4gLT0gbGVuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnl5bGxvYy5yYW5nZVsxXSA9IHRoaXMueXlsbG9jLnJhbmdlWzBdICsgdGhpcy55eWxlbmc7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjYWNoZSBtYXRjaGVkIHRleHQgYW5kIGFwcGVuZCBpdCBvbiBuZXh0IGFjdGlvblxuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgbW9yZTogZnVuY3Rpb24gbGV4ZXJfbW9yZSgpIHtcbiAgICAgIHRoaXMuX21vcmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHNpZ25hbCB0aGUgbGV4ZXIgdGhhdCB0aGlzIHJ1bGUgZmFpbHMgdG8gbWF0Y2ggdGhlIGlucHV0LCBzbyB0aGVcbiAgICAgKiBuZXh0IG1hdGNoaW5nIHJ1bGUgKHJlZ2V4KSBzaG91bGQgYmUgdGVzdGVkIGluc3RlYWQuXG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICByZWplY3Q6IGZ1bmN0aW9uIGxleGVyX3JlamVjdCgpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYmFja3RyYWNrX2xleGVyKSB7XG4gICAgICAgIHRoaXMuX2JhY2t0cmFjayA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB3aGVuIHRoZSBgcGFyc2VFcnJvcigpYCBjYWxsIHJldHVybnMsIHdlIE1VU1QgZW5zdXJlIHRoYXQgdGhlIGVycm9yIGlzIHJlZ2lzdGVyZWQuXG4gICAgICAgIC8vIFdlIGFjY29tcGxpc2ggdGhpcyBieSBzaWduYWxpbmcgYW4gJ2Vycm9yJyB0b2tlbiB0byBiZSBwcm9kdWNlZCBmb3IgdGhlIGN1cnJlbnRcbiAgICAgICAgLy8gYC5sZXgoKWAgcnVuLlxuICAgICAgICB2YXIgbGluZW5vX21zZyA9ICcnO1xuXG4gICAgICAgIGlmICh0aGlzLnl5bGxvYykge1xuICAgICAgICAgIGxpbmVub19tc2cgPSAnIG9uIGxpbmUgJyArICh0aGlzLnl5bGluZW5vICsgMSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcCA9IHRoaXMuY29uc3RydWN0TGV4RXJyb3JJbmZvKFxuICAgICAgICAgICdMZXhpY2FsIGVycm9yJyArIGxpbmVub19tc2cgKyAnOiBZb3UgY2FuIG9ubHkgaW52b2tlIHJlamVjdCgpIGluIHRoZSBsZXhlciB3aGVuIHRoZSBsZXhlciBpcyBvZiB0aGUgYmFja3RyYWNraW5nIHBlcnN1YXNpb24gKG9wdGlvbnMuYmFja3RyYWNrX2xleGVyID0gdHJ1ZSkuJyxcbiAgICAgICAgICBmYWxzZVxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuX3NpZ25hbGVkX2Vycm9yX3Rva2VuID0gdGhpcy5wYXJzZUVycm9yKHAuZXJyU3RyLCBwLCB0aGlzLkppc29uTGV4ZXJFcnJvcikgfHwgdGhpcy5FUlJPUjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldGFpbiBmaXJzdCBuIGNoYXJhY3RlcnMgb2YgdGhlIG1hdGNoXG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICBsZXNzOiBmdW5jdGlvbiBsZXhlcl9sZXNzKG4pIHtcbiAgICAgIHJldHVybiB0aGlzLnVucHV0KHRoaXMubWF0Y2guc2xpY2UobikpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gKHBhcnQgb2YgdGhlKSBhbHJlYWR5IG1hdGNoZWQgaW5wdXQsIGkuZS4gZm9yIGVycm9yXG4gICAgICogbWVzc2FnZXMuXG4gICAgICogXG4gICAgICogTGltaXQgdGhlIHJldHVybmVkIHN0cmluZyBsZW5ndGggdG8gYG1heFNpemVgIChkZWZhdWx0OiAyMCkuXG4gICAgICogXG4gICAgICogTGltaXQgdGhlIHJldHVybmVkIHN0cmluZyB0byB0aGUgYG1heExpbmVzYCBudW1iZXIgb2YgbGluZXMgb2ZcbiAgICAgKiBpbnB1dCAoZGVmYXVsdDogMSkuXG4gICAgICogXG4gICAgICogTmVnYXRpdmUgbGltaXQgdmFsdWVzIGVxdWFsICp1bmxpbWl0ZWQqLlxuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgcGFzdElucHV0OiBmdW5jdGlvbiBsZXhlcl9wYXN0SW5wdXQobWF4U2l6ZSwgbWF4TGluZXMpIHtcbiAgICAgIHZhciBwYXN0ID0gdGhpcy5tYXRjaGVkLnN1YnN0cmluZygwLCB0aGlzLm1hdGNoZWQubGVuZ3RoIC0gdGhpcy5tYXRjaC5sZW5ndGgpO1xuXG4gICAgICBpZiAobWF4U2l6ZSA8IDApXG4gICAgICAgIG1heFNpemUgPSBwYXN0Lmxlbmd0aDtcbiAgICAgIGVsc2UgaWYgKCFtYXhTaXplKVxuICAgICAgICBtYXhTaXplID0gMjA7XG5cbiAgICAgIGlmIChtYXhMaW5lcyA8IDApXG4gICAgICAgIG1heExpbmVzID0gcGFzdC5sZW5ndGg7ICAgICAgICAgIC8vIGNhbid0IGV2ZXIgaGF2ZSBtb3JlIGlucHV0IGxpbmVzIHRoYW4gdGhpcyEgXG4gICAgICBlbHNlIGlmICghbWF4TGluZXMpXG4gICAgICAgIG1heExpbmVzID0gMTtcblxuICAgICAgLy8gYHN1YnN0cmAgYW50aWNpcGF0aW9uOiB0cmVhdCBcXHJcXG4gYXMgYSBzaW5nbGUgY2hhcmFjdGVyIGFuZCB0YWtlIGEgbGl0dGxlXG4gICAgICAvLyBtb3JlIHRoYW4gbmVjZXNzYXJ5IHNvIHRoYXQgd2UgY2FuIHN0aWxsIHByb3Blcmx5IGNoZWNrIGFnYWluc3QgbWF4U2l6ZVxuICAgICAgLy8gYWZ0ZXIgd2UndmUgdHJhbnNmb3JtZWQgYW5kIGxpbWl0ZWQgdGhlIG5ld0xpbmVzIGluIGhlcmU6XG4gICAgICBwYXN0ID0gcGFzdC5zdWJzdHIoLW1heFNpemUgKiAyIC0gMik7XG5cbiAgICAgIC8vIG5vdyB0aGF0IHdlIGhhdmUgYSBzaWduaWZpY2FudGx5IHJlZHVjZWQgc3RyaW5nIHRvIHByb2Nlc3MsIHRyYW5zZm9ybSB0aGUgbmV3bGluZXNcbiAgICAgIC8vIGFuZCBjaG9wIHRoZW0sIHRoZW4gbGltaXQgdGhlbTpcbiAgICAgIHZhciBhID0gcGFzdC5yZXBsYWNlKC9cXHJcXG58XFxyL2csICdcXG4nKS5zcGxpdCgnXFxuJyk7XG5cbiAgICAgIGEgPSBhLnNsaWNlKC1tYXhMaW5lcyk7XG4gICAgICBwYXN0ID0gYS5qb2luKCdcXG4nKTtcblxuICAgICAgLy8gV2hlbiwgYWZ0ZXIgbGltaXRpbmcgdG8gbWF4TGluZXMsIHdlIHN0aWxsIGhhdmUgdG9vIG11Y2ggdG8gcmV0dXJuLFxuICAgICAgLy8gZG8gYWRkIGFuIGVsbGlwc2lzIHByZWZpeC4uLlxuICAgICAgaWYgKHBhc3QubGVuZ3RoID4gbWF4U2l6ZSkge1xuICAgICAgICBwYXN0ID0gJy4uLicgKyBwYXN0LnN1YnN0cigtbWF4U2l6ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gKHBhcnQgb2YgdGhlKSB1cGNvbWluZyBpbnB1dCwgaS5lLiBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gICAgICogXG4gICAgICogTGltaXQgdGhlIHJldHVybmVkIHN0cmluZyBsZW5ndGggdG8gYG1heFNpemVgIChkZWZhdWx0OiAyMCkuXG4gICAgICogXG4gICAgICogTGltaXQgdGhlIHJldHVybmVkIHN0cmluZyB0byB0aGUgYG1heExpbmVzYCBudW1iZXIgb2YgbGluZXMgb2YgaW5wdXQgKGRlZmF1bHQ6IDEpLlxuICAgICAqIFxuICAgICAqIE5lZ2F0aXZlIGxpbWl0IHZhbHVlcyBlcXVhbCAqdW5saW1pdGVkKi5cbiAgICAgKlxuICAgICAqID4gIyMjIE5PVEUgIyMjXG4gICAgICogPlxuICAgICAqID4gKlwidXBjb21pbmcgaW5wdXRcIiogaXMgZGVmaW5lZCBhcyB0aGUgd2hvbGUgb2YgdGhlIGJvdGhcbiAgICAgKiA+IHRoZSAqY3VycmVudGx5IGxleGVkKiBpbnB1dCwgdG9nZXRoZXIgd2l0aCBhbnkgcmVtYWluaW5nIGlucHV0XG4gICAgICogPiBmb2xsb3dpbmcgdGhhdC4gKlwiY3VycmVudGx5IGxleGVkXCIqIGlucHV0IGlzIHRoZSBpbnB1dCBcbiAgICAgKiA+IGFscmVhZHkgcmVjb2duaXplZCBieSB0aGUgbGV4ZXIgYnV0IG5vdCB5ZXQgcmV0dXJuZWQgd2l0aFxuICAgICAqID4gdGhlIGxleGVyIHRva2VuLiBUaGlzIGhhcHBlbnMgd2hlbiB5b3UgYXJlIGludm9raW5nIHRoaXMgQVBJXG4gICAgICogPiBmcm9tIGluc2lkZSBhbnkgbGV4ZXIgcnVsZSBhY3Rpb24gY29kZSBibG9jay4gXG4gICAgICogPlxuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgdXBjb21pbmdJbnB1dDogZnVuY3Rpb24gbGV4ZXJfdXBjb21pbmdJbnB1dChtYXhTaXplLCBtYXhMaW5lcykge1xuICAgICAgdmFyIG5leHQgPSB0aGlzLm1hdGNoO1xuXG4gICAgICBpZiAobWF4U2l6ZSA8IDApXG4gICAgICAgIG1heFNpemUgPSBuZXh0Lmxlbmd0aCArIHRoaXMuX2lucHV0Lmxlbmd0aDtcbiAgICAgIGVsc2UgaWYgKCFtYXhTaXplKVxuICAgICAgICBtYXhTaXplID0gMjA7XG5cbiAgICAgIGlmIChtYXhMaW5lcyA8IDApXG4gICAgICAgIG1heExpbmVzID0gbWF4U2l6ZTsgICAgICAgICAgLy8gY2FuJ3QgZXZlciBoYXZlIG1vcmUgaW5wdXQgbGluZXMgdGhhbiB0aGlzISBcbiAgICAgIGVsc2UgaWYgKCFtYXhMaW5lcylcbiAgICAgICAgbWF4TGluZXMgPSAxO1xuXG4gICAgICAvLyBgc3Vic3RyaW5nYCBhbnRpY2lwYXRpb246IHRyZWF0IFxcclxcbiBhcyBhIHNpbmdsZSBjaGFyYWN0ZXIgYW5kIHRha2UgYSBsaXR0bGVcbiAgICAgIC8vIG1vcmUgdGhhbiBuZWNlc3Nhcnkgc28gdGhhdCB3ZSBjYW4gc3RpbGwgcHJvcGVybHkgY2hlY2sgYWdhaW5zdCBtYXhTaXplXG4gICAgICAvLyBhZnRlciB3ZSd2ZSB0cmFuc2Zvcm1lZCBhbmQgbGltaXRlZCB0aGUgbmV3TGluZXMgaW4gaGVyZTpcbiAgICAgIGlmIChuZXh0Lmxlbmd0aCA8IG1heFNpemUgKiAyICsgMikge1xuICAgICAgICBuZXh0ICs9IHRoaXMuX2lucHV0LnN1YnN0cmluZygwLCBtYXhTaXplICogMiArIDIpOyAgIC8vIHN1YnN0cmluZyBpcyBmYXN0ZXIgb24gQ2hyb21lL1Y4IFxuICAgICAgfVxuXG4gICAgICAvLyBub3cgdGhhdCB3ZSBoYXZlIGEgc2lnbmlmaWNhbnRseSByZWR1Y2VkIHN0cmluZyB0byBwcm9jZXNzLCB0cmFuc2Zvcm0gdGhlIG5ld2xpbmVzXG4gICAgICAvLyBhbmQgY2hvcCB0aGVtLCB0aGVuIGxpbWl0IHRoZW06XG4gICAgICB2YXIgYSA9IG5leHQucmVwbGFjZSgvXFxyXFxufFxcci9nLCAnXFxuJykuc3BsaXQoJ1xcbicpO1xuXG4gICAgICBhID0gYS5zbGljZSgwLCBtYXhMaW5lcyk7XG4gICAgICBuZXh0ID0gYS5qb2luKCdcXG4nKTtcblxuICAgICAgLy8gV2hlbiwgYWZ0ZXIgbGltaXRpbmcgdG8gbWF4TGluZXMsIHdlIHN0aWxsIGhhdmUgdG9vIG11Y2ggdG8gcmV0dXJuLFxuICAgICAgLy8gZG8gYWRkIGFuIGVsbGlwc2lzIHBvc3RmaXguLi5cbiAgICAgIGlmIChuZXh0Lmxlbmd0aCA+IG1heFNpemUpIHtcbiAgICAgICAgbmV4dCA9IG5leHQuc3Vic3RyaW5nKDAsIG1heFNpemUpICsgJy4uLic7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gYSBzdHJpbmcgd2hpY2ggZGlzcGxheXMgdGhlIGNoYXJhY3RlciBwb3NpdGlvbiB3aGVyZSB0aGVcbiAgICAgKiBsZXhpbmcgZXJyb3Igb2NjdXJyZWQsIGkuZS4gZm9yIGVycm9yIG1lc3NhZ2VzXG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICBzaG93UG9zaXRpb246IGZ1bmN0aW9uIGxleGVyX3Nob3dQb3NpdGlvbihtYXhQcmVmaXgsIG1heFBvc3RmaXgpIHtcbiAgICAgIHZhciBwcmUgPSB0aGlzLnBhc3RJbnB1dChtYXhQcmVmaXgpLnJlcGxhY2UoL1xccy9nLCAnICcpO1xuICAgICAgdmFyIGMgPSBuZXcgQXJyYXkocHJlLmxlbmd0aCArIDEpLmpvaW4oJy0nKTtcbiAgICAgIHJldHVybiBwcmUgKyB0aGlzLnVwY29taW5nSW5wdXQobWF4UG9zdGZpeCkucmVwbGFjZSgvXFxzL2csICcgJykgKyAnXFxuJyArIGMgKyAnXic7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiBhbiBZWUxMT0MgaW5mbyBvYmplY3QgZGVyaXZlZCBvZmYgdGhlIGdpdmVuIGNvbnRleHQgKGFjdHVhbCwgcHJlY2VkaW5nLCBmb2xsb3dpbmcsIGN1cnJlbnQpLlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB3aGVuIHRoZSBnaXZlbiBgYWN0dWFsYCBsb2NhdGlvbiBpcyBub3QgZ3VhcmFudGVlZCB0byBleGlzdCAoaS5lLiB3aGVuXG4gICAgICogaXQgTUFZIGJlIE5VTEwpIGFuZCB5b3UgTVVTVCBoYXZlIGEgdmFsaWQgbG9jYXRpb24gaW5mbyBvYmplY3QgYW55d2F5OlxuICAgICAqIHRoZW4gd2UgdGFrZSB0aGUgZ2l2ZW4gY29udGV4dCBvZiB0aGUgYHByZWNlZGluZ2AgYW5kIGBmb2xsb3dpbmdgIGxvY2F0aW9ucywgSUZGIHRob3NlIGFyZSBhdmFpbGFibGUsXG4gICAgICogYW5kIHJlY29uc3RydWN0IHRoZSBgYWN0dWFsYCBsb2NhdGlvbiBpbmZvIGZyb20gdGhvc2UuXG4gICAgICogSWYgdGhpcyBmYWlscywgdGhlIGhldXJpc3RpYyBpcyB0byB0YWtlIHRoZSBgY3VycmVudGAgbG9jYXRpb24sIElGRiBhdmFpbGFibGUuXG4gICAgICogSWYgdGhpcyBmYWlscyBhcyB3ZWxsLCB3ZSBhc3N1bWUgdGhlIHNvdWdodCBsb2NhdGlvbiBpcyBhdC9hcm91bmQgdGhlIGN1cnJlbnQgbGV4ZXIgcG9zaXRpb25cbiAgICAgKiBhbmQgdGhlbiBwcm9kdWNlIHRoYXQgb25lIGFzIGEgcmVzcG9uc2UuIERPIE5PVEUgdGhhdCB0aGVzZSBoZXVyaXN0aWMvZGVyaXZlZCBsb2NhdGlvbiBpbmZvXG4gICAgICogdmFsdWVzIE1BWSBiZSBpbmFjY3VyYXRlIVxuICAgICAqXG4gICAgICogTk9URTogYGRlcml2ZUxvY2F0aW9uSW5mbygpYCBBTFdBWVMgcHJvZHVjZXMgYSBsb2NhdGlvbiBpbmZvIG9iamVjdCAqY29weSogb2YgYGFjdHVhbGAsIG5vdCBqdXN0XG4gICAgICogYSAqcmVmZXJlbmNlKiBoZW5jZSBhbGwgaW5wdXQgbG9jYXRpb24gb2JqZWN0cyBjYW4gYmUgYXNzdW1lZCB0byBiZSAnY29uc3RhbnQnIChmdW5jdGlvbiBoYXMgbm8gc2lkZS1lZmZlY3RzKS5cbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIGRlcml2ZUxvY2F0aW9uSW5mbzogZnVuY3Rpb24gbGV4ZXJfZGVyaXZlWVlMTE9DKGFjdHVhbCwgcHJlY2VkaW5nLCBmb2xsb3dpbmcsIGN1cnJlbnQpIHtcbiAgICAgIHZhciBsb2MgPSB7XG4gICAgICAgIGZpcnN0X2xpbmU6IDEsXG4gICAgICAgIGZpcnN0X2NvbHVtbjogMCxcbiAgICAgICAgbGFzdF9saW5lOiAxLFxuICAgICAgICBsYXN0X2NvbHVtbjogMCxcbiAgICAgICAgcmFuZ2U6IFswLCAwXVxuICAgICAgfTtcblxuICAgICAgaWYgKGFjdHVhbCkge1xuICAgICAgICBsb2MuZmlyc3RfbGluZSA9IGFjdHVhbC5maXJzdF9saW5lIHwgMDtcbiAgICAgICAgbG9jLmxhc3RfbGluZSA9IGFjdHVhbC5sYXN0X2xpbmUgfCAwO1xuICAgICAgICBsb2MuZmlyc3RfY29sdW1uID0gYWN0dWFsLmZpcnN0X2NvbHVtbiB8IDA7XG4gICAgICAgIGxvYy5sYXN0X2NvbHVtbiA9IGFjdHVhbC5sYXN0X2NvbHVtbiB8IDA7XG5cbiAgICAgICAgaWYgKGFjdHVhbC5yYW5nZSkge1xuICAgICAgICAgIGxvYy5yYW5nZVswXSA9IGFjdHVhbC5yYW5nZVswXSB8IDA7XG4gICAgICAgICAgbG9jLnJhbmdlWzFdID0gYWN0dWFsLnJhbmdlWzFdIHwgMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobG9jLmZpcnN0X2xpbmUgPD0gMCB8fCBsb2MubGFzdF9saW5lIDwgbG9jLmZpcnN0X2xpbmUpIHtcbiAgICAgICAgLy8gcGxhbiBCOiBoZXVyaXN0aWMgdXNpbmcgcHJlY2VkaW5nIGFuZCBmb2xsb3dpbmc6XG4gICAgICAgIGlmIChsb2MuZmlyc3RfbGluZSA8PSAwICYmIHByZWNlZGluZykge1xuICAgICAgICAgIGxvYy5maXJzdF9saW5lID0gcHJlY2VkaW5nLmxhc3RfbGluZSB8IDA7XG4gICAgICAgICAgbG9jLmZpcnN0X2NvbHVtbiA9IHByZWNlZGluZy5sYXN0X2NvbHVtbiB8IDA7XG5cbiAgICAgICAgICBpZiAocHJlY2VkaW5nLnJhbmdlKSB7XG4gICAgICAgICAgICBsb2MucmFuZ2VbMF0gPSBhY3R1YWwucmFuZ2VbMV0gfCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgobG9jLmxhc3RfbGluZSA8PSAwIHx8IGxvYy5sYXN0X2xpbmUgPCBsb2MuZmlyc3RfbGluZSkgJiYgZm9sbG93aW5nKSB7XG4gICAgICAgICAgbG9jLmxhc3RfbGluZSA9IGZvbGxvd2luZy5maXJzdF9saW5lIHwgMDtcbiAgICAgICAgICBsb2MubGFzdF9jb2x1bW4gPSBmb2xsb3dpbmcuZmlyc3RfY29sdW1uIHwgMDtcblxuICAgICAgICAgIGlmIChmb2xsb3dpbmcucmFuZ2UpIHtcbiAgICAgICAgICAgIGxvYy5yYW5nZVsxXSA9IGFjdHVhbC5yYW5nZVswXSB8IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcGxhbiBDPzogc2VlIGlmIHRoZSAnY3VycmVudCcgbG9jYXRpb24gaXMgdXNlZnVsL3NhbmUgdG9vOlxuICAgICAgICBpZiAobG9jLmZpcnN0X2xpbmUgPD0gMCAmJiBjdXJyZW50ICYmIChsb2MubGFzdF9saW5lIDw9IDAgfHwgY3VycmVudC5sYXN0X2xpbmUgPD0gbG9jLmxhc3RfbGluZSkpIHtcbiAgICAgICAgICBsb2MuZmlyc3RfbGluZSA9IGN1cnJlbnQuZmlyc3RfbGluZSB8IDA7XG4gICAgICAgICAgbG9jLmZpcnN0X2NvbHVtbiA9IGN1cnJlbnQuZmlyc3RfY29sdW1uIHwgMDtcblxuICAgICAgICAgIGlmIChjdXJyZW50LnJhbmdlKSB7XG4gICAgICAgICAgICBsb2MucmFuZ2VbMF0gPSBjdXJyZW50LnJhbmdlWzBdIHwgMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobG9jLmxhc3RfbGluZSA8PSAwICYmIGN1cnJlbnQgJiYgKGxvYy5maXJzdF9saW5lIDw9IDAgfHwgY3VycmVudC5maXJzdF9saW5lID49IGxvYy5maXJzdF9saW5lKSkge1xuICAgICAgICAgIGxvYy5sYXN0X2xpbmUgPSBjdXJyZW50Lmxhc3RfbGluZSB8IDA7XG4gICAgICAgICAgbG9jLmxhc3RfY29sdW1uID0gY3VycmVudC5sYXN0X2NvbHVtbiB8IDA7XG5cbiAgICAgICAgICBpZiAoY3VycmVudC5yYW5nZSkge1xuICAgICAgICAgICAgbG9jLnJhbmdlWzFdID0gY3VycmVudC5yYW5nZVsxXSB8IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHNhbml0aXplOiBmaXggbGFzdF9saW5lIEJFRk9SRSB3ZSBmaXggZmlyc3RfbGluZSBhcyB3ZSB1c2UgdGhlICdyYXcnIHZhbHVlIG9mIHRoZSBsYXR0ZXJcbiAgICAgIC8vIG9yIHBsYW4gRCBoZXVyaXN0aWNzIHRvIHByb2R1Y2UgYSAnc2Vuc2libGUnIGxhc3RfbGluZSB2YWx1ZTpcbiAgICAgIGlmIChsb2MubGFzdF9saW5lIDw9IDApIHtcbiAgICAgICAgaWYgKGxvYy5maXJzdF9saW5lIDw9IDApIHtcbiAgICAgICAgICBsb2MuZmlyc3RfbGluZSA9IHRoaXMueXlsbG9jLmZpcnN0X2xpbmU7XG4gICAgICAgICAgbG9jLmxhc3RfbGluZSA9IHRoaXMueXlsbG9jLmxhc3RfbGluZTtcbiAgICAgICAgICBsb2MuZmlyc3RfY29sdW1uID0gdGhpcy55eWxsb2MuZmlyc3RfY29sdW1uO1xuICAgICAgICAgIGxvYy5sYXN0X2NvbHVtbiA9IHRoaXMueXlsbG9jLmxhc3RfY29sdW1uO1xuICAgICAgICAgIGxvYy5yYW5nZVswXSA9IHRoaXMueXlsbG9jLnJhbmdlWzBdO1xuICAgICAgICAgIGxvYy5yYW5nZVsxXSA9IHRoaXMueXlsbG9jLnJhbmdlWzFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvYy5sYXN0X2xpbmUgPSB0aGlzLnl5bGxvYy5sYXN0X2xpbmU7XG4gICAgICAgICAgbG9jLmxhc3RfY29sdW1uID0gdGhpcy55eWxsb2MubGFzdF9jb2x1bW47XG4gICAgICAgICAgbG9jLnJhbmdlWzFdID0gdGhpcy55eWxsb2MucmFuZ2VbMV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGxvYy5maXJzdF9saW5lIDw9IDApIHtcbiAgICAgICAgbG9jLmZpcnN0X2xpbmUgPSBsb2MubGFzdF9saW5lO1xuICAgICAgICBsb2MuZmlyc3RfY29sdW1uID0gMDsgIC8vIGxvYy5sYXN0X2NvbHVtbjsgXG4gICAgICAgIGxvYy5yYW5nZVsxXSA9IGxvYy5yYW5nZVswXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxvYy5maXJzdF9jb2x1bW4gPCAwKSB7XG4gICAgICAgIGxvYy5maXJzdF9jb2x1bW4gPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAobG9jLmxhc3RfY29sdW1uIDwgMCkge1xuICAgICAgICBsb2MubGFzdF9jb2x1bW4gPSAobG9jLmZpcnN0X2NvbHVtbiA+IDAgPyBsb2MuZmlyc3RfY29sdW1uIDogODApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbG9jO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gYSBzdHJpbmcgd2hpY2ggZGlzcGxheXMgdGhlIGxpbmVzICYgY29sdW1ucyBvZiBpbnB1dCB3aGljaCBhcmUgcmVmZXJlbmNlZCBcbiAgICAgKiBieSB0aGUgZ2l2ZW4gbG9jYXRpb24gaW5mbyByYW5nZSwgcGx1cyBhIGZldyBsaW5lcyBvZiBjb250ZXh0LlxuICAgICAqIFxuICAgICAqIFRoaXMgZnVuY3Rpb24gcHJldHR5LXByaW50cyB0aGUgaW5kaWNhdGVkIHNlY3Rpb24gb2YgdGhlIGlucHV0LCB3aXRoIGxpbmUgbnVtYmVycyBcbiAgICAgKiBhbmQgZXZlcnl0aGluZyFcbiAgICAgKiBcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHZlcnkgdXNlZnVsIHRvIHByb3ZpZGUgaGlnaGx5IHJlYWRhYmxlIGVycm9yIHJlcG9ydHMsIHdoaWxlXG4gICAgICogdGhlIGxvY2F0aW9uIHJhbmdlIG1heSBiZSBzcGVjaWZpZWQgaW4gdmFyaW91cyBmbGV4aWJsZSB3YXlzOlxuICAgICAqIFxuICAgICAqIC0gYGxvY2AgaXMgdGhlIGxvY2F0aW9uIGluZm8gb2JqZWN0IHdoaWNoIHJlZmVyZW5jZXMgdGhlIGFyZWEgd2hpY2ggc2hvdWxkIGJlXG4gICAgICogICBkaXNwbGF5ZWQgYW5kICdtYXJrZWQgdXAnOiB0aGVzZSBsaW5lcyAmIGNvbHVtbnMgb2YgdGV4dCBhcmUgbWFya2VkIHVwIGJ5IGBeYFxuICAgICAqICAgY2hhcmFjdGVycyBiZWxvdyBlYWNoIGNoYXJhY3RlciBpbiB0aGUgZW50aXJlIGlucHV0IHJhbmdlLlxuICAgICAqIFxuICAgICAqIC0gYGNvbnRleHRfbG9jYCBpcyB0aGUgKm9wdGlvbmFsKiBsb2NhdGlvbiBpbmZvIG9iamVjdCB3aGljaCBpbnN0cnVjdHMgdGhpc1xuICAgICAqICAgcHJldHR5LXByaW50ZXIgaG93IG11Y2ggKmxlYWRpbmcqIGNvbnRleHQgc2hvdWxkIGJlIGRpc3BsYXllZCBhbG9uZ3NpZGVcbiAgICAgKiAgIHRoZSBhcmVhIHJlZmVyZW5jZWQgYnkgYGxvY2AuIFRoaXMgY2FuIGhlbHAgcHJvdmlkZSBjb250ZXh0IGZvciB0aGUgZGlzcGxheWVkXG4gICAgICogICBlcnJvciwgZXRjLlxuICAgICAqIFxuICAgICAqICAgV2hlbiB0aGlzIGxvY2F0aW9uIGluZm8gaXMgbm90IHByb3ZpZGVkLCBhIGRlZmF1bHQgY29udGV4dCBvZiAzIGxpbmVzIGlzXG4gICAgICogICB1c2VkLlxuICAgICAqIFxuICAgICAqIC0gYGNvbnRleHRfbG9jMmAgaXMgYW5vdGhlciAqb3B0aW9uYWwqIGxvY2F0aW9uIGluZm8gb2JqZWN0LCB3aGljaCBzZXJ2ZXNcbiAgICAgKiAgIGEgc2ltaWxhciBwdXJwb3NlIHRvIGBjb250ZXh0X2xvY2A6IGl0IHNwZWNpZmllcyB0aGUgYW1vdW50IG9mICp0cmFpbGluZypcbiAgICAgKiAgIGNvbnRleHQgbGluZXMgdG8gZGlzcGxheSBpbiB0aGUgcHJldHR5LXByaW50IG91dHB1dC5cbiAgICAgKiBcbiAgICAgKiAgIFdoZW4gdGhpcyBsb2NhdGlvbiBpbmZvIGlzIG5vdCBwcm92aWRlZCwgYSBkZWZhdWx0IGNvbnRleHQgb2YgMSBsaW5lIG9ubHkgaXNcbiAgICAgKiAgIHVzZWQuXG4gICAgICogXG4gICAgICogU3BlY2lhbCBOb3RlczpcbiAgICAgKiBcbiAgICAgKiAtIHdoZW4gdGhlIGBsb2NgLWluZGljYXRlZCByYW5nZSBpcyB2ZXJ5IGxhcmdlIChhYm91dCA1IGxpbmVzIG9yIG1vcmUpLCB0aGVuXG4gICAgICogICBvbmx5IHRoZSBmaXJzdCBhbmQgbGFzdCBmZXcgbGluZXMgb2YgdGhpcyBibG9jayBhcmUgcHJpbnRlZCB3aGlsZSBhXG4gICAgICogICBgLi4uY29udGludWVkLi4uYCBtZXNzYWdlIHdpbGwgYmUgcHJpbnRlZCBiZXR3ZWVuIHRoZW0uXG4gICAgICogXG4gICAgICogICBUaGlzIHNlcnZlcyB0aGUgcHVycG9zZSBvZiBub3QgcHJpbnRpbmcgYSBodWdlIGFtb3VudCBvZiB0ZXh0IHdoZW4gdGhlIGBsb2NgXG4gICAgICogICByYW5nZSBoYXBwZW5zIHRvIGJlIGh1Z2U6IHRoaXMgd2F5IGEgbWFuYWdlYWJsZSAmIHJlYWRhYmxlIG91dHB1dCByZXN1bHRzXG4gICAgICogICBmb3IgYXJiaXRyYXJ5IGxhcmdlIHJhbmdlcy5cbiAgICAgKiBcbiAgICAgKiAtIHRoaXMgZnVuY3Rpb24gY2FuIGRpc3BsYXkgbGluZXMgb2YgaW5wdXQgd2hpY2ggd2hhdmUgbm90IHlldCBiZWVuIGxleGVkLlxuICAgICAqICAgYHByZXR0eVByaW50UmFuZ2UoKWAgY2FuIGFjY2VzcyB0aGUgZW50aXJlIGlucHV0IVxuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgcHJldHR5UHJpbnRSYW5nZTogZnVuY3Rpb24gbGV4ZXJfcHJldHR5UHJpbnRSYW5nZShsb2MsIGNvbnRleHRfbG9jLCBjb250ZXh0X2xvYzIpIHtcbiAgICAgIGxvYyA9IHRoaXMuZGVyaXZlTG9jYXRpb25JbmZvKGxvYywgY29udGV4dF9sb2MsIGNvbnRleHRfbG9jMik7XG4gICAgICBjb25zdCBDT05URVhUID0gMztcbiAgICAgIGNvbnN0IENPTlRFWFRfVEFJTCA9IDE7XG4gICAgICBjb25zdCBNSU5JTVVNX1ZJU0lCTEVfTk9ORU1QVFlfTElORV9DT1VOVCA9IDI7XG4gICAgICB2YXIgaW5wdXQgPSB0aGlzLm1hdGNoZWQgKyB0aGlzLl9pbnB1dDtcbiAgICAgIHZhciBsaW5lcyA9IGlucHV0LnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBsMCA9IE1hdGgubWF4KDEsIChjb250ZXh0X2xvYyA/IGNvbnRleHRfbG9jLmZpcnN0X2xpbmUgOiBsb2MuZmlyc3RfbGluZSAtIENPTlRFWFQpKTtcbiAgICAgIHZhciBsMSA9IE1hdGgubWF4KDEsIChjb250ZXh0X2xvYzIgPyBjb250ZXh0X2xvYzIubGFzdF9saW5lIDogbG9jLmxhc3RfbGluZSArIENPTlRFWFRfVEFJTCkpO1xuICAgICAgdmFyIGxpbmVub19kaXNwbGF5X3dpZHRoID0gMSArIE1hdGgubG9nMTAobDEgfCAxKSB8IDA7XG4gICAgICB2YXIgd3NfcHJlZml4ID0gbmV3IEFycmF5KGxpbmVub19kaXNwbGF5X3dpZHRoKS5qb2luKCcgJyk7XG4gICAgICB2YXIgbm9uZW1wdHlfbGluZV9pbmRleGVzID0gW107XG5cbiAgICAgIHZhciBydiA9IGxpbmVzLnNsaWNlKGwwIC0gMSwgbDEgKyAxKS5tYXAoZnVuY3Rpb24gaW5qZWN0TGluZU51bWJlcihsaW5lLCBpbmRleCkge1xuICAgICAgICB2YXIgbG5vID0gaW5kZXggKyBsMDtcbiAgICAgICAgdmFyIGxub19wZnggPSAod3NfcHJlZml4ICsgbG5vKS5zdWJzdHIoLWxpbmVub19kaXNwbGF5X3dpZHRoKTtcbiAgICAgICAgdmFyIHJ2ID0gbG5vX3BmeCArICc6ICcgKyBsaW5lO1xuICAgICAgICB2YXIgZXJycGZ4ID0gbmV3IEFycmF5KGxpbmVub19kaXNwbGF5X3dpZHRoICsgMSkuam9pbignXicpO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gMiArIDE7XG4gICAgICAgIHZhciBsZW4gPSAwO1xuXG4gICAgICAgIGlmIChsbm8gPT09IGxvYy5maXJzdF9saW5lKSB7XG4gICAgICAgICAgb2Zmc2V0ICs9IGxvYy5maXJzdF9jb2x1bW47XG5cbiAgICAgICAgICBsZW4gPSBNYXRoLm1heChcbiAgICAgICAgICAgIDIsXG4gICAgICAgICAgICAoKGxubyA9PT0gbG9jLmxhc3RfbGluZSA/IGxvYy5sYXN0X2NvbHVtbiA6IGxpbmUubGVuZ3RoKSkgLSBsb2MuZmlyc3RfY29sdW1uICsgMVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAobG5vID09PSBsb2MubGFzdF9saW5lKSB7XG4gICAgICAgICAgbGVuID0gTWF0aC5tYXgoMiwgbG9jLmxhc3RfY29sdW1uICsgMSk7XG4gICAgICAgIH0gZWxzZSBpZiAobG5vID4gbG9jLmZpcnN0X2xpbmUgJiYgbG5vIDwgbG9jLmxhc3RfbGluZSkge1xuICAgICAgICAgIGxlbiA9IE1hdGgubWF4KDIsIGxpbmUubGVuZ3RoICsgMSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgdmFyIGxlYWQgPSBuZXcgQXJyYXkob2Zmc2V0KS5qb2luKCcuJyk7XG4gICAgICAgICAgdmFyIG1hcmsgPSBuZXcgQXJyYXkobGVuKS5qb2luKCdeJyk7XG4gICAgICAgICAgcnYgKz0gJ1xcbicgKyBlcnJwZnggKyBsZWFkICsgbWFyaztcblxuICAgICAgICAgIGlmIChsaW5lLnRyaW0oKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBub25lbXB0eV9saW5lX2luZGV4ZXMucHVzaChpbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcnYgPSBydi5yZXBsYWNlKC9cXHQvZywgJyAnKTtcbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgfSk7XG5cbiAgICAgIC8vIG5vdyBtYWtlIHN1cmUgd2UgZG9uJ3QgcHJpbnQgYW4gb3Zlcmx5IGxhcmdlIGFtb3VudCBvZiBlcnJvciBhcmVhOiBsaW1pdCBpdCBcbiAgICAgIC8vIHRvIHRoZSB0b3AgYW5kIGJvdHRvbSBsaW5lIGNvdW50OlxuICAgICAgaWYgKG5vbmVtcHR5X2xpbmVfaW5kZXhlcy5sZW5ndGggPiAyICogTUlOSU1VTV9WSVNJQkxFX05PTkVNUFRZX0xJTkVfQ09VTlQpIHtcbiAgICAgICAgdmFyIGNsaXBfc3RhcnQgPSBub25lbXB0eV9saW5lX2luZGV4ZXNbTUlOSU1VTV9WSVNJQkxFX05PTkVNUFRZX0xJTkVfQ09VTlQgLSAxXSArIDE7XG4gICAgICAgIHZhciBjbGlwX2VuZCA9IG5vbmVtcHR5X2xpbmVfaW5kZXhlc1tub25lbXB0eV9saW5lX2luZGV4ZXMubGVuZ3RoIC0gTUlOSU1VTV9WSVNJQkxFX05PTkVNUFRZX0xJTkVfQ09VTlRdIC0gMTtcbiAgICAgICAgdmFyIGludGVybWVkaWF0ZV9saW5lID0gbmV3IEFycmF5KGxpbmVub19kaXNwbGF5X3dpZHRoICsgMSkuam9pbignICcpICsgJyAgKC4uLmNvbnRpbnVlZC4uLiknO1xuICAgICAgICBpbnRlcm1lZGlhdGVfbGluZSArPSAnXFxuJyArIG5ldyBBcnJheShsaW5lbm9fZGlzcGxheV93aWR0aCArIDEpLmpvaW4oJy0nKSArICcgICgtLS0tLS0tLS0tLS0tLS0pJztcbiAgICAgICAgcnYuc3BsaWNlKGNsaXBfc3RhcnQsIGNsaXBfZW5kIC0gY2xpcF9zdGFydCArIDEsIGludGVybWVkaWF0ZV9saW5lKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJ2LmpvaW4oJ1xcbicpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBoZWxwZXIgZnVuY3Rpb24sIHVzZWQgdG8gcHJvZHVjZSBhIGh1bWFuIHJlYWRhYmxlIGRlc2NyaXB0aW9uIGFzIGEgc3RyaW5nLCBnaXZlblxuICAgICAqIHRoZSBpbnB1dCBgeXlsbG9jYCBsb2NhdGlvbiBvYmplY3QuXG4gICAgICogXG4gICAgICogU2V0IGBkaXNwbGF5X3JhbmdlX3Rvb2AgdG8gVFJVRSB0byBpbmNsdWRlIHRoZSBzdHJpbmcgY2hhcmFjdGVyIGluZGV4IHBvc2l0aW9uKHMpXG4gICAgICogaW4gdGhlIGRlc2NyaXB0aW9uIGlmIHRoZSBgeXlsbG9jLnJhbmdlYCBpcyBhdmFpbGFibGUuXG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICBkZXNjcmliZVlZTExPQzogZnVuY3Rpb24gbGV4ZXJfZGVzY3JpYmVfeXlsbG9jKHl5bGxvYywgZGlzcGxheV9yYW5nZV90b28pIHtcbiAgICAgIHZhciBsMSA9IHl5bGxvYy5maXJzdF9saW5lO1xuICAgICAgdmFyIGwyID0geXlsbG9jLmxhc3RfbGluZTtcbiAgICAgIHZhciBjMSA9IHl5bGxvYy5maXJzdF9jb2x1bW47XG4gICAgICB2YXIgYzIgPSB5eWxsb2MubGFzdF9jb2x1bW47XG4gICAgICB2YXIgZGwgPSBsMiAtIGwxO1xuICAgICAgdmFyIGRjID0gYzIgLSBjMTtcbiAgICAgIHZhciBydjtcblxuICAgICAgaWYgKGRsID09PSAwKSB7XG4gICAgICAgIHJ2ID0gJ2xpbmUgJyArIGwxICsgJywgJztcblxuICAgICAgICBpZiAoZGMgPD0gMSkge1xuICAgICAgICAgIHJ2ICs9ICdjb2x1bW4gJyArIGMxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJ2ICs9ICdjb2x1bW5zICcgKyBjMSArICcgLi4gJyArIGMyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBydiA9ICdsaW5lcyAnICsgbDEgKyAnKGNvbHVtbiAnICsgYzEgKyAnKSAuLiAnICsgbDIgKyAnKGNvbHVtbiAnICsgYzIgKyAnKSc7XG4gICAgICB9XG5cbiAgICAgIGlmICh5eWxsb2MucmFuZ2UgJiYgZGlzcGxheV9yYW5nZV90b28pIHtcbiAgICAgICAgdmFyIHIxID0geXlsbG9jLnJhbmdlWzBdO1xuICAgICAgICB2YXIgcjIgPSB5eWxsb2MucmFuZ2VbMV0gLSAxO1xuXG4gICAgICAgIGlmIChyMiA8PSByMSkge1xuICAgICAgICAgIHJ2ICs9ICcge1N0cmluZyBPZmZzZXQ6ICcgKyByMSArICd9JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBydiArPSAnIHtTdHJpbmcgT2Zmc2V0IHJhbmdlOiAnICsgcjEgKyAnIC4uICcgKyByMiArICd9JztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcnY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHRlc3QgdGhlIGxleGVkIHRva2VuOiByZXR1cm4gRkFMU0Ugd2hlbiBub3QgYSBtYXRjaCwgb3RoZXJ3aXNlIHJldHVybiB0b2tlbi5cbiAgICAgKiBcbiAgICAgKiBgbWF0Y2hgIGlzIHN1cHBvc2VkIHRvIGJlIGFuIGFycmF5IGNvbWluZyBvdXQgb2YgYSByZWdleCBtYXRjaCwgaS5lLiBgbWF0Y2hbMF1gXG4gICAgICogY29udGFpbnMgdGhlIGFjdHVhbGx5IG1hdGNoZWQgdGV4dCBzdHJpbmcuXG4gICAgICogXG4gICAgICogQWxzbyBtb3ZlIHRoZSBpbnB1dCBjdXJzb3IgZm9yd2FyZCBhbmQgdXBkYXRlIHRoZSBtYXRjaCBjb2xsZWN0b3JzOlxuICAgICAqIFxuICAgICAqIC0gYHl5dGV4dGBcbiAgICAgKiAtIGB5eWxlbmdgXG4gICAgICogLSBgbWF0Y2hgXG4gICAgICogLSBgbWF0Y2hlc2BcbiAgICAgKiAtIGB5eWxsb2NgXG4gICAgICogLSBgb2Zmc2V0YFxuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgdGVzdF9tYXRjaDogZnVuY3Rpb24gbGV4ZXJfdGVzdF9tYXRjaChtYXRjaCwgaW5kZXhlZF9ydWxlKSB7XG4gICAgICB2YXIgdG9rZW4sIGxpbmVzLCBiYWNrdXAsIG1hdGNoX3N0ciwgbWF0Y2hfc3RyX2xlbjtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5iYWNrdHJhY2tfbGV4ZXIpIHtcbiAgICAgICAgLy8gc2F2ZSBjb250ZXh0XG4gICAgICAgIGJhY2t1cCA9IHtcbiAgICAgICAgICB5eWxpbmVubzogdGhpcy55eWxpbmVubyxcblxuICAgICAgICAgIHl5bGxvYzoge1xuICAgICAgICAgICAgZmlyc3RfbGluZTogdGhpcy55eWxsb2MuZmlyc3RfbGluZSxcbiAgICAgICAgICAgIGxhc3RfbGluZTogdGhpcy55eWxsb2MubGFzdF9saW5lLFxuICAgICAgICAgICAgZmlyc3RfY29sdW1uOiB0aGlzLnl5bGxvYy5maXJzdF9jb2x1bW4sXG4gICAgICAgICAgICBsYXN0X2NvbHVtbjogdGhpcy55eWxsb2MubGFzdF9jb2x1bW4sXG4gICAgICAgICAgICByYW5nZTogdGhpcy55eWxsb2MucmFuZ2Uuc2xpY2UoMClcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgeXl0ZXh0OiB0aGlzLnl5dGV4dCxcbiAgICAgICAgICBtYXRjaDogdGhpcy5tYXRjaCxcbiAgICAgICAgICBtYXRjaGVzOiB0aGlzLm1hdGNoZXMsXG4gICAgICAgICAgbWF0Y2hlZDogdGhpcy5tYXRjaGVkLFxuICAgICAgICAgIHl5bGVuZzogdGhpcy55eWxlbmcsXG4gICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICBfbW9yZTogdGhpcy5fbW9yZSxcbiAgICAgICAgICBfaW5wdXQ6IHRoaXMuX2lucHV0LFxuXG4gICAgICAgICAgLy9fc2lnbmFsZWRfZXJyb3JfdG9rZW46IHRoaXMuX3NpZ25hbGVkX2Vycm9yX3Rva2VuLFxuICAgICAgICAgIHl5OiB0aGlzLnl5LFxuXG4gICAgICAgICAgY29uZGl0aW9uU3RhY2s6IHRoaXMuY29uZGl0aW9uU3RhY2suc2xpY2UoMCksXG4gICAgICAgICAgZG9uZTogdGhpcy5kb25lXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG1hdGNoX3N0ciA9IG1hdGNoWzBdO1xuICAgICAgbWF0Y2hfc3RyX2xlbiA9IG1hdGNoX3N0ci5sZW5ndGg7XG5cbiAgICAgIC8vIGlmIChtYXRjaF9zdHIuaW5kZXhPZignXFxuJykgIT09IC0xIHx8IG1hdGNoX3N0ci5pbmRleE9mKCdcXHInKSAhPT0gLTEpIHtcbiAgICAgIGxpbmVzID0gbWF0Y2hfc3RyLnNwbGl0KC8oPzpcXHJcXG4/fFxcbikvZyk7XG5cbiAgICAgIGlmIChsaW5lcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRoaXMueXlsaW5lbm8gKz0gbGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgdGhpcy55eWxsb2MubGFzdF9saW5lID0gdGhpcy55eWxpbmVubyArIDE7XG4gICAgICAgIHRoaXMueXlsbG9jLmxhc3RfY29sdW1uID0gbGluZXNbbGluZXMubGVuZ3RoIC0gMV0ubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy55eWxsb2MubGFzdF9jb2x1bW4gKz0gbWF0Y2hfc3RyX2xlbjtcbiAgICAgIH1cblxuICAgICAgLy8gfVxuICAgICAgdGhpcy55eXRleHQgKz0gbWF0Y2hfc3RyO1xuXG4gICAgICB0aGlzLm1hdGNoICs9IG1hdGNoX3N0cjtcbiAgICAgIHRoaXMubWF0Y2hlZCArPSBtYXRjaF9zdHI7XG4gICAgICB0aGlzLm1hdGNoZXMgPSBtYXRjaDtcbiAgICAgIHRoaXMueXlsZW5nID0gdGhpcy55eXRleHQubGVuZ3RoO1xuICAgICAgdGhpcy55eWxsb2MucmFuZ2VbMV0gKz0gbWF0Y2hfc3RyX2xlbjtcblxuICAgICAgLy8gcHJldmlvdXMgbGV4IHJ1bGVzIE1BWSBoYXZlIGludm9rZWQgdGhlIGBtb3JlKClgIEFQSSByYXRoZXIgdGhhbiBwcm9kdWNpbmcgYSB0b2tlbjpcbiAgICAgIC8vIHRob3NlIHJ1bGVzIHdpbGwgYWxyZWFkeSBoYXZlIG1vdmVkIHRoaXMgYG9mZnNldGAgZm9yd2FyZCBtYXRjaGluZyB0aGVpciBtYXRjaCBsZW5ndGhzLFxuICAgICAgLy8gaGVuY2Ugd2UgbXVzdCBvbmx5IGFkZCBvdXIgb3duIG1hdGNoIGxlbmd0aCBub3c6XG4gICAgICB0aGlzLm9mZnNldCArPSBtYXRjaF9zdHJfbGVuO1xuXG4gICAgICB0aGlzLl9tb3JlID0gZmFsc2U7XG4gICAgICB0aGlzLl9iYWNrdHJhY2sgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2lucHV0ID0gdGhpcy5faW5wdXQuc2xpY2UobWF0Y2hfc3RyX2xlbik7XG5cbiAgICAgIC8vIGNhbGxpbmcgdGhpcyBtZXRob2Q6XG4gICAgICAvL1xuICAgICAgLy8gICBmdW5jdGlvbiBsZXhlcl9fcGVyZm9ybUFjdGlvbih5eSwgeXlydWxlbnVtYmVyLCBZWV9TVEFSVCkgey4uLn1cbiAgICAgIHRva2VuID0gdGhpcy5wZXJmb3JtQWN0aW9uLmNhbGwoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHRoaXMueXksXG4gICAgICAgIGluZGV4ZWRfcnVsZSxcbiAgICAgICAgdGhpcy5jb25kaXRpb25TdGFja1t0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDFdIC8qID0gWVlfU1RBUlQgKi9cbiAgICAgICk7XG5cbiAgICAgIC8vIG90aGVyd2lzZSwgd2hlbiB0aGUgYWN0aW9uIGNvZGVzIGFyZSBhbGwgc2ltcGxlIHJldHVybiB0b2tlbiBzdGF0ZW1lbnRzOlxuICAgICAgLy90b2tlbiA9IHRoaXMuc2ltcGxlQ2FzZUFjdGlvbkNsdXN0ZXJzW2luZGV4ZWRfcnVsZV07XG5cbiAgICAgIGlmICh0aGlzLmRvbmUgJiYgdGhpcy5faW5wdXQpIHtcbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICh0b2tlbikge1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JhY2t0cmFjaykge1xuICAgICAgICAvLyByZWNvdmVyIGNvbnRleHRcbiAgICAgICAgZm9yICh2YXIgayBpbiBiYWNrdXApIHtcbiAgICAgICAgICB0aGlzW2tdID0gYmFja3VwW2tdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fX2N1cnJlbnRSdWxlU2V0X18gPSBudWxsO1xuICAgICAgICByZXR1cm4gZmFsc2U7ICAvLyBydWxlIGFjdGlvbiBjYWxsZWQgcmVqZWN0KCkgaW1wbHlpbmcgdGhlIG5leHQgcnVsZSBzaG91bGQgYmUgdGVzdGVkIGluc3RlYWQuIFxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9zaWduYWxlZF9lcnJvcl90b2tlbikge1xuICAgICAgICAvLyBwcm9kdWNlIG9uZSAnZXJyb3InIHRva2VuIGFzIGAucGFyc2VFcnJvcigpYCBpbiBgcmVqZWN0KClgXG4gICAgICAgIC8vIGRpZCBub3QgZ3VhcmFudGVlIGEgZmFpbHVyZSBzaWduYWwgYnkgdGhyb3dpbmcgYW4gZXhjZXB0aW9uIVxuICAgICAgICB0b2tlbiA9IHRoaXMuX3NpZ25hbGVkX2Vycm9yX3Rva2VuO1xuXG4gICAgICAgIHRoaXMuX3NpZ25hbGVkX2Vycm9yX3Rva2VuID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gbmV4dCBtYXRjaCBpbiBpbnB1dFxuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgbmV4dDogZnVuY3Rpb24gbGV4ZXJfbmV4dCgpIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICByZXR1cm4gdGhpcy5FT0Y7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5faW5wdXQpIHtcbiAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRva2VuLCBtYXRjaCwgdGVtcE1hdGNoLCBpbmRleDtcblxuICAgICAgaWYgKCF0aGlzLl9tb3JlKSB7XG4gICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNwZWMgPSB0aGlzLl9fY3VycmVudFJ1bGVTZXRfXztcblxuICAgICAgaWYgKCFzcGVjKSB7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcnVsZXNldCBjYWNoZSBhcyB3ZSBhcHBhcmVudGx5IGVuY291bnRlcmVkIGEgc3RhdGUgY2hhbmdlIG9yIGp1c3Qgc3RhcnRlZCBsZXhpbmcuXG4gICAgICAgIC8vIFRoZSBjYWNoZSBpcyBzZXQgdXAgZm9yIGZhc3QgbG9va3VwIC0tIHdlIGFzc3VtZSBhIGxleGVyIHdpbGwgc3dpdGNoIHN0YXRlcyBtdWNoIGxlc3Mgb2Z0ZW4gdGhhbiBpdCB3aWxsXG4gICAgICAgIC8vIGludm9rZSB0aGUgYGxleCgpYCB0b2tlbi1wcm9kdWNpbmcgQVBJIGFuZCByZWxhdGVkIEFQSXMsIGhlbmNlIGNhY2hpbmcgdGhlIHNldCBmb3IgZGlyZWN0IGFjY2VzcyBoZWxwc1xuICAgICAgICAvLyBzcGVlZCB1cCB0aG9zZSBhY3Rpdml0aWVzIGEgdGlueSBiaXQuXG4gICAgICAgIHNwZWMgPSB0aGlzLl9fY3VycmVudFJ1bGVTZXRfXyA9IHRoaXMuX2N1cnJlbnRSdWxlcygpO1xuXG4gICAgICAgIC8vIENoZWNrIHdoZXRoZXIgYSAqc2FuZSogY29uZGl0aW9uIGhhcyBiZWVuIHB1c2hlZCBiZWZvcmU6IHRoaXMgbWFrZXMgdGhlIGxleGVyIHJvYnVzdCBhZ2FpbnN0XG4gICAgICAgIC8vIHVzZXItcHJvZ3JhbW1lciBidWdzIHN1Y2ggYXMgaHR0cHM6Ly9naXRodWIuY29tL3phYWNoL2ppc29uLWxleC9pc3N1ZXMvMTlcbiAgICAgICAgaWYgKCFzcGVjIHx8ICFzcGVjLnJ1bGVzKSB7XG4gICAgICAgICAgdmFyIGxpbmVub19tc2cgPSAnJztcblxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudHJhY2tQb3NpdGlvbikge1xuICAgICAgICAgICAgbGluZW5vX21zZyA9ICcgb24gbGluZSAnICsgKHRoaXMueXlsaW5lbm8gKyAxKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcCA9IHRoaXMuY29uc3RydWN0TGV4RXJyb3JJbmZvKFxuICAgICAgICAgICAgJ0ludGVybmFsIGxleGVyIGVuZ2luZSBlcnJvcicgKyBsaW5lbm9fbXNnICsgJzogVGhlIGxleCBncmFtbWFyIHByb2dyYW1tZXIgcHVzaGVkIGEgbm9uLWV4aXN0aW5nIGNvbmRpdGlvbiBuYW1lIFwiJyArIHRoaXMudG9wU3RhdGUoKSArICdcIjsgdGhpcyBpcyBhIGZhdGFsIGVycm9yIGFuZCBzaG91bGQgYmUgcmVwb3J0ZWQgdG8gdGhlIGFwcGxpY2F0aW9uIHByb2dyYW1tZXIgdGVhbSEnLFxuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgLy8gcHJvZHVjZSBvbmUgJ2Vycm9yJyB0b2tlbiB1bnRpbCB0aGlzIHNpdHVhdGlvbiBoYXMgYmVlbiByZXNvbHZlZCwgbW9zdCBwcm9iYWJseSBieSBwYXJzZSB0ZXJtaW5hdGlvbiFcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUVycm9yKHAuZXJyU3RyLCBwLCB0aGlzLkppc29uTGV4ZXJFcnJvcikgfHwgdGhpcy5FUlJPUjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcnVsZV9pZHMgPSBzcGVjLnJ1bGVzO1xuICAgICAgdmFyIHJlZ2V4ZXMgPSBzcGVjLl9fcnVsZV9yZWdleGVzO1xuICAgICAgdmFyIGxlbiA9IHNwZWMuX19ydWxlX2NvdW50O1xuXG4gICAgICAvLyBOb3RlOiB0aGUgYXJyYXlzIGFyZSAxLWJhc2VkLCB3aGlsZSBgbGVuYCBpdHNlbGYgaXMgYSB2YWxpZCBpbmRleCxcbiAgICAgIC8vIGhlbmNlIHRoZSBub24tc3RhbmRhcmQgbGVzcy1vci1lcXVhbCBjaGVjayBpbiB0aGUgbmV4dCBsb29wIGNvbmRpdGlvbiFcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IGxlbjsgaSsrKSB7XG4gICAgICAgIHRlbXBNYXRjaCA9IHRoaXMuX2lucHV0Lm1hdGNoKHJlZ2V4ZXNbaV0pO1xuXG4gICAgICAgIGlmICh0ZW1wTWF0Y2ggJiYgKCFtYXRjaCB8fCB0ZW1wTWF0Y2hbMF0ubGVuZ3RoID4gbWF0Y2hbMF0ubGVuZ3RoKSkge1xuICAgICAgICAgIG1hdGNoID0gdGVtcE1hdGNoO1xuICAgICAgICAgIGluZGV4ID0gaTtcblxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYmFja3RyYWNrX2xleGVyKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHRoaXMudGVzdF9tYXRjaCh0ZW1wTWF0Y2gsIHJ1bGVfaWRzW2ldKTtcblxuICAgICAgICAgICAgaWYgKHRva2VuICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JhY2t0cmFjaykge1xuICAgICAgICAgICAgICBtYXRjaCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgY29udGludWU7ICAvLyBydWxlIGFjdGlvbiBjYWxsZWQgcmVqZWN0KCkgaW1wbHlpbmcgYSBydWxlIE1JU21hdGNoLiBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGVsc2U6IHRoaXMgaXMgYSBsZXhlciBydWxlIHdoaWNoIGNvbnN1bWVzIGlucHV0IHdpdGhvdXQgcHJvZHVjaW5nIGEgdG9rZW4gKGUuZy4gd2hpdGVzcGFjZSlcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMub3B0aW9ucy5mbGV4KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHRva2VuID0gdGhpcy50ZXN0X21hdGNoKG1hdGNoLCBydWxlX2lkc1tpbmRleF0pO1xuXG4gICAgICAgIGlmICh0b2tlbiAhPT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlbHNlOiB0aGlzIGlzIGEgbGV4ZXIgcnVsZSB3aGljaCBjb25zdW1lcyBpbnB1dCB3aXRob3V0IHByb2R1Y2luZyBhIHRva2VuIChlLmcuIHdoaXRlc3BhY2UpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9pbnB1dCkge1xuICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIHJldHVybiB0aGlzLkVPRjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBsaW5lbm9fbXNnID0gJyc7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50cmFja1Bvc2l0aW9uKSB7XG4gICAgICAgICAgbGluZW5vX21zZyA9ICcgb24gbGluZSAnICsgKHRoaXMueXlsaW5lbm8gKyAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwID0gdGhpcy5jb25zdHJ1Y3RMZXhFcnJvckluZm8oXG4gICAgICAgICAgJ0xleGljYWwgZXJyb3InICsgbGluZW5vX21zZyArICc6IFVucmVjb2duaXplZCB0ZXh0LicsXG4gICAgICAgICAgdGhpcy5vcHRpb25zLmxleGVyRXJyb3JzQXJlUmVjb3ZlcmFibGVcbiAgICAgICAgKTtcblxuICAgICAgICB2YXIgcGVuZGluZ0lucHV0ID0gdGhpcy5faW5wdXQ7XG4gICAgICAgIHZhciBhY3RpdmVDb25kaXRpb24gPSB0aGlzLnRvcFN0YXRlKCk7XG4gICAgICAgIHZhciBjb25kaXRpb25TdGFja0RlcHRoID0gdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGg7XG4gICAgICAgIHRva2VuID0gdGhpcy5wYXJzZUVycm9yKHAuZXJyU3RyLCBwLCB0aGlzLkppc29uTGV4ZXJFcnJvcikgfHwgdGhpcy5FUlJPUjtcblxuICAgICAgICBpZiAodG9rZW4gPT09IHRoaXMuRVJST1IpIHtcbiAgICAgICAgICAvLyB3ZSBjYW4gdHJ5IHRvIHJlY292ZXIgZnJvbSBhIGxleGVyIGVycm9yIHRoYXQgYHBhcnNlRXJyb3IoKWAgZGlkIG5vdCAncmVjb3ZlcicgZm9yIHVzXG4gICAgICAgICAgLy8gYnkgbW92aW5nIGZvcndhcmQgYXQgbGVhc3Qgb25lIGNoYXJhY3RlciBhdCBhIHRpbWUgSUZGIHRoZSAodXNlci1zcGVjaWZpZWQ/KSBgcGFyc2VFcnJvcigpYFxuICAgICAgICAgIC8vIGhhcyBub3QgY29uc3VtZWQvbW9kaWZpZWQgYW55IHBlbmRpbmcgaW5wdXQgb3IgY2hhbmdlZCBzdGF0ZSBpbiB0aGUgZXJyb3IgaGFuZGxlcjpcbiAgICAgICAgICBpZiAoIXRoaXMubWF0Y2hlcyAmJiAvLyBhbmQgbWFrZSBzdXJlIHRoZSBpbnB1dCBoYXMgYmVlbiBtb2RpZmllZC9jb25zdW1lZCAuLi5cbiAgICAgICAgICBwZW5kaW5nSW5wdXQgPT09IHRoaXMuX2lucHV0ICYmIC8vIC4uLm9yIHRoZSBsZXhlciBzdGF0ZSBoYXMgYmVlbiBtb2RpZmllZCBzaWduaWZpY2FudGx5IGVub3VnaFxuICAgICAgICAgIC8vIHRvIG1lcml0IGEgbm9uLWNvbnN1bWluZyBlcnJvciBoYW5kbGluZyBhY3Rpb24gcmlnaHQgbm93LlxuICAgICAgICAgIGFjdGl2ZUNvbmRpdGlvbiA9PT0gdGhpcy50b3BTdGF0ZSgpICYmIGNvbmRpdGlvblN0YWNrRGVwdGggPT09IHRoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gbmV4dCBtYXRjaCB0aGF0IGhhcyBhIHRva2VuXG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICBsZXg6IGZ1bmN0aW9uIGxleGVyX2xleCgpIHtcbiAgICAgIHZhciByO1xuXG4gICAgICAvLyBhbGxvdyB0aGUgUFJFL1BPU1QgaGFuZGxlcnMgc2V0L21vZGlmeSB0aGUgcmV0dXJuIHRva2VuIGZvciBtYXhpbXVtIGZsZXhpYmlsaXR5IG9mIHRoZSBnZW5lcmF0ZWQgbGV4ZXI6XG4gICAgICBpZiAodHlwZW9mIHRoaXMucHJlX2xleCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByID0gdGhpcy5wcmVfbGV4LmNhbGwodGhpcywgMCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnByZV9sZXggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gKGFsc28gYWNjb3VudCBmb3IgYSB1c2VyZGVmIGZ1bmN0aW9uIHdoaWNoIGRvZXMgbm90IHJldHVybiBhbnkgdmFsdWU6IGtlZXAgdGhlIHRva2VuIGFzIGlzKVxuICAgICAgICByID0gdGhpcy5vcHRpb25zLnByZV9sZXguY2FsbCh0aGlzLCByKSB8fCByO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy55eSAmJiB0eXBlb2YgdGhpcy55eS5wcmVfbGV4ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIChhbHNvIGFjY291bnQgZm9yIGEgdXNlcmRlZiBmdW5jdGlvbiB3aGljaCBkb2VzIG5vdCByZXR1cm4gYW55IHZhbHVlOiBrZWVwIHRoZSB0b2tlbiBhcyBpcylcbiAgICAgICAgciA9IHRoaXMueXkucHJlX2xleC5jYWxsKHRoaXMsIHIpIHx8IHI7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICghcikge1xuICAgICAgICByID0gdGhpcy5uZXh0KCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnl5ICYmIHR5cGVvZiB0aGlzLnl5LnBvc3RfbGV4ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIChhbHNvIGFjY291bnQgZm9yIGEgdXNlcmRlZiBmdW5jdGlvbiB3aGljaCBkb2VzIG5vdCByZXR1cm4gYW55IHZhbHVlOiBrZWVwIHRoZSB0b2tlbiBhcyBpcylcbiAgICAgICAgciA9IHRoaXMueXkucG9zdF9sZXguY2FsbCh0aGlzLCByKSB8fCByO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5wb3N0X2xleCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyAoYWxzbyBhY2NvdW50IGZvciBhIHVzZXJkZWYgZnVuY3Rpb24gd2hpY2ggZG9lcyBub3QgcmV0dXJuIGFueSB2YWx1ZToga2VlcCB0aGUgdG9rZW4gYXMgaXMpXG4gICAgICAgIHIgPSB0aGlzLm9wdGlvbnMucG9zdF9sZXguY2FsbCh0aGlzLCByKSB8fCByO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHRoaXMucG9zdF9sZXggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gKGFsc28gYWNjb3VudCBmb3IgYSB1c2VyZGVmIGZ1bmN0aW9uIHdoaWNoIGRvZXMgbm90IHJldHVybiBhbnkgdmFsdWU6IGtlZXAgdGhlIHRva2VuIGFzIGlzKVxuICAgICAgICByID0gdGhpcy5wb3N0X2xleC5jYWxsKHRoaXMsIHIpIHx8IHI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gbmV4dCBtYXRjaCB0aGF0IGhhcyBhIHRva2VuLiBJZGVudGljYWwgdG8gdGhlIGBsZXgoKWAgQVBJIGJ1dCBkb2VzIG5vdCBpbnZva2UgYW55IG9mIHRoZSBcbiAgICAgKiBgcHJlX2xleCgpYCBub3IgYW55IG9mIHRoZSBgcG9zdF9sZXgoKWAgY2FsbGJhY2tzLlxuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgZmFzdExleDogZnVuY3Rpb24gbGV4ZXJfZmFzdExleCgpIHtcbiAgICAgIHZhciByO1xuXG4gICAgICB3aGlsZSAoIXIpIHtcbiAgICAgICAgciA9IHRoaXMubmV4dCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIGluZm8gYWJvdXQgdGhlIGxleGVyIHN0YXRlIHRoYXQgY2FuIGhlbHAgYSBwYXJzZXIgb3Igb3RoZXIgbGV4ZXIgQVBJIHVzZXIgdG8gdXNlIHRoZVxuICAgICAqIG1vc3QgZWZmaWNpZW50IG1lYW5zIGF2YWlsYWJsZS4gVGhpcyBBUEkgaXMgcHJvdmlkZWQgdG8gYWlkIHJ1bi10aW1lIHBlcmZvcm1hbmNlIGZvciBsYXJnZXJcbiAgICAgKiBzeXN0ZW1zIHdoaWNoIGVtcGxveSB0aGlzIGxleGVyLlxuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgY2FuSVVzZTogZnVuY3Rpb24gbGV4ZXJfY2FuSVVzZSgpIHtcbiAgICAgIHZhciBydiA9IHtcbiAgICAgICAgZmFzdExleDogISh0eXBlb2YgdGhpcy5wcmVfbGV4ID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiB0aGlzLm9wdGlvbnMucHJlX2xleCA9PT0gJ2Z1bmN0aW9uJyB8fCB0aGlzLnl5ICYmIHR5cGVvZiB0aGlzLnl5LnByZV9sZXggPT09ICdmdW5jdGlvbicgfHwgdGhpcy55eSAmJiB0eXBlb2YgdGhpcy55eS5wb3N0X2xleCA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgdGhpcy5vcHRpb25zLnBvc3RfbGV4ID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiB0aGlzLnBvc3RfbGV4ID09PSAnZnVuY3Rpb24nKSAmJiB0eXBlb2YgdGhpcy5mYXN0TGV4ID09PSAnZnVuY3Rpb24nXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gcnY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGJhY2t3YXJkcyBjb21wYXRpYmxlIGFsaWFzIGZvciBgcHVzaFN0YXRlKClgO1xuICAgICAqIHRoZSBsYXR0ZXIgaXMgc3ltbWV0cmljYWwgd2l0aCBgcG9wU3RhdGUoKWAgYW5kIHdlIGFkdmlzZSB0byB1c2VcbiAgICAgKiB0aG9zZSBBUElzIGluIGFueSBtb2Rlcm4gbGV4ZXIgY29kZSwgcmF0aGVyIHRoYW4gYGJlZ2luKClgLlxuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgYmVnaW46IGZ1bmN0aW9uIGxleGVyX2JlZ2luKGNvbmRpdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YXRlKGNvbmRpdGlvbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGFjdGl2YXRlcyBhIG5ldyBsZXhlciBjb25kaXRpb24gc3RhdGUgKHB1c2hlcyB0aGUgbmV3IGxleGVyXG4gICAgICogY29uZGl0aW9uIHN0YXRlIG9udG8gdGhlIGNvbmRpdGlvbiBzdGFjaylcbiAgICAgKiBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHRoaXMge1JlZ0V4cExleGVyfVxuICAgICAqL1xuICAgIHB1c2hTdGF0ZTogZnVuY3Rpb24gbGV4ZXJfcHVzaFN0YXRlKGNvbmRpdGlvbikge1xuICAgICAgdGhpcy5jb25kaXRpb25TdGFjay5wdXNoKGNvbmRpdGlvbik7XG4gICAgICB0aGlzLl9fY3VycmVudFJ1bGVTZXRfXyA9IG51bGw7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcG9wIHRoZSBwcmV2aW91c2x5IGFjdGl2ZSBsZXhlciBjb25kaXRpb24gc3RhdGUgb2ZmIHRoZSBjb25kaXRpb25cbiAgICAgKiBzdGFja1xuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgcG9wU3RhdGU6IGZ1bmN0aW9uIGxleGVyX3BvcFN0YXRlKCkge1xuICAgICAgdmFyIG4gPSB0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDE7XG5cbiAgICAgIGlmIChuID4gMCkge1xuICAgICAgICB0aGlzLl9fY3VycmVudFJ1bGVTZXRfXyA9IG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvblN0YWNrLnBvcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uU3RhY2tbMF07XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiB0aGUgY3VycmVudGx5IGFjdGl2ZSBsZXhlciBjb25kaXRpb24gc3RhdGU7IHdoZW4gYW4gaW5kZXhcbiAgICAgKiBhcmd1bWVudCBpcyBwcm92aWRlZCBpdCBwcm9kdWNlcyB0aGUgTi10aCBwcmV2aW91cyBjb25kaXRpb24gc3RhdGUsXG4gICAgICogaWYgYXZhaWxhYmxlXG4gICAgICogXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0aGlzIHtSZWdFeHBMZXhlcn1cbiAgICAgKi9cbiAgICB0b3BTdGF0ZTogZnVuY3Rpb24gbGV4ZXJfdG9wU3RhdGUobikge1xuICAgICAgbiA9IHRoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMSAtIE1hdGguYWJzKG4gfHwgMCk7XG5cbiAgICAgIGlmIChuID49IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uU3RhY2tbbl07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJ0lOSVRJQUwnO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiAoaW50ZXJuYWwpIGRldGVybWluZSB0aGUgbGV4ZXIgcnVsZSBzZXQgd2hpY2ggaXMgYWN0aXZlIGZvciB0aGVcbiAgICAgKiBjdXJyZW50bHkgYWN0aXZlIGxleGVyIGNvbmRpdGlvbiBzdGF0ZVxuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgX2N1cnJlbnRSdWxlczogZnVuY3Rpb24gbGV4ZXJfX2N1cnJlbnRSdWxlcygpIHtcbiAgICAgIGlmICh0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAmJiB0aGlzLmNvbmRpdGlvblN0YWNrW3RoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uc1t0aGlzLmNvbmRpdGlvblN0YWNrW3RoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMV1dO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uc1snSU5JVElBTCddO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gdGhlIG51bWJlciBvZiBzdGF0ZXMgY3VycmVudGx5IG9uIHRoZSBzdGFja1xuICAgICAqIFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdGhpcyB7UmVnRXhwTGV4ZXJ9XG4gICAgICovXG4gICAgc3RhdGVTdGFja1NpemU6IGZ1bmN0aW9uIGxleGVyX3N0YXRlU3RhY2tTaXplKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoO1xuICAgIH0sXG5cbiAgICBvcHRpb25zOiB7XG4gICAgICB0cmFja1Bvc2l0aW9uOiB0cnVlXG4gICAgfSxcblxuICAgIEppc29uTGV4ZXJFcnJvcjogSmlzb25MZXhlckVycm9yLFxuXG4gICAgcGVyZm9ybUFjdGlvbjogZnVuY3Rpb24gbGV4ZXJfX3BlcmZvcm1BY3Rpb24oeXksIHl5cnVsZW51bWJlciwgWVlfU1RBUlQpIHtcbiAgICAgIHZhciB5eV8gPSB0aGlzO1xuICAgICAgdmFyIFlZU1RBVEUgPSBZWV9TVEFSVDtcblxuICAgICAgc3dpdGNoICh5eXJ1bGVudW1iZXIpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgLyohIENvbmRpdGlvbnM6OiBJTklUSUFMICovXG4gICAgICAgIC8qISBSdWxlOjogICAgICAgXFxzKyAqL1xuICAgICAgICAvKiBza2lwIHdoaXRlc3BhY2UgKi9cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzLnNpbXBsZUNhc2VBY3Rpb25DbHVzdGVyc1t5eXJ1bGVudW1iZXJdO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBzaW1wbGVDYXNlQWN0aW9uQ2x1c3RlcnM6IHtcbiAgICAgIC8qISBDb25kaXRpb25zOjogSU5JVElBTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICAoLS1bMC05YS16LUEtWi1dKikgKi9cbiAgICAgIDA6IDEzLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IElOSVRJQUwgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgXFwqICovXG4gICAgICAyOiA1LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IElOSVRJQUwgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgXFwvICovXG4gICAgICAzOiA2LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IElOSVRJQUwgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgXFwrICovXG4gICAgICA0OiAzLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IElOSVRJQUwgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgLSAqL1xuICAgICAgNTogNCxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBJTklUSUFMICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIChbMC05XSsoXFwuWzAtOV0qKT98XFwuWzAtOV0rKXB4XFxiICovXG4gICAgICA2OiAxNSxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBJTklUSUFMICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIChbMC05XSsoXFwuWzAtOV0qKT98XFwuWzAtOV0rKWNtXFxiICovXG4gICAgICA3OiAxNSxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBJTklUSUFMICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIChbMC05XSsoXFwuWzAtOV0qKT98XFwuWzAtOV0rKW1tXFxiICovXG4gICAgICA4OiAxNSxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBJTklUSUFMICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIChbMC05XSsoXFwuWzAtOV0qKT98XFwuWzAtOV0rKWluXFxiICovXG4gICAgICA5OiAxNSxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBJTklUSUFMICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIChbMC05XSsoXFwuWzAtOV0qKT98XFwuWzAtOV0rKXB0XFxiICovXG4gICAgICAxMDogMTUsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogSU5JVElBTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICAoWzAtOV0rKFxcLlswLTldKik/fFxcLlswLTldKylwY1xcYiAqL1xuICAgICAgMTE6IDE1LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IElOSVRJQUwgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgKFswLTldKyhcXC5bMC05XSopP3xcXC5bMC05XSspZGVnXFxiICovXG4gICAgICAxMjogMTYsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogSU5JVElBTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICAoWzAtOV0rKFxcLlswLTldKik/fFxcLlswLTldKylncmFkXFxiICovXG4gICAgICAxMzogMTYsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogSU5JVElBTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICAoWzAtOV0rKFxcLlswLTldKik/fFxcLlswLTldKylyYWRcXGIgKi9cbiAgICAgIDE0OiAxNixcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBJTklUSUFMICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIChbMC05XSsoXFwuWzAtOV0qKT98XFwuWzAtOV0rKXR1cm5cXGIgKi9cbiAgICAgIDE1OiAxNixcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBJTklUSUFMICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIChbMC05XSsoXFwuWzAtOV0qKT98XFwuWzAtOV0rKXNcXGIgKi9cbiAgICAgIDE2OiAxNyxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBJTklUSUFMICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIChbMC05XSsoXFwuWzAtOV0qKT98XFwuWzAtOV0rKW1zXFxiICovXG4gICAgICAxNzogMTcsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogSU5JVElBTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICAoWzAtOV0rKFxcLlswLTldKik/fFxcLlswLTldKylIelxcYiAqL1xuICAgICAgMTg6IDE4LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IElOSVRJQUwgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgKFswLTldKyhcXC5bMC05XSopP3xcXC5bMC05XSspa0h6XFxiICovXG4gICAgICAxOTogMTgsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogSU5JVElBTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICAoWzAtOV0rKFxcLlswLTldKik/fFxcLlswLTldKylkcGlcXGIgKi9cbiAgICAgIDIwOiAxOSxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBJTklUSUFMICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIChbMC05XSsoXFwuWzAtOV0qKT98XFwuWzAtOV0rKWRwY21cXGIgKi9cbiAgICAgIDIxOiAxOSxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBJTklUSUFMICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIChbMC05XSsoXFwuWzAtOV0qKT98XFwuWzAtOV0rKWRwcHhcXGIgKi9cbiAgICAgIDIyOiAxOSxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBJTklUSUFMICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIChbMC05XSsoXFwuWzAtOV0qKT98XFwuWzAtOV0rKWVtXFxiICovXG4gICAgICAyMzogMjAsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogSU5JVElBTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICAoWzAtOV0rKFxcLlswLTldKik/fFxcLlswLTldKylleFxcYiAqL1xuICAgICAgMjQ6IDIxLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IElOSVRJQUwgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgKFswLTldKyhcXC5bMC05XSopP3xcXC5bMC05XSspY2hcXGIgKi9cbiAgICAgIDI1OiAyMixcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBJTklUSUFMICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIChbMC05XSsoXFwuWzAtOV0qKT98XFwuWzAtOV0rKXJlbVxcYiAqL1xuICAgICAgMjY6IDIzLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IElOSVRJQUwgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgKFswLTldKyhcXC5bMC05XSopP3xcXC5bMC05XSspdndcXGIgKi9cbiAgICAgIDI3OiAyNSxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBJTklUSUFMICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIChbMC05XSsoXFwuWzAtOV0qKT98XFwuWzAtOV0rKXZoXFxiICovXG4gICAgICAyODogMjQsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogSU5JVElBTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICAoWzAtOV0rKFxcLlswLTldKik/fFxcLlswLTldKyl2bWluXFxiICovXG4gICAgICAyOTogMjYsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogSU5JVElBTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICAoWzAtOV0rKFxcLlswLTldKik/fFxcLlswLTldKyl2bWF4XFxiICovXG4gICAgICAzMDogMjcsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogSU5JVElBTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICAoWzAtOV0rKFxcLlswLTldKik/fFxcLlswLTldKyklICovXG4gICAgICAzMTogMjgsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogSU5JVElBTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICAoWzAtOV0rKFxcLlswLTldKik/fFxcLlswLTldKylcXGIgKi9cbiAgICAgIDMyOiAxMSxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBJTklUSUFMICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIChjYWxjKSAqL1xuICAgICAgMzM6IDksXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogSU5JVElBTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICAodmFyKSAqL1xuICAgICAgMzQ6IDEyLFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IElOSVRJQUwgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgKFthLXpdKykgKi9cbiAgICAgIDM1OiAxMCxcblxuICAgICAgLyohIENvbmRpdGlvbnM6OiBJTklUSUFMICovXG4gICAgICAvKiEgUnVsZTo6ICAgICAgIFxcKCAqL1xuICAgICAgMzY6IDcsXG5cbiAgICAgIC8qISBDb25kaXRpb25zOjogSU5JVElBTCAqL1xuICAgICAgLyohIFJ1bGU6OiAgICAgICBcXCkgKi9cbiAgICAgIDM3OiA4LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IElOSVRJQUwgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgLCAqL1xuICAgICAgMzg6IDE0LFxuXG4gICAgICAvKiEgQ29uZGl0aW9uczo6IElOSVRJQUwgKi9cbiAgICAgIC8qISBSdWxlOjogICAgICAgJCAqL1xuICAgICAgMzk6IDFcbiAgICB9LFxuXG4gICAgcnVsZXM6IFtcbiAgICAgIC8qICAwOiAqLyAgL14oPzooLS1bXFxkXFwtQS1aYS16XSopKS8sXG4gICAgICAvKiAgMTogKi8gIC9eKD86XFxzKykvLFxuICAgICAgLyogIDI6ICovICAvXig/OlxcKikvLFxuICAgICAgLyogIDM6ICovICAvXig/OlxcLykvLFxuICAgICAgLyogIDQ6ICovICAvXig/OlxcKykvLFxuICAgICAgLyogIDU6ICovICAvXig/Oi0pLyxcbiAgICAgIC8qICA2OiAqLyAgL14oPzooXFxkKyhcXC5cXGQqKT98XFwuXFxkKylweFxcYikvLFxuICAgICAgLyogIDc6ICovICAvXig/OihcXGQrKFxcLlxcZCopP3xcXC5cXGQrKWNtXFxiKS8sXG4gICAgICAvKiAgODogKi8gIC9eKD86KFxcZCsoXFwuXFxkKik/fFxcLlxcZCspbW1cXGIpLyxcbiAgICAgIC8qICA5OiAqLyAgL14oPzooXFxkKyhcXC5cXGQqKT98XFwuXFxkKylpblxcYikvLFxuICAgICAgLyogMTA6ICovICAvXig/OihcXGQrKFxcLlxcZCopP3xcXC5cXGQrKXB0XFxiKS8sXG4gICAgICAvKiAxMTogKi8gIC9eKD86KFxcZCsoXFwuXFxkKik/fFxcLlxcZCspcGNcXGIpLyxcbiAgICAgIC8qIDEyOiAqLyAgL14oPzooXFxkKyhcXC5cXGQqKT98XFwuXFxkKylkZWdcXGIpLyxcbiAgICAgIC8qIDEzOiAqLyAgL14oPzooXFxkKyhcXC5cXGQqKT98XFwuXFxkKylncmFkXFxiKS8sXG4gICAgICAvKiAxNDogKi8gIC9eKD86KFxcZCsoXFwuXFxkKik/fFxcLlxcZCspcmFkXFxiKS8sXG4gICAgICAvKiAxNTogKi8gIC9eKD86KFxcZCsoXFwuXFxkKik/fFxcLlxcZCspdHVyblxcYikvLFxuICAgICAgLyogMTY6ICovICAvXig/OihcXGQrKFxcLlxcZCopP3xcXC5cXGQrKXNcXGIpLyxcbiAgICAgIC8qIDE3OiAqLyAgL14oPzooXFxkKyhcXC5cXGQqKT98XFwuXFxkKyltc1xcYikvLFxuICAgICAgLyogMTg6ICovICAvXig/OihcXGQrKFxcLlxcZCopP3xcXC5cXGQrKUh6XFxiKS8sXG4gICAgICAvKiAxOTogKi8gIC9eKD86KFxcZCsoXFwuXFxkKik/fFxcLlxcZCspa0h6XFxiKS8sXG4gICAgICAvKiAyMDogKi8gIC9eKD86KFxcZCsoXFwuXFxkKik/fFxcLlxcZCspZHBpXFxiKS8sXG4gICAgICAvKiAyMTogKi8gIC9eKD86KFxcZCsoXFwuXFxkKik/fFxcLlxcZCspZHBjbVxcYikvLFxuICAgICAgLyogMjI6ICovICAvXig/OihcXGQrKFxcLlxcZCopP3xcXC5cXGQrKWRwcHhcXGIpLyxcbiAgICAgIC8qIDIzOiAqLyAgL14oPzooXFxkKyhcXC5cXGQqKT98XFwuXFxkKyllbVxcYikvLFxuICAgICAgLyogMjQ6ICovICAvXig/OihcXGQrKFxcLlxcZCopP3xcXC5cXGQrKWV4XFxiKS8sXG4gICAgICAvKiAyNTogKi8gIC9eKD86KFxcZCsoXFwuXFxkKik/fFxcLlxcZCspY2hcXGIpLyxcbiAgICAgIC8qIDI2OiAqLyAgL14oPzooXFxkKyhcXC5cXGQqKT98XFwuXFxkKylyZW1cXGIpLyxcbiAgICAgIC8qIDI3OiAqLyAgL14oPzooXFxkKyhcXC5cXGQqKT98XFwuXFxkKyl2d1xcYikvLFxuICAgICAgLyogMjg6ICovICAvXig/OihcXGQrKFxcLlxcZCopP3xcXC5cXGQrKXZoXFxiKS8sXG4gICAgICAvKiAyOTogKi8gIC9eKD86KFxcZCsoXFwuXFxkKik/fFxcLlxcZCspdm1pblxcYikvLFxuICAgICAgLyogMzA6ICovICAvXig/OihcXGQrKFxcLlxcZCopP3xcXC5cXGQrKXZtYXhcXGIpLyxcbiAgICAgIC8qIDMxOiAqLyAgL14oPzooXFxkKyhcXC5cXGQqKT98XFwuXFxkKyklKS8sXG4gICAgICAvKiAzMjogKi8gIC9eKD86KFxcZCsoXFwuXFxkKik/fFxcLlxcZCspXFxiKS8sXG4gICAgICAvKiAzMzogKi8gIC9eKD86KGNhbGMpKS8sXG4gICAgICAvKiAzNDogKi8gIC9eKD86KHZhcikpLyxcbiAgICAgIC8qIDM1OiAqLyAgL14oPzooW2Etel0rKSkvLFxuICAgICAgLyogMzY6ICovICAvXig/OlxcKCkvLFxuICAgICAgLyogMzc6ICovICAvXig/OlxcKSkvLFxuICAgICAgLyogMzg6ICovICAvXig/OiwpLyxcbiAgICAgIC8qIDM5OiAqLyAgL14oPzokKS9cbiAgICBdLFxuXG4gICAgY29uZGl0aW9uczoge1xuICAgICAgJ0lOSVRJQUwnOiB7XG4gICAgICAgIHJ1bGVzOiBbXG4gICAgICAgICAgMCxcbiAgICAgICAgICAxLFxuICAgICAgICAgIDIsXG4gICAgICAgICAgMyxcbiAgICAgICAgICA0LFxuICAgICAgICAgIDUsXG4gICAgICAgICAgNixcbiAgICAgICAgICA3LFxuICAgICAgICAgIDgsXG4gICAgICAgICAgOSxcbiAgICAgICAgICAxMCxcbiAgICAgICAgICAxMSxcbiAgICAgICAgICAxMixcbiAgICAgICAgICAxMyxcbiAgICAgICAgICAxNCxcbiAgICAgICAgICAxNSxcbiAgICAgICAgICAxNixcbiAgICAgICAgICAxNyxcbiAgICAgICAgICAxOCxcbiAgICAgICAgICAxOSxcbiAgICAgICAgICAyMCxcbiAgICAgICAgICAyMSxcbiAgICAgICAgICAyMixcbiAgICAgICAgICAyMyxcbiAgICAgICAgICAyNCxcbiAgICAgICAgICAyNSxcbiAgICAgICAgICAyNixcbiAgICAgICAgICAyNyxcbiAgICAgICAgICAyOCxcbiAgICAgICAgICAyOSxcbiAgICAgICAgICAzMCxcbiAgICAgICAgICAzMSxcbiAgICAgICAgICAzMixcbiAgICAgICAgICAzMyxcbiAgICAgICAgICAzNCxcbiAgICAgICAgICAzNSxcbiAgICAgICAgICAzNixcbiAgICAgICAgICAzNyxcbiAgICAgICAgICAzOCxcbiAgICAgICAgICAzOVxuICAgICAgICBdLFxuXG4gICAgICAgIGluY2x1c2l2ZTogdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gbGV4ZXI7XG59KCk7XG5wYXJzZXIubGV4ZXIgPSBsZXhlcjtcblxuXG5cbmZ1bmN0aW9uIFBhcnNlcigpIHtcbiAgdGhpcy55eSA9IHt9O1xufVxuUGFyc2VyLnByb3RvdHlwZSA9IHBhcnNlcjtcbnBhcnNlci5QYXJzZXIgPSBQYXJzZXI7XG5cbnJldHVybiBuZXcgUGFyc2VyKCk7XG59KSgpO1xuXG4gICAgICAgIFxuXG5cbmlmICh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gIGV4cG9ydHMucGFyc2VyID0gcGFyc2VyO1xuICBleHBvcnRzLlBhcnNlciA9IHBhcnNlci5QYXJzZXI7XG4gIGV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHBhcnNlci5wYXJzZS5hcHBseShwYXJzZXIsIGFyZ3VtZW50cyk7XG4gIH07XG4gIFxufVxuIl0sIm5hbWVzIjpbInBhcnNlciIsIkppc29uUGFyc2VyRXJyb3IiLCJtc2ciLCJoYXNoIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiLCJ2YWx1ZSIsInN0YWNrdHJhY2UiLCJleGNlcHRpb24iLCJFcnJvciIsImV4MiIsIm1lc3NhZ2UiLCJzdGFjayIsImhhc093blByb3BlcnR5IiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJjb25zdHJ1Y3RvciIsInNldFByb3RvdHlwZU9mIiwicHJvdG90eXBlIiwiY3JlYXRlIiwibmFtZSIsImJwIiwicyIsInJ2IiwicCIsInBvcCIsInIiLCJydWxlIiwiaSIsImwiLCJsZW5ndGgiLCJwdXNoIiwiYmRhIiwiZCIsImlkeCIsImciLCJnb3RvIiwiaiIsImJ0IiwibGVuIiwieSIsInN5bWJvbCIsInQiLCJ0eXBlIiwiYSIsInN0YXRlIiwibSIsIm1vZGUiLCJuIiwicSIsInoiLCJzaGlmdCIsImMiLCJ1IiwiZSIsImFwcGx5IiwidHJhY2UiLCJub19vcF90cmFjZSIsInl5Iiwib3B0aW9ucyIsImhhc1BhcnRpYWxMclVwZ3JhZGVPbkNvbmZsaWN0IiwiZXJyb3JSZWNvdmVyeVRva2VuRGlzY2FyZENvdW50Iiwic3ltYm9sc18iLCJ0ZXJtaW5hbHNfIiwiVEVSUk9SIiwiRU9GIiwib3JpZ2luYWxRdW90ZU5hbWUiLCJvcmlnaW5hbFBhcnNlRXJyb3IiLCJjbGVhbnVwQWZ0ZXJQYXJzZSIsImNvbnN0cnVjdFBhcnNlRXJyb3JJbmZvIiwieXlNZXJnZUxvY2F0aW9uSW5mbyIsIl9fcmVlbnRyYW50X2NhbGxfZGVwdGgiLCJfX2Vycm9yX2luZm9zIiwiX19lcnJvcl9yZWNvdmVyeV9pbmZvcyIsInF1b3RlTmFtZSIsInBhcnNlcl9xdW90ZU5hbWUiLCJpZF9zdHIiLCJnZXRTeW1ib2xOYW1lIiwicGFyc2VyX2dldFN5bWJvbE5hbWUiLCJrZXkiLCJkZXNjcmliZVN5bWJvbCIsInBhcnNlcl9kZXNjcmliZVN5bWJvbCIsInRlcm1pbmFsX2Rlc2NyaXB0aW9uc18iLCJpZCIsImNvbGxlY3RfZXhwZWN0ZWRfdG9rZW5fc2V0IiwicGFyc2VyX2NvbGxlY3RfZXhwZWN0ZWRfdG9rZW5fc2V0IiwiZG9fbm90X2Rlc2NyaWJlIiwidG9rZW5zZXQiLCJjaGVjayIsInN0YXRlX2Rlc2NyaXB0aW9uc18iLCJ0YWJsZSIsInByb2R1Y3Rpb25zXyIsInBlcmZvcm1BY3Rpb24iLCJwYXJzZXJfX1BlcmZvcm1BY3Rpb24iLCJ5eXN0YXRlIiwieXlzcCIsInl5dnN0YWNrIiwieXlwYXJzZXIiLCJ5eWxleGVyIiwibGV4ZXIiLCIkIiwib3BlcmF0b3IiLCJsZWZ0IiwicmlnaHQiLCJwcmVmaXgiLCJwYXJzZUZsb2F0IiwiZmFsbGJhY2siLCJ1bml0IiwiZXhlYyIsInByZXYiLCJkZWZhdWx0QWN0aW9ucyIsInBhcnNlRXJyb3IiLCJzdHIiLCJFeGNlcHRpb25DbGFzcyIsInJlY292ZXJhYmxlIiwiZGVzdHJveSIsInBhcnNlIiwiaW5wdXQiLCJzZWxmIiwiQXJyYXkiLCJzc3RhY2siLCJ2c3RhY2siLCJzcCIsIkVSUk9SX1JFQ09WRVJZX1RPS0VOX0RJU0NBUkRfQ09VTlQiLCJOT19BQ1RJT04iLCJfX2xleGVyX18iLCJzaGFyZWRTdGF0ZV95eSIsInVuZGVmaW5lZCIsInByZV9wYXJzZSIsInBvc3RfcGFyc2UiLCJwcmVfbGV4IiwicG9zdF9sZXgiLCJBU1NFUlQiLCJhc3NlcnQiLCJKaXNvbkFzc2VydCIsImNvbmQiLCJ5eUdldFNoYXJlZFN0YXRlIiwic2hhbGxvd19jb3B5X25vY2xvYmJlciIsImRzdCIsInNyYyIsImsiLCJjYWxsIiwicGFyc2VFcnJvckFsdCIsInF1b3RlTmFtZUFsdCIsInBhcnNlcl9jbGVhbnVwQWZ0ZXJQYXJzZSIsInJlc3VsdFZhbHVlIiwiaW52b2tlX3Bvc3RfbWV0aG9kcyIsImRvX25vdF9udWtlX2Vycm9yaW5mb3MiLCJjbGVhbnVwQWZ0ZXJMZXgiLCJlbCIsInBhcnNlcl9jb25zdHJ1Y3RQYXJzZUVycm9ySW5mbyIsImV4IiwiZXhwZWN0ZWQiLCJwZWkiLCJlcnJTdHIiLCJ0ZXh0IiwibWF0Y2giLCJ5eXRleHQiLCJ0b2tlbiIsInRva2VuX2lkIiwibGluZSIsInl5bGluZW5vIiwiYWN0aW9uIiwibmV3X3N0YXRlIiwibmV3U3RhdGUiLCJzeW1ib2xfc3RhY2siLCJzdGF0ZV9zdGFjayIsInZhbHVlX3N0YWNrIiwic3RhY2tfcG9pbnRlciIsImRlc3RydWN0UGFyc2VFcnJvckluZm8iLCJyZWMiLCJnZXROb25UZXJtaW5hbEZyb21Db2RlIiwidG9rZW5OYW1lIiwic3RkTGV4IiwibGV4IiwiZmFzdExleCIsInl5dmFsIiwiXyQiLCJ5eXJ1bGVsZW4iLCJ0aGlzX3Byb2R1Y3Rpb24iLCJyZXR2YWwiLCJzZXRJbnB1dCIsImNhbklVc2UiLCJsZXhlckluZm8iLCJlcnJTeW1ib2xEZXNjciIsInNob3dQb3NpdGlvbiIsImpvaW4iLCJudHN5bWJvbCIsIkppc29uTGV4ZXJFcnJvciIsIkVSUk9SIiwiX19jdXJyZW50UnVsZVNldF9fIiwiX19kZWNvbXByZXNzZWQiLCJkb25lIiwiX2JhY2t0cmFjayIsIl9pbnB1dCIsIl9tb3JlIiwiX3NpZ25hbGVkX2Vycm9yX3Rva2VuIiwiY29uZGl0aW9uU3RhY2siLCJtYXRjaGVkIiwibWF0Y2hlcyIsIm9mZnNldCIsInl5bGVuZyIsInl5bGxvYyIsImNvbnN0cnVjdExleEVycm9ySW5mbyIsImxleGVyX2NvbnN0cnVjdExleEVycm9ySW5mbyIsInNob3dfaW5wdXRfcG9zaXRpb24iLCJpbmRleE9mIiwicHJldHR5UHJpbnRSYW5nZSIsInByZXR0eV9zcmMiLCJ0ZXN0IiwicG9zX3N0ciIsImxvYyIsImRlc3RydWN0TGV4RXJyb3JJbmZvIiwibGV4ZXJfcGFyc2VFcnJvciIsInl5ZXJyb3IiLCJ5eUVycm9yIiwibGluZW5vX21zZyIsImxleGVyRXJyb3JzQXJlUmVjb3ZlcmFibGUiLCJhcmdzIiwic2xpY2UiLCJhcmd1bWVudHMiLCJleHRyYV9lcnJvcl9hdHRyaWJ1dGVzIiwibGV4ZXJfY2xlYW51cEFmdGVyTGV4IiwiY2xlYXIiLCJsZXhlcl9jbGVhciIsImNvbCIsImxhc3RfY29sdW1uIiwiZmlyc3RfbGluZSIsImZpcnN0X2NvbHVtbiIsImxhc3RfbGluZSIsInJhbmdlIiwibGV4ZXJfc2V0SW5wdXQiLCJydWxlcyIsInJ1bGVfcmUiLCJjb25kaXRpb25zIiwic3BlYyIsInJ1bGVfaWRzIiwicnVsZV9yZWdleGVzIiwicnVsZV9uZXdfaWRzIiwiX19ydWxlX3JlZ2V4ZXMiLCJfX3J1bGVfY291bnQiLCJlZGl0UmVtYWluaW5nSW5wdXQiLCJsZXhlcl9lZGl0UmVtYWluaW5nSW5wdXQiLCJjYWxsYmFjayIsImNwc0FyZyIsImxleGVyX2lucHV0IiwiY2giLCJzbGljZV9sZW4iLCJsaW5lcyIsImNoMiIsInVucHV0IiwibGV4ZXJfdW5wdXQiLCJzcGxpdCIsInN1YnN0ciIsInByZSIsInByZV9saW5lcyIsIm1vcmUiLCJsZXhlcl9tb3JlIiwicmVqZWN0IiwibGV4ZXJfcmVqZWN0IiwiYmFja3RyYWNrX2xleGVyIiwibGVzcyIsImxleGVyX2xlc3MiLCJwYXN0SW5wdXQiLCJsZXhlcl9wYXN0SW5wdXQiLCJtYXhTaXplIiwibWF4TGluZXMiLCJwYXN0Iiwic3Vic3RyaW5nIiwicmVwbGFjZSIsInVwY29taW5nSW5wdXQiLCJsZXhlcl91cGNvbWluZ0lucHV0IiwibmV4dCIsImxleGVyX3Nob3dQb3NpdGlvbiIsIm1heFByZWZpeCIsIm1heFBvc3RmaXgiLCJkZXJpdmVMb2NhdGlvbkluZm8iLCJsZXhlcl9kZXJpdmVZWUxMT0MiLCJhY3R1YWwiLCJwcmVjZWRpbmciLCJmb2xsb3dpbmciLCJjdXJyZW50IiwibGV4ZXJfcHJldHR5UHJpbnRSYW5nZSIsImNvbnRleHRfbG9jIiwiY29udGV4dF9sb2MyIiwiQ09OVEVYVCIsIkNPTlRFWFRfVEFJTCIsIk1JTklNVU1fVklTSUJMRV9OT05FTVBUWV9MSU5FX0NPVU5UIiwibDAiLCJNYXRoIiwibWF4IiwibDEiLCJsaW5lbm9fZGlzcGxheV93aWR0aCIsImxvZzEwIiwid3NfcHJlZml4Iiwibm9uZW1wdHlfbGluZV9pbmRleGVzIiwibWFwIiwiaW5qZWN0TGluZU51bWJlciIsImluZGV4IiwibG5vIiwibG5vX3BmeCIsImVycnBmeCIsImxlYWQiLCJtYXJrIiwidHJpbSIsImNsaXBfc3RhcnQiLCJjbGlwX2VuZCIsImludGVybWVkaWF0ZV9saW5lIiwic3BsaWNlIiwiZGVzY3JpYmVZWUxMT0MiLCJsZXhlcl9kZXNjcmliZV95eWxsb2MiLCJkaXNwbGF5X3JhbmdlX3RvbyIsImwyIiwiYzEiLCJjMiIsImRsIiwiZGMiLCJyMSIsInIyIiwidGVzdF9tYXRjaCIsImxleGVyX3Rlc3RfbWF0Y2giLCJpbmRleGVkX3J1bGUiLCJiYWNrdXAiLCJtYXRjaF9zdHIiLCJtYXRjaF9zdHJfbGVuIiwibGV4ZXJfbmV4dCIsInRlbXBNYXRjaCIsIl9jdXJyZW50UnVsZXMiLCJ0cmFja1Bvc2l0aW9uIiwidG9wU3RhdGUiLCJyZWdleGVzIiwiZmxleCIsInBlbmRpbmdJbnB1dCIsImFjdGl2ZUNvbmRpdGlvbiIsImNvbmRpdGlvblN0YWNrRGVwdGgiLCJsZXhlcl9sZXgiLCJsZXhlcl9mYXN0TGV4IiwibGV4ZXJfY2FuSVVzZSIsImJlZ2luIiwibGV4ZXJfYmVnaW4iLCJjb25kaXRpb24iLCJwdXNoU3RhdGUiLCJsZXhlcl9wdXNoU3RhdGUiLCJwb3BTdGF0ZSIsImxleGVyX3BvcFN0YXRlIiwibGV4ZXJfdG9wU3RhdGUiLCJhYnMiLCJsZXhlcl9fY3VycmVudFJ1bGVzIiwic3RhdGVTdGFja1NpemUiLCJsZXhlcl9zdGF0ZVN0YWNrU2l6ZSIsImxleGVyX19wZXJmb3JtQWN0aW9uIiwieXlydWxlbnVtYmVyIiwiWVlfU1RBUlQiLCJ5eV8iLCJZWVNUQVRFIiwic2ltcGxlQ2FzZUFjdGlvbkNsdXN0ZXJzIiwiaW5jbHVzaXZlIiwiUGFyc2VyIiwicmVxdWlyZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/reduce-css-calc/dist/parser.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/reduce-css-calc/node_modules/postcss-value-parser/lib/index.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/reduce-css-calc/node_modules/postcss-value-parser/lib/index.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var parse = __webpack_require__(/*! ./parse */ \"(ssr)/./node_modules/reduce-css-calc/node_modules/postcss-value-parser/lib/parse.js\");\nvar walk = __webpack_require__(/*! ./walk */ \"(ssr)/./node_modules/reduce-css-calc/node_modules/postcss-value-parser/lib/walk.js\");\nvar stringify = __webpack_require__(/*! ./stringify */ \"(ssr)/./node_modules/reduce-css-calc/node_modules/postcss-value-parser/lib/stringify.js\");\nfunction ValueParser(value) {\n    if (this instanceof ValueParser) {\n        this.nodes = parse(value);\n        return this;\n    }\n    return new ValueParser(value);\n}\nValueParser.prototype.toString = function() {\n    return Array.isArray(this.nodes) ? stringify(this.nodes) : \"\";\n};\nValueParser.prototype.walk = function(cb, bubble) {\n    walk(this.nodes, cb, bubble);\n    return this;\n};\nValueParser.unit = __webpack_require__(/*! ./unit */ \"(ssr)/./node_modules/reduce-css-calc/node_modules/postcss-value-parser/lib/unit.js\");\nValueParser.walk = walk;\nValueParser.stringify = stringify;\nmodule.exports = ValueParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVkdWNlLWNzcy1jYWxjL25vZGVfbW9kdWxlcy9wb3N0Y3NzLXZhbHVlLXBhcnNlci9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUMsb0dBQVM7QUFDN0IsSUFBSUMsT0FBT0QsbUJBQU9BLENBQUMsa0dBQVE7QUFDM0IsSUFBSUUsWUFBWUYsbUJBQU9BLENBQUMsNEdBQWE7QUFFckMsU0FBU0csWUFBWUMsS0FBSztJQUN4QixJQUFJLElBQUksWUFBWUQsYUFBYTtRQUMvQixJQUFJLENBQUNFLEtBQUssR0FBR04sTUFBTUs7UUFDbkIsT0FBTyxJQUFJO0lBQ2I7SUFDQSxPQUFPLElBQUlELFlBQVlDO0FBQ3pCO0FBRUFELFlBQVlHLFNBQVMsQ0FBQ0MsUUFBUSxHQUFHO0lBQy9CLE9BQU9DLE1BQU1DLE9BQU8sQ0FBQyxJQUFJLENBQUNKLEtBQUssSUFBSUgsVUFBVSxJQUFJLENBQUNHLEtBQUssSUFBSTtBQUM3RDtBQUVBRixZQUFZRyxTQUFTLENBQUNMLElBQUksR0FBRyxTQUFTUyxFQUFFLEVBQUVDLE1BQU07SUFDOUNWLEtBQUssSUFBSSxDQUFDSSxLQUFLLEVBQUVLLElBQUlDO0lBQ3JCLE9BQU8sSUFBSTtBQUNiO0FBRUFSLFlBQVlTLElBQUksR0FBR1osbUJBQU9BLENBQUMsa0dBQVE7QUFFbkNHLFlBQVlGLElBQUksR0FBR0E7QUFFbkJFLFlBQVlELFNBQVMsR0FBR0E7QUFFeEJXLE9BQU9DLE9BQU8sR0FBR1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbmNvbWUtZXhwZW5zZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9yZWR1Y2UtY3NzLWNhbGMvbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtdmFsdWUtcGFyc2VyL2xpYi9pbmRleC5qcz9iNTMxIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBwYXJzZSA9IHJlcXVpcmUoXCIuL3BhcnNlXCIpO1xudmFyIHdhbGsgPSByZXF1aXJlKFwiLi93YWxrXCIpO1xudmFyIHN0cmluZ2lmeSA9IHJlcXVpcmUoXCIuL3N0cmluZ2lmeVwiKTtcblxuZnVuY3Rpb24gVmFsdWVQYXJzZXIodmFsdWUpIHtcbiAgaWYgKHRoaXMgaW5zdGFuY2VvZiBWYWx1ZVBhcnNlcikge1xuICAgIHRoaXMubm9kZXMgPSBwYXJzZSh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmV0dXJuIG5ldyBWYWx1ZVBhcnNlcih2YWx1ZSk7XG59XG5cblZhbHVlUGFyc2VyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh0aGlzLm5vZGVzKSA/IHN0cmluZ2lmeSh0aGlzLm5vZGVzKSA6IFwiXCI7XG59O1xuXG5WYWx1ZVBhcnNlci5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uKGNiLCBidWJibGUpIHtcbiAgd2Fsayh0aGlzLm5vZGVzLCBjYiwgYnViYmxlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5WYWx1ZVBhcnNlci51bml0ID0gcmVxdWlyZShcIi4vdW5pdFwiKTtcblxuVmFsdWVQYXJzZXIud2FsayA9IHdhbGs7XG5cblZhbHVlUGFyc2VyLnN0cmluZ2lmeSA9IHN0cmluZ2lmeTtcblxubW9kdWxlLmV4cG9ydHMgPSBWYWx1ZVBhcnNlcjtcbiJdLCJuYW1lcyI6WyJwYXJzZSIsInJlcXVpcmUiLCJ3YWxrIiwic3RyaW5naWZ5IiwiVmFsdWVQYXJzZXIiLCJ2YWx1ZSIsIm5vZGVzIiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJBcnJheSIsImlzQXJyYXkiLCJjYiIsImJ1YmJsZSIsInVuaXQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/reduce-css-calc/node_modules/postcss-value-parser/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/reduce-css-calc/node_modules/postcss-value-parser/lib/parse.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/reduce-css-calc/node_modules/postcss-value-parser/lib/parse.js ***!
  \*************************************************************************************/
/***/ ((module) => {

eval("var openParentheses = \"(\".charCodeAt(0);\nvar closeParentheses = \")\".charCodeAt(0);\nvar singleQuote = \"'\".charCodeAt(0);\nvar doubleQuote = '\"'.charCodeAt(0);\nvar backslash = \"\\\\\".charCodeAt(0);\nvar slash = \"/\".charCodeAt(0);\nvar comma = \",\".charCodeAt(0);\nvar colon = \":\".charCodeAt(0);\nvar star = \"*\".charCodeAt(0);\nmodule.exports = function(input) {\n    var tokens = [];\n    var value = input;\n    var next, quote, prev, token, escape, escapePos, whitespacePos;\n    var pos = 0;\n    var code = value.charCodeAt(pos);\n    var max = value.length;\n    var stack = [\n        {\n            nodes: tokens\n        }\n    ];\n    var balanced = 0;\n    var parent;\n    var name = \"\";\n    var before = \"\";\n    var after = \"\";\n    while(pos < max){\n        // Whitespaces\n        if (code <= 32) {\n            next = pos;\n            do {\n                next += 1;\n                code = value.charCodeAt(next);\n            }while (code <= 32);\n            token = value.slice(pos, next);\n            prev = tokens[tokens.length - 1];\n            if (code === closeParentheses && balanced) {\n                after = token;\n            } else if (prev && prev.type === \"div\") {\n                prev.after = token;\n            } else if (code === comma || code === colon || code === slash && value.charCodeAt(next + 1) !== star) {\n                before = token;\n            } else {\n                tokens.push({\n                    type: \"space\",\n                    sourceIndex: pos,\n                    value: token\n                });\n            }\n            pos = next;\n        // Quotes\n        } else if (code === singleQuote || code === doubleQuote) {\n            next = pos;\n            quote = code === singleQuote ? \"'\" : '\"';\n            token = {\n                type: \"string\",\n                sourceIndex: pos,\n                quote: quote\n            };\n            do {\n                escape = false;\n                next = value.indexOf(quote, next + 1);\n                if (~next) {\n                    escapePos = next;\n                    while(value.charCodeAt(escapePos - 1) === backslash){\n                        escapePos -= 1;\n                        escape = !escape;\n                    }\n                } else {\n                    value += quote;\n                    next = value.length - 1;\n                    token.unclosed = true;\n                }\n            }while (escape);\n            token.value = value.slice(pos + 1, next);\n            tokens.push(token);\n            pos = next + 1;\n            code = value.charCodeAt(pos);\n        // Comments\n        } else if (code === slash && value.charCodeAt(pos + 1) === star) {\n            token = {\n                type: \"comment\",\n                sourceIndex: pos\n            };\n            next = value.indexOf(\"*/\", pos);\n            if (next === -1) {\n                token.unclosed = true;\n                next = value.length;\n            }\n            token.value = value.slice(pos + 2, next);\n            tokens.push(token);\n            pos = next + 2;\n            code = value.charCodeAt(pos);\n        // Dividers\n        } else if (code === slash || code === comma || code === colon) {\n            token = value[pos];\n            tokens.push({\n                type: \"div\",\n                sourceIndex: pos - before.length,\n                value: token,\n                before: before,\n                after: \"\"\n            });\n            before = \"\";\n            pos += 1;\n            code = value.charCodeAt(pos);\n        // Open parentheses\n        } else if (openParentheses === code) {\n            // Whitespaces after open parentheses\n            next = pos;\n            do {\n                next += 1;\n                code = value.charCodeAt(next);\n            }while (code <= 32);\n            token = {\n                type: \"function\",\n                sourceIndex: pos - name.length,\n                value: name,\n                before: value.slice(pos + 1, next)\n            };\n            pos = next;\n            if (name === \"url\" && code !== singleQuote && code !== doubleQuote) {\n                next -= 1;\n                do {\n                    escape = false;\n                    next = value.indexOf(\")\", next + 1);\n                    if (~next) {\n                        escapePos = next;\n                        while(value.charCodeAt(escapePos - 1) === backslash){\n                            escapePos -= 1;\n                            escape = !escape;\n                        }\n                    } else {\n                        value += \")\";\n                        next = value.length - 1;\n                        token.unclosed = true;\n                    }\n                }while (escape);\n                // Whitespaces before closed\n                whitespacePos = next;\n                do {\n                    whitespacePos -= 1;\n                    code = value.charCodeAt(whitespacePos);\n                }while (code <= 32);\n                if (pos !== whitespacePos + 1) {\n                    token.nodes = [\n                        {\n                            type: \"word\",\n                            sourceIndex: pos,\n                            value: value.slice(pos, whitespacePos + 1)\n                        }\n                    ];\n                } else {\n                    token.nodes = [];\n                }\n                if (token.unclosed && whitespacePos + 1 !== next) {\n                    token.after = \"\";\n                    token.nodes.push({\n                        type: \"space\",\n                        sourceIndex: whitespacePos + 1,\n                        value: value.slice(whitespacePos + 1, next)\n                    });\n                } else {\n                    token.after = value.slice(whitespacePos + 1, next);\n                }\n                pos = next + 1;\n                code = value.charCodeAt(pos);\n                tokens.push(token);\n            } else {\n                balanced += 1;\n                token.after = \"\";\n                tokens.push(token);\n                stack.push(token);\n                tokens = token.nodes = [];\n                parent = token;\n            }\n            name = \"\";\n        // Close parentheses\n        } else if (closeParentheses === code && balanced) {\n            pos += 1;\n            code = value.charCodeAt(pos);\n            parent.after = after;\n            after = \"\";\n            balanced -= 1;\n            stack.pop();\n            parent = stack[balanced];\n            tokens = parent.nodes;\n        // Words\n        } else {\n            next = pos;\n            do {\n                if (code === backslash) {\n                    next += 1;\n                }\n                next += 1;\n                code = value.charCodeAt(next);\n            }while (next < max && !(code <= 32 || code === singleQuote || code === doubleQuote || code === comma || code === colon || code === slash || code === openParentheses || code === closeParentheses && balanced));\n            token = value.slice(pos, next);\n            if (openParentheses === code) {\n                name = token;\n            } else {\n                tokens.push({\n                    type: \"word\",\n                    sourceIndex: pos,\n                    value: token\n                });\n            }\n            pos = next;\n        }\n    }\n    for(pos = stack.length - 1; pos; pos -= 1){\n        stack[pos].unclosed = true;\n    }\n    return stack[0].nodes;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbmNvbWUtZXhwZW5zZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9yZWR1Y2UtY3NzLWNhbGMvbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtdmFsdWUtcGFyc2VyL2xpYi9wYXJzZS5qcz8yNDQ1Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBvcGVuUGFyZW50aGVzZXMgPSBcIihcIi5jaGFyQ29kZUF0KDApO1xudmFyIGNsb3NlUGFyZW50aGVzZXMgPSBcIilcIi5jaGFyQ29kZUF0KDApO1xudmFyIHNpbmdsZVF1b3RlID0gXCInXCIuY2hhckNvZGVBdCgwKTtcbnZhciBkb3VibGVRdW90ZSA9ICdcIicuY2hhckNvZGVBdCgwKTtcbnZhciBiYWNrc2xhc2ggPSBcIlxcXFxcIi5jaGFyQ29kZUF0KDApO1xudmFyIHNsYXNoID0gXCIvXCIuY2hhckNvZGVBdCgwKTtcbnZhciBjb21tYSA9IFwiLFwiLmNoYXJDb2RlQXQoMCk7XG52YXIgY29sb24gPSBcIjpcIi5jaGFyQ29kZUF0KDApO1xudmFyIHN0YXIgPSBcIipcIi5jaGFyQ29kZUF0KDApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIHZhciB0b2tlbnMgPSBbXTtcbiAgdmFyIHZhbHVlID0gaW5wdXQ7XG5cbiAgdmFyIG5leHQsIHF1b3RlLCBwcmV2LCB0b2tlbiwgZXNjYXBlLCBlc2NhcGVQb3MsIHdoaXRlc3BhY2VQb3M7XG4gIHZhciBwb3MgPSAwO1xuICB2YXIgY29kZSA9IHZhbHVlLmNoYXJDb2RlQXQocG9zKTtcbiAgdmFyIG1heCA9IHZhbHVlLmxlbmd0aDtcbiAgdmFyIHN0YWNrID0gW3sgbm9kZXM6IHRva2VucyB9XTtcbiAgdmFyIGJhbGFuY2VkID0gMDtcbiAgdmFyIHBhcmVudDtcblxuICB2YXIgbmFtZSA9IFwiXCI7XG4gIHZhciBiZWZvcmUgPSBcIlwiO1xuICB2YXIgYWZ0ZXIgPSBcIlwiO1xuXG4gIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICAvLyBXaGl0ZXNwYWNlc1xuICAgIGlmIChjb2RlIDw9IDMyKSB7XG4gICAgICBuZXh0ID0gcG9zO1xuICAgICAgZG8ge1xuICAgICAgICBuZXh0ICs9IDE7XG4gICAgICAgIGNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KG5leHQpO1xuICAgICAgfSB3aGlsZSAoY29kZSA8PSAzMik7XG4gICAgICB0b2tlbiA9IHZhbHVlLnNsaWNlKHBvcywgbmV4dCk7XG5cbiAgICAgIHByZXYgPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGNvZGUgPT09IGNsb3NlUGFyZW50aGVzZXMgJiYgYmFsYW5jZWQpIHtcbiAgICAgICAgYWZ0ZXIgPSB0b2tlbjtcbiAgICAgIH0gZWxzZSBpZiAocHJldiAmJiBwcmV2LnR5cGUgPT09IFwiZGl2XCIpIHtcbiAgICAgICAgcHJldi5hZnRlciA9IHRva2VuO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgY29kZSA9PT0gY29tbWEgfHxcbiAgICAgICAgY29kZSA9PT0gY29sb24gfHxcbiAgICAgICAgKGNvZGUgPT09IHNsYXNoICYmIHZhbHVlLmNoYXJDb2RlQXQobmV4dCArIDEpICE9PSBzdGFyKVxuICAgICAgKSB7XG4gICAgICAgIGJlZm9yZSA9IHRva2VuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwic3BhY2VcIixcbiAgICAgICAgICBzb3VyY2VJbmRleDogcG9zLFxuICAgICAgICAgIHZhbHVlOiB0b2tlblxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcG9zID0gbmV4dDtcblxuICAgICAgLy8gUXVvdGVzXG4gICAgfSBlbHNlIGlmIChjb2RlID09PSBzaW5nbGVRdW90ZSB8fCBjb2RlID09PSBkb3VibGVRdW90ZSkge1xuICAgICAgbmV4dCA9IHBvcztcbiAgICAgIHF1b3RlID0gY29kZSA9PT0gc2luZ2xlUXVvdGUgPyBcIidcIiA6ICdcIic7XG4gICAgICB0b2tlbiA9IHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgc291cmNlSW5kZXg6IHBvcyxcbiAgICAgICAgcXVvdGU6IHF1b3RlXG4gICAgICB9O1xuICAgICAgZG8ge1xuICAgICAgICBlc2NhcGUgPSBmYWxzZTtcbiAgICAgICAgbmV4dCA9IHZhbHVlLmluZGV4T2YocXVvdGUsIG5leHQgKyAxKTtcbiAgICAgICAgaWYgKH5uZXh0KSB7XG4gICAgICAgICAgZXNjYXBlUG9zID0gbmV4dDtcbiAgICAgICAgICB3aGlsZSAodmFsdWUuY2hhckNvZGVBdChlc2NhcGVQb3MgLSAxKSA9PT0gYmFja3NsYXNoKSB7XG4gICAgICAgICAgICBlc2NhcGVQb3MgLT0gMTtcbiAgICAgICAgICAgIGVzY2FwZSA9ICFlc2NhcGU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlICs9IHF1b3RlO1xuICAgICAgICAgIG5leHQgPSB2YWx1ZS5sZW5ndGggLSAxO1xuICAgICAgICAgIHRva2VuLnVuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAoZXNjYXBlKTtcbiAgICAgIHRva2VuLnZhbHVlID0gdmFsdWUuc2xpY2UocG9zICsgMSwgbmV4dCk7XG5cbiAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgIHBvcyA9IG5leHQgKyAxO1xuICAgICAgY29kZSA9IHZhbHVlLmNoYXJDb2RlQXQocG9zKTtcblxuICAgICAgLy8gQ29tbWVudHNcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IHNsYXNoICYmIHZhbHVlLmNoYXJDb2RlQXQocG9zICsgMSkgPT09IHN0YXIpIHtcbiAgICAgIHRva2VuID0ge1xuICAgICAgICB0eXBlOiBcImNvbW1lbnRcIixcbiAgICAgICAgc291cmNlSW5kZXg6IHBvc1xuICAgICAgfTtcblxuICAgICAgbmV4dCA9IHZhbHVlLmluZGV4T2YoXCIqL1wiLCBwb3MpO1xuICAgICAgaWYgKG5leHQgPT09IC0xKSB7XG4gICAgICAgIHRva2VuLnVuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgbmV4dCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgdG9rZW4udmFsdWUgPSB2YWx1ZS5zbGljZShwb3MgKyAyLCBuZXh0KTtcbiAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcblxuICAgICAgcG9zID0gbmV4dCArIDI7XG4gICAgICBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgICAvLyBEaXZpZGVyc1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gc2xhc2ggfHwgY29kZSA9PT0gY29tbWEgfHwgY29kZSA9PT0gY29sb24pIHtcbiAgICAgIHRva2VuID0gdmFsdWVbcG9zXTtcblxuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiBcImRpdlwiLFxuICAgICAgICBzb3VyY2VJbmRleDogcG9zIC0gYmVmb3JlLmxlbmd0aCxcbiAgICAgICAgdmFsdWU6IHRva2VuLFxuICAgICAgICBiZWZvcmU6IGJlZm9yZSxcbiAgICAgICAgYWZ0ZXI6IFwiXCJcbiAgICAgIH0pO1xuICAgICAgYmVmb3JlID0gXCJcIjtcblxuICAgICAgcG9zICs9IDE7XG4gICAgICBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgICAvLyBPcGVuIHBhcmVudGhlc2VzXG4gICAgfSBlbHNlIGlmIChvcGVuUGFyZW50aGVzZXMgPT09IGNvZGUpIHtcbiAgICAgIC8vIFdoaXRlc3BhY2VzIGFmdGVyIG9wZW4gcGFyZW50aGVzZXNcbiAgICAgIG5leHQgPSBwb3M7XG4gICAgICBkbyB7XG4gICAgICAgIG5leHQgKz0gMTtcbiAgICAgICAgY29kZSA9IHZhbHVlLmNoYXJDb2RlQXQobmV4dCk7XG4gICAgICB9IHdoaWxlIChjb2RlIDw9IDMyKTtcbiAgICAgIHRva2VuID0ge1xuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgIHNvdXJjZUluZGV4OiBwb3MgLSBuYW1lLmxlbmd0aCxcbiAgICAgICAgdmFsdWU6IG5hbWUsXG4gICAgICAgIGJlZm9yZTogdmFsdWUuc2xpY2UocG9zICsgMSwgbmV4dClcbiAgICAgIH07XG4gICAgICBwb3MgPSBuZXh0O1xuXG4gICAgICBpZiAobmFtZSA9PT0gXCJ1cmxcIiAmJiBjb2RlICE9PSBzaW5nbGVRdW90ZSAmJiBjb2RlICE9PSBkb3VibGVRdW90ZSkge1xuICAgICAgICBuZXh0IC09IDE7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBlc2NhcGUgPSBmYWxzZTtcbiAgICAgICAgICBuZXh0ID0gdmFsdWUuaW5kZXhPZihcIilcIiwgbmV4dCArIDEpO1xuICAgICAgICAgIGlmICh+bmV4dCkge1xuICAgICAgICAgICAgZXNjYXBlUG9zID0gbmV4dDtcbiAgICAgICAgICAgIHdoaWxlICh2YWx1ZS5jaGFyQ29kZUF0KGVzY2FwZVBvcyAtIDEpID09PSBiYWNrc2xhc2gpIHtcbiAgICAgICAgICAgICAgZXNjYXBlUG9zIC09IDE7XG4gICAgICAgICAgICAgIGVzY2FwZSA9ICFlc2NhcGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlICs9IFwiKVwiO1xuICAgICAgICAgICAgbmV4dCA9IHZhbHVlLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB0b2tlbi51bmNsb3NlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChlc2NhcGUpO1xuICAgICAgICAvLyBXaGl0ZXNwYWNlcyBiZWZvcmUgY2xvc2VkXG4gICAgICAgIHdoaXRlc3BhY2VQb3MgPSBuZXh0O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgd2hpdGVzcGFjZVBvcyAtPSAxO1xuICAgICAgICAgIGNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KHdoaXRlc3BhY2VQb3MpO1xuICAgICAgICB9IHdoaWxlIChjb2RlIDw9IDMyKTtcbiAgICAgICAgaWYgKHBvcyAhPT0gd2hpdGVzcGFjZVBvcyArIDEpIHtcbiAgICAgICAgICB0b2tlbi5ub2RlcyA9IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJ3b3JkXCIsXG4gICAgICAgICAgICAgIHNvdXJjZUluZGV4OiBwb3MsXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZS5zbGljZShwb3MsIHdoaXRlc3BhY2VQb3MgKyAxKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9rZW4ubm9kZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4udW5jbG9zZWQgJiYgd2hpdGVzcGFjZVBvcyArIDEgIT09IG5leHQpIHtcbiAgICAgICAgICB0b2tlbi5hZnRlciA9IFwiXCI7XG4gICAgICAgICAgdG9rZW4ubm9kZXMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBcInNwYWNlXCIsXG4gICAgICAgICAgICBzb3VyY2VJbmRleDogd2hpdGVzcGFjZVBvcyArIDEsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUuc2xpY2Uod2hpdGVzcGFjZVBvcyArIDEsIG5leHQpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9rZW4uYWZ0ZXIgPSB2YWx1ZS5zbGljZSh3aGl0ZXNwYWNlUG9zICsgMSwgbmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gbmV4dCArIDE7XG4gICAgICAgIGNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhbGFuY2VkICs9IDE7XG4gICAgICAgIHRva2VuLmFmdGVyID0gXCJcIjtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBzdGFjay5wdXNoKHRva2VuKTtcbiAgICAgICAgdG9rZW5zID0gdG9rZW4ubm9kZXMgPSBbXTtcbiAgICAgICAgcGFyZW50ID0gdG9rZW47XG4gICAgICB9XG4gICAgICBuYW1lID0gXCJcIjtcblxuICAgICAgLy8gQ2xvc2UgcGFyZW50aGVzZXNcbiAgICB9IGVsc2UgaWYgKGNsb3NlUGFyZW50aGVzZXMgPT09IGNvZGUgJiYgYmFsYW5jZWQpIHtcbiAgICAgIHBvcyArPSAxO1xuICAgICAgY29kZSA9IHZhbHVlLmNoYXJDb2RlQXQocG9zKTtcblxuICAgICAgcGFyZW50LmFmdGVyID0gYWZ0ZXI7XG4gICAgICBhZnRlciA9IFwiXCI7XG4gICAgICBiYWxhbmNlZCAtPSAxO1xuICAgICAgc3RhY2sucG9wKCk7XG4gICAgICBwYXJlbnQgPSBzdGFja1tiYWxhbmNlZF07XG4gICAgICB0b2tlbnMgPSBwYXJlbnQubm9kZXM7XG5cbiAgICAgIC8vIFdvcmRzXG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHQgPSBwb3M7XG4gICAgICBkbyB7XG4gICAgICAgIGlmIChjb2RlID09PSBiYWNrc2xhc2gpIHtcbiAgICAgICAgICBuZXh0ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dCArPSAxO1xuICAgICAgICBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChuZXh0KTtcbiAgICAgIH0gd2hpbGUgKFxuICAgICAgICBuZXh0IDwgbWF4ICYmXG4gICAgICAgICEoXG4gICAgICAgICAgY29kZSA8PSAzMiB8fFxuICAgICAgICAgIGNvZGUgPT09IHNpbmdsZVF1b3RlIHx8XG4gICAgICAgICAgY29kZSA9PT0gZG91YmxlUXVvdGUgfHxcbiAgICAgICAgICBjb2RlID09PSBjb21tYSB8fFxuICAgICAgICAgIGNvZGUgPT09IGNvbG9uIHx8XG4gICAgICAgICAgY29kZSA9PT0gc2xhc2ggfHxcbiAgICAgICAgICBjb2RlID09PSBvcGVuUGFyZW50aGVzZXMgfHxcbiAgICAgICAgICAoY29kZSA9PT0gY2xvc2VQYXJlbnRoZXNlcyAmJiBiYWxhbmNlZClcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHRva2VuID0gdmFsdWUuc2xpY2UocG9zLCBuZXh0KTtcblxuICAgICAgaWYgKG9wZW5QYXJlbnRoZXNlcyA9PT0gY29kZSkge1xuICAgICAgICBuYW1lID0gdG9rZW47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJ3b3JkXCIsXG4gICAgICAgICAgc291cmNlSW5kZXg6IHBvcyxcbiAgICAgICAgICB2YWx1ZTogdG9rZW5cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHBvcyA9IG5leHQ7XG4gICAgfVxuICB9XG5cbiAgZm9yIChwb3MgPSBzdGFjay5sZW5ndGggLSAxOyBwb3M7IHBvcyAtPSAxKSB7XG4gICAgc3RhY2tbcG9zXS51bmNsb3NlZCA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gc3RhY2tbMF0ubm9kZXM7XG59O1xuIl0sIm5hbWVzIjpbIm9wZW5QYXJlbnRoZXNlcyIsImNoYXJDb2RlQXQiLCJjbG9zZVBhcmVudGhlc2VzIiwic2luZ2xlUXVvdGUiLCJkb3VibGVRdW90ZSIsImJhY2tzbGFzaCIsInNsYXNoIiwiY29tbWEiLCJjb2xvbiIsInN0YXIiLCJtb2R1bGUiLCJleHBvcnRzIiwiaW5wdXQiLCJ0b2tlbnMiLCJ2YWx1ZSIsIm5leHQiLCJxdW90ZSIsInByZXYiLCJ0b2tlbiIsImVzY2FwZSIsImVzY2FwZVBvcyIsIndoaXRlc3BhY2VQb3MiLCJwb3MiLCJjb2RlIiwibWF4IiwibGVuZ3RoIiwic3RhY2siLCJub2RlcyIsImJhbGFuY2VkIiwicGFyZW50IiwibmFtZSIsImJlZm9yZSIsImFmdGVyIiwic2xpY2UiLCJ0eXBlIiwicHVzaCIsInNvdXJjZUluZGV4IiwiaW5kZXhPZiIsInVuY2xvc2VkIiwicG9wIl0sIm1hcHBpbmdzIjoiQUFBQSxJQUFJQSxrQkFBa0IsSUFBSUMsVUFBVSxDQUFDO0FBQ3JDLElBQUlDLG1CQUFtQixJQUFJRCxVQUFVLENBQUM7QUFDdEMsSUFBSUUsY0FBYyxJQUFJRixVQUFVLENBQUM7QUFDakMsSUFBSUcsY0FBYyxJQUFJSCxVQUFVLENBQUM7QUFDakMsSUFB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\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/reduce-css-calc/node_modules/postcss-value-parser/lib/parse.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/reduce-css-calc/node_modules/postcss-value-parser/lib/stringify.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/reduce-css-calc/node_modules/postcss-value-parser/lib/stringify.js ***!
  \*****************************************************************************************/
/***/ ((module) => {

eval("function stringifyNode(node, custom) {\n    var type = node.type;\n    var value = node.value;\n    var buf;\n    var customResult;\n    if (custom && (customResult = custom(node)) !== undefined) {\n        return customResult;\n    } else if (type === \"word\" || type === \"space\") {\n        return value;\n    } else if (type === \"string\") {\n        buf = node.quote || \"\";\n        return buf + value + (node.unclosed ? \"\" : buf);\n    } else if (type === \"comment\") {\n        return \"/*\" + value + (node.unclosed ? \"\" : \"*/\");\n    } else if (type === \"div\") {\n        return (node.before || \"\") + value + (node.after || \"\");\n    } else if (Array.isArray(node.nodes)) {\n        buf = stringify(node.nodes);\n        if (type !== \"function\") {\n            return buf;\n        }\n        return value + \"(\" + (node.before || \"\") + buf + (node.after || \"\") + (node.unclosed ? \"\" : \")\");\n    }\n    return value;\n}\nfunction stringify(nodes, custom) {\n    var result, i;\n    if (Array.isArray(nodes)) {\n        result = \"\";\n        for(i = nodes.length - 1; ~i; i -= 1){\n            result = stringifyNode(nodes[i], custom) + result;\n        }\n        return result;\n    }\n    return stringifyNode(nodes, custom);\n}\nmodule.exports = stringify;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbmNvbWUtZXhwZW5zZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9yZWR1Y2UtY3NzLWNhbGMvbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtdmFsdWUtcGFyc2VyL2xpYi9zdHJpbmdpZnkuanM/OTRiOSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBzdHJpbmdpZnlOb2RlKG5vZGUsIGN1c3RvbSkge1xuICB2YXIgdHlwZSA9IG5vZGUudHlwZTtcbiAgdmFyIHZhbHVlID0gbm9kZS52YWx1ZTtcbiAgdmFyIGJ1ZjtcbiAgdmFyIGN1c3RvbVJlc3VsdDtcblxuICBpZiAoY3VzdG9tICYmIChjdXN0b21SZXN1bHQgPSBjdXN0b20obm9kZSkpICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gY3VzdG9tUmVzdWx0O1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IFwid29yZFwiIHx8IHR5cGUgPT09IFwic3BhY2VcIikge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgYnVmID0gbm9kZS5xdW90ZSB8fCBcIlwiO1xuICAgIHJldHVybiBidWYgKyB2YWx1ZSArIChub2RlLnVuY2xvc2VkID8gXCJcIiA6IGJ1Zik7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJjb21tZW50XCIpIHtcbiAgICByZXR1cm4gXCIvKlwiICsgdmFsdWUgKyAobm9kZS51bmNsb3NlZCA/IFwiXCIgOiBcIiovXCIpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiZGl2XCIpIHtcbiAgICByZXR1cm4gKG5vZGUuYmVmb3JlIHx8IFwiXCIpICsgdmFsdWUgKyAobm9kZS5hZnRlciB8fCBcIlwiKTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG5vZGUubm9kZXMpKSB7XG4gICAgYnVmID0gc3RyaW5naWZ5KG5vZGUubm9kZXMpO1xuICAgIGlmICh0eXBlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBidWY7XG4gICAgfVxuICAgIHJldHVybiAoXG4gICAgICB2YWx1ZSArXG4gICAgICBcIihcIiArXG4gICAgICAobm9kZS5iZWZvcmUgfHwgXCJcIikgK1xuICAgICAgYnVmICtcbiAgICAgIChub2RlLmFmdGVyIHx8IFwiXCIpICtcbiAgICAgIChub2RlLnVuY2xvc2VkID8gXCJcIiA6IFwiKVwiKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnkobm9kZXMsIGN1c3RvbSkge1xuICB2YXIgcmVzdWx0LCBpO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGVzKSkge1xuICAgIHJlc3VsdCA9IFwiXCI7XG4gICAgZm9yIChpID0gbm9kZXMubGVuZ3RoIC0gMTsgfmk7IGkgLT0gMSkge1xuICAgICAgcmVzdWx0ID0gc3RyaW5naWZ5Tm9kZShub2Rlc1tpXSwgY3VzdG9tKSArIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICByZXR1cm4gc3RyaW5naWZ5Tm9kZShub2RlcywgY3VzdG9tKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdpZnk7XG4iXSwibmFtZXMiOlsic3RyaW5naWZ5Tm9kZSIsIm5vZGUiLCJjdXN0b20iLCJ0eXBlIiwidmFsdWUiLCJidWYiLCJjdXN0b21SZXN1bHQiLCJ1bmRlZmluZWQiLCJxdW90ZSIsInVuY2xvc2VkIiwiYmVmb3JlIiwiYWZ0ZXIiLCJBcnJheSIsImlzQXJyYXkiLCJub2RlcyIsInN0cmluZ2lmeSIsInJlc3VsdCIsImkiLCJsZW5ndGgiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQSxTQUFTQSxjQUFjQyxJQUFJLEVBQUVDLE1BQU07SUFDakMsSUFBSUMsT0FBT0YsS0FBS0UsSUFBSTtJQUNwQixJQUFJQyxRQUFRSCxLQUFLRyxLQUFLO0lBQ3RCLElBQUlDO0lBQ0osSUFBSUM7SUFFSixJQUFJSixVQUFVLEFBQUNJLENBQUFBLGVBQWVKLE9BQU9ELEtBQUksTUFBT00sV0FBVztRQUN6RCxPQUFPRDtJQUNULE9BQU8sSUFBSUgsU0FBUyxVQUFVQSxTQUFTLFNBQVM7UUFDOUMsT0FBT0M7SUFDVCxPQUFPLElBQUlELFNBQVMsVUFBVTtRQUM1QkUsTUFBTUosS0FBS08sS0FBSyxJQUFJO1FBQ3BCLE9BQU9ILE1BQU1ELFFBQVNILENBQUFBLEtBQUtRLFFBQVEsR0FBRyxLQUFLSixHQUFFO0lBQy9DLE9BQU8sSUFBSUYsU0FBUyxXQUFXO1FBQzdCLE9BQU8sT0FBT0MsUUFBU0gsQ0FBQUEsS0FBS1EsUUFBUSxHQUFHLEtBQUssSUFBRztJQUNqRCxPQUFPLElBQUlOLFNBQVMsT0FBTztRQUN6QixPQUFPLEFBQUNGLENBQUFBLEtBQUtTLE1BQU0sSUFBSSxFQUFDLElBQUtOLFFBQVNILENBQUFBLEtBQUtVLEtBQUssSUFBSSxFQUFDO0lBQ3ZELE9BQU8sSUFBSUMsTUFBTUMsT0FBTyxDQUFDWixLQUFLYSxLQUFLLEdBQUc7UUFDcENULE1BQU1VLFVBQVVkLEtBQUthLEtBQUs7UUFDMUIsSUFBSVgsU0FBUyxZQUFZO1lBQ3ZCLE9BQU9FO1FBQ1Q7UUFDQSxPQUNFRCxRQUNBLE1BQ0NILENBQUFBLEtBQUtTLE1BQU0sSUFBSSxFQUFDLElBQ2pCTCxNQUNDSixDQUFBQSxLQUFLVSxLQUFLLElBQUksRUFBQyxJQUNmVixDQUFBQSxLQUFLUSxRQUFRLEdBQUcsS0FBSyxHQUFFO0lBRTVCO0lBQ0EsT0FBT0w7QUFDVDtBQUVBLFNBQVNXLFVBQVVELEtBQUssRUFBRVosTUFBTTtJQUM5QixJQUFJYyxRQUFRQztJQUVaLElBQUlMLE1BQU1DLE9BQU8sQ0FBQ0MsUUFBUTtRQUN4QkUsU0FBUztRQUNULElBQUtDLElBQUlILE1BQU1JLE1BQU0sR0FBRyxHQUFHLENBQUNELEdBQUdBLEtBQUssRUFBRztZQUNyQ0QsU0FBU2hCLGNBQWNjLEtBQUssQ0FBQ0csRUFBRSxFQUFFZixVQUFVYztRQUM3QztRQUNBLE9BQU9BO0lBQ1Q7SUFDQSxPQUFPaEIsY0FBY2MsT0FBT1o7QUFDOUI7QUFFQWlCLE9BQU9DLE9BQU8sR0FBR0wiLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVkdWNlLWNzcy1jYWxjL25vZGVfbW9kdWxlcy9wb3N0Y3NzLXZhbHVlLXBhcnNlci9saWIvc3RyaW5naWZ5LmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/reduce-css-calc/node_modules/postcss-value-parser/lib/stringify.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/reduce-css-calc/node_modules/postcss-value-parser/lib/unit.js":
/*!************************************************************************************!*\
  !*** ./node_modules/reduce-css-calc/node_modules/postcss-value-parser/lib/unit.js ***!
  \************************************************************************************/
/***/ ((module) => {

eval("var minus = \"-\".charCodeAt(0);\nvar plus = \"+\".charCodeAt(0);\nvar dot = \".\".charCodeAt(0);\nvar exp = \"e\".charCodeAt(0);\nvar EXP = \"E\".charCodeAt(0);\nmodule.exports = function(value) {\n    var pos = 0;\n    var length = value.length;\n    var dotted = false;\n    var sciPos = -1;\n    var containsNumber = false;\n    var code;\n    while(pos < length){\n        code = value.charCodeAt(pos);\n        if (code >= 48 && code <= 57) {\n            containsNumber = true;\n        } else if (code === exp || code === EXP) {\n            if (sciPos > -1) {\n                break;\n            }\n            sciPos = pos;\n        } else if (code === dot) {\n            if (dotted) {\n                break;\n            }\n            dotted = true;\n        } else if (code === plus || code === minus) {\n            if (pos !== 0) {\n                break;\n            }\n        } else {\n            break;\n        }\n        pos += 1;\n    }\n    if (sciPos + 1 === pos) pos--;\n    return containsNumber ? {\n        number: value.slice(0, pos),\n        unit: value.slice(pos)\n    } : false;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbmNvbWUtZXhwZW5zZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9yZWR1Y2UtY3NzLWNhbGMvbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtdmFsdWUtcGFyc2VyL2xpYi91bml0LmpzPzNhZmQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIG1pbnVzID0gXCItXCIuY2hhckNvZGVBdCgwKTtcbnZhciBwbHVzID0gXCIrXCIuY2hhckNvZGVBdCgwKTtcbnZhciBkb3QgPSBcIi5cIi5jaGFyQ29kZUF0KDApO1xudmFyIGV4cCA9IFwiZVwiLmNoYXJDb2RlQXQoMCk7XG52YXIgRVhQID0gXCJFXCIuY2hhckNvZGVBdCgwKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWx1ZSkge1xuICB2YXIgcG9zID0gMDtcbiAgdmFyIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgdmFyIGRvdHRlZCA9IGZhbHNlO1xuICB2YXIgc2NpUG9zID0gLTE7XG4gIHZhciBjb250YWluc051bWJlciA9IGZhbHNlO1xuICB2YXIgY29kZTtcblxuICB3aGlsZSAocG9zIDwgbGVuZ3RoKSB7XG4gICAgY29kZSA9IHZhbHVlLmNoYXJDb2RlQXQocG9zKTtcblxuICAgIGlmIChjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTcpIHtcbiAgICAgIGNvbnRhaW5zTnVtYmVyID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IGV4cCB8fCBjb2RlID09PSBFWFApIHtcbiAgICAgIGlmIChzY2lQb3MgPiAtMSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHNjaVBvcyA9IHBvcztcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IGRvdCkge1xuICAgICAgaWYgKGRvdHRlZCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRvdHRlZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSBwbHVzIHx8IGNvZGUgPT09IG1pbnVzKSB7XG4gICAgICBpZiAocG9zICE9PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBwb3MgKz0gMTtcbiAgfVxuXG4gIGlmIChzY2lQb3MgKyAxID09PSBwb3MpIHBvcy0tO1xuXG4gIHJldHVybiBjb250YWluc051bWJlclxuICAgID8ge1xuICAgICAgICBudW1iZXI6IHZhbHVlLnNsaWNlKDAsIHBvcyksXG4gICAgICAgIHVuaXQ6IHZhbHVlLnNsaWNlKHBvcylcbiAgICAgIH1cbiAgICA6IGZhbHNlO1xufTtcbiJdLCJuYW1lcyI6WyJtaW51cyIsImNoYXJDb2RlQXQiLCJwbHVzIiwiZG90IiwiZXhwIiwiRVhQIiwibW9kdWxlIiwiZXhwb3J0cyIsInZhbHVlIiwicG9zIiwibGVuZ3RoIiwiZG90dGVkIiwic2NpUG9zIiwiY29udGFpbnNOdW1iZXIiLCJjb2RlIiwibnVtYmVyIiwic2xpY2UiLCJ1bml0Il0sIm1hcHBpbmdzIjoiQUFBQSxJQUFJQSxRQUFRLElBQUlDLFVBQVUsQ0FBQztBQUMzQixJQUFJQyxPQUFPLElBQUlELFVBQVUsQ0FBQztBQUMxQixJQUFJRSxNQUFNLElBQUlGLFVBQVUsQ0FBQztBQUN6QixJQUFJRyxNQUFNLElBQUlILFVBQVUsQ0FBQztBQUN6QixJQUFJSSxNQUFNLElBQUlKLFVBQVUsQ0FBQztBQUV6QkssT0FBT0MsT0FBTyxHQUFHLFNBQVNDLEtBQUs7SUFDN0IsSUFBSUMsTUFBTTtJQUNWLElBQUlDLFNBQVNGLE1BQU1FLE1BQU07SUFDekIsSUFBSUMsU0FBUztJQUNiLElBQUlDLFNBQVMsQ0FBQztJQUNkLElBQUlDLGlCQUFpQjtJQUNyQixJQUFJQztJQUVKLE1BQU9MLE1BQU1DLE9BQVE7UUFDbkJJLE9BQU9OLE1BQU1QLFVBQVUsQ0FBQ1E7UUFFeEIsSUFBSUssUUFBUSxNQUFNQSxRQUFRLElBQUk7WUFDNUJELGlCQUFpQjtRQUNuQixPQUFPLElBQUlDLFNBQVNWLE9BQU9VLFNBQVNULEtBQUs7WUFDdkMsSUFBSU8sU0FBUyxDQUFDLEdBQUc7Z0JBQ2Y7WUFDRjtZQUNBQSxTQUFTSDtRQUNYLE9BQU8sSUFBSUssU0FBU1gsS0FBSztZQUN2QixJQUFJUSxRQUFRO2dCQUNWO1lBQ0Y7WUFDQUEsU0FBUztRQUNYLE9BQU8sSUFBSUcsU0FBU1osUUFBUVksU0FBU2QsT0FBTztZQUMxQyxJQUFJUyxRQUFRLEdBQUc7Z0JBQ2I7WUFDRjtRQUNGLE9BQU87WUFDTDtRQUNGO1FBRUFBLE9BQU87SUFDVDtJQUVBLElBQUlHLFNBQVMsTUFBTUgsS0FBS0E7SUFFeEIsT0FBT0ksaUJBQ0g7UUFDRUUsUUFBUVAsTUFBTVEsS0FBSyxDQUFDLEdBQUdQO1FBQ3ZCUSxNQUFNVCxNQUFNUSxLQUFLLENBQUNQO0lBQ3BCLElBQ0E7QUFDTiIsImZpbGUiOiIoc3NyKS8uL25vZGVfbW9kdWxlcy9yZWR1Y2UtY3NzLWNhbGMvbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtdmFsdWUtcGFyc2VyL2xpYi91bml0LmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/reduce-css-calc/node_modules/postcss-value-parser/lib/unit.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/reduce-css-calc/node_modules/postcss-value-parser/lib/walk.js":
/*!************************************************************************************!*\
  !*** ./node_modules/reduce-css-calc/node_modules/postcss-value-parser/lib/walk.js ***!
  \************************************************************************************/
/***/ ((module) => {

eval("module.exports = function walk(nodes, cb, bubble) {\n    var i, max, node, result;\n    for(i = 0, max = nodes.length; i < max; i += 1){\n        node = nodes[i];\n        if (!bubble) {\n            result = cb(node, i, nodes);\n        }\n        if (result !== false && node.type === \"function\" && Array.isArray(node.nodes)) {\n            walk(node.nodes, cb, bubble);\n        }\n        if (bubble) {\n            cb(node, i, nodes);\n        }\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbmNvbWUtZXhwZW5zZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9yZWR1Y2UtY3NzLWNhbGMvbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtdmFsdWUtcGFyc2VyL2xpYi93YWxrLmpzPzEyOWQiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB3YWxrKG5vZGVzLCBjYiwgYnViYmxlKSB7XG4gIHZhciBpLCBtYXgsIG5vZGUsIHJlc3VsdDtcblxuICBmb3IgKGkgPSAwLCBtYXggPSBub2Rlcy5sZW5ndGg7IGkgPCBtYXg7IGkgKz0gMSkge1xuICAgIG5vZGUgPSBub2Rlc1tpXTtcbiAgICBpZiAoIWJ1YmJsZSkge1xuICAgICAgcmVzdWx0ID0gY2Iobm9kZSwgaSwgbm9kZXMpO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHJlc3VsdCAhPT0gZmFsc2UgJiZcbiAgICAgIG5vZGUudHlwZSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICBBcnJheS5pc0FycmF5KG5vZGUubm9kZXMpXG4gICAgKSB7XG4gICAgICB3YWxrKG5vZGUubm9kZXMsIGNiLCBidWJibGUpO1xuICAgIH1cblxuICAgIGlmIChidWJibGUpIHtcbiAgICAgIGNiKG5vZGUsIGksIG5vZGVzKTtcbiAgICB9XG4gIH1cbn07XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIndhbGsiLCJub2RlcyIsImNiIiwiYnViYmxlIiwiaSIsIm1heCIsIm5vZGUiLCJyZXN1bHQiLCJsZW5ndGgiLCJ0eXBlIiwiQXJyYXkiLCJpc0FycmF5Il0sIm1hcHBpbmdzIjoiQUFBQUEsT0FBT0MsT0FBTyxHQUFHLFNBQVNDLEtBQUtDLEtBQUssRUFBRUMsRUFBRSxFQUFFQyxNQUFNO0lBQzlDLElBQUlDLEdBQUdDLEtBQUtDLE1BQU1DO0lBRWxCLElBQUtILElBQUksR0FBR0MsTUFBTUosTUFBTU8sTUFBTSxFQUFFSixJQUFJQyxLQUFLRCxLQUFLLEVBQUc7UUFDL0NFLE9BQU9MLEtBQUssQ0FBQ0csRUFBRTtRQUNmLElBQUksQ0FBQ0QsUUFBUTtZQUNYSSxTQUFTTCxHQUFHSSxNQUFNRixHQUFHSDtRQUN2QjtRQUVBLElBQ0VNLFdBQVcsU0FDWEQsS0FBS0csSUFBSSxLQUFLLGNBQ2RDLE1BQU1DLE9BQU8sQ0FBQ0wsS0FBS0wsS0FBSyxHQUN4QjtZQUNBRCxLQUFLTSxLQUFLTCxLQUFLLEVBQUVDLElBQUlDO1FBQ3ZCO1FBRUEsSUFBSUEsUUFBUTtZQUNWRCxHQUFHSSxNQUFNRixHQUFHSDtRQUNkO0lBQ0Y7QUFDRiIsImZpbGUiOiIoc3NyKS8uL25vZGVfbW9kdWxlcy9yZWR1Y2UtY3NzLWNhbGMvbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtdmFsdWUtcGFyc2VyL2xpYi93YWxrLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/reduce-css-calc/node_modules/postcss-value-parser/lib/walk.js\n");

/***/ })

};
;