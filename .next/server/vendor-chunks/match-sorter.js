"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/match-sorter";
exports.ids = ["vendor-chunks/match-sorter"];
exports.modules = {

/***/ "(ssr)/./node_modules/match-sorter/dist/match-sorter.esm.js":
/*!************************************************************!*\
  !*** ./node_modules/match-sorter/dist/match-sorter.esm.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultBaseSortFn: () => (/* binding */ defaultBaseSortFn),\n/* harmony export */   matchSorter: () => (/* binding */ matchSorter),\n/* harmony export */   rankings: () => (/* binding */ rankings)\n/* harmony export */ });\n/* harmony import */ var remove_accents__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! remove-accents */ \"(ssr)/./node_modules/remove-accents/index.js\");\n/* harmony import */ var remove_accents__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(remove_accents__WEBPACK_IMPORTED_MODULE_0__);\n\n/**\n * @name match-sorter\n * @license MIT license.\n * @copyright (c) 2020 Kent C. Dodds\n * @author Kent C. Dodds <me@kentcdodds.com> (https://kentcdodds.com)\n */ const rankings = {\n    CASE_SENSITIVE_EQUAL: 7,\n    EQUAL: 6,\n    STARTS_WITH: 5,\n    WORD_STARTS_WITH: 4,\n    CONTAINS: 3,\n    ACRONYM: 2,\n    MATCHES: 1,\n    NO_MATCH: 0\n};\nconst defaultBaseSortFn = (a, b)=>String(a.rankedValue).localeCompare(String(b.rankedValue));\n/**\n * Takes an array of items and a value and returns a new array with the items that match the given value\n * @param {Array} items - the items to sort\n * @param {String} value - the value to use for ranking\n * @param {Object} options - Some options to configure the sorter\n * @return {Array} - the new sorted array\n */ function matchSorter(items, value, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    const { keys, threshold = rankings.MATCHES, baseSort = defaultBaseSortFn, sorter = (matchedItems)=>matchedItems.sort((a, b)=>sortRankedValues(a, b, baseSort)) } = options;\n    const matchedItems = items.reduce(reduceItemsToRanked, []);\n    return sorter(matchedItems).map((_ref)=>{\n        let { item } = _ref;\n        return item;\n    });\n    function reduceItemsToRanked(matches, item, index) {\n        const rankingInfo = getHighestRanking(item, keys, value, options);\n        const { rank, keyThreshold = threshold } = rankingInfo;\n        if (rank >= keyThreshold) {\n            matches.push({\n                ...rankingInfo,\n                item,\n                index\n            });\n        }\n        return matches;\n    }\n}\nmatchSorter.rankings = rankings;\n/**\n * Gets the highest ranking for value for the given item based on its values for the given keys\n * @param {*} item - the item to rank\n * @param {Array} keys - the keys to get values from the item for the ranking\n * @param {String} value - the value to rank against\n * @param {Object} options - options to control the ranking\n * @return {{rank: Number, keyIndex: Number, keyThreshold: Number}} - the highest ranking\n */ function getHighestRanking(item, keys, value, options) {\n    if (!keys) {\n        // if keys is not specified, then we assume the item given is ready to be matched\n        const stringItem = item;\n        return {\n            // ends up being duplicate of 'item' in matches but consistent\n            rankedValue: stringItem,\n            rank: getMatchRanking(stringItem, value, options),\n            keyIndex: -1,\n            keyThreshold: options.threshold\n        };\n    }\n    const valuesToRank = getAllValuesToRank(item, keys);\n    return valuesToRank.reduce((_ref2, _ref3, i)=>{\n        let { rank, rankedValue, keyIndex, keyThreshold } = _ref2;\n        let { itemValue, attributes } = _ref3;\n        let newRank = getMatchRanking(itemValue, value, options);\n        let newRankedValue = rankedValue;\n        const { minRanking, maxRanking, threshold } = attributes;\n        if (newRank < minRanking && newRank >= rankings.MATCHES) {\n            newRank = minRanking;\n        } else if (newRank > maxRanking) {\n            newRank = maxRanking;\n        }\n        if (newRank > rank) {\n            rank = newRank;\n            keyIndex = i;\n            keyThreshold = threshold;\n            newRankedValue = itemValue;\n        }\n        return {\n            rankedValue: newRankedValue,\n            rank,\n            keyIndex,\n            keyThreshold\n        };\n    }, {\n        rankedValue: item,\n        rank: rankings.NO_MATCH,\n        keyIndex: -1,\n        keyThreshold: options.threshold\n    });\n}\n/**\n * Gives a rankings score based on how well the two strings match.\n * @param {String} testString - the string to test against\n * @param {String} stringToRank - the string to rank\n * @param {Object} options - options for the match (like keepDiacritics for comparison)\n * @returns {Number} the ranking for how well stringToRank matches testString\n */ function getMatchRanking(testString, stringToRank, options) {\n    testString = prepareValueForComparison(testString, options);\n    stringToRank = prepareValueForComparison(stringToRank, options);\n    // too long\n    if (stringToRank.length > testString.length) {\n        return rankings.NO_MATCH;\n    }\n    // case sensitive equals\n    if (testString === stringToRank) {\n        return rankings.CASE_SENSITIVE_EQUAL;\n    }\n    // Lower casing before further comparison\n    testString = testString.toLowerCase();\n    stringToRank = stringToRank.toLowerCase();\n    // case insensitive equals\n    if (testString === stringToRank) {\n        return rankings.EQUAL;\n    }\n    // starts with\n    if (testString.startsWith(stringToRank)) {\n        return rankings.STARTS_WITH;\n    }\n    // word starts with\n    if (testString.includes(` ${stringToRank}`)) {\n        return rankings.WORD_STARTS_WITH;\n    }\n    // contains\n    if (testString.includes(stringToRank)) {\n        return rankings.CONTAINS;\n    } else if (stringToRank.length === 1) {\n        // If the only character in the given stringToRank\n        //   isn't even contained in the testString, then\n        //   it's definitely not a match.\n        return rankings.NO_MATCH;\n    }\n    // acronym\n    if (getAcronym(testString).includes(stringToRank)) {\n        return rankings.ACRONYM;\n    }\n    // will return a number between rankings.MATCHES and\n    // rankings.MATCHES + 1 depending  on how close of a match it is.\n    return getClosenessRanking(testString, stringToRank);\n}\n/**\n * Generates an acronym for a string.\n *\n * @param {String} string the string for which to produce the acronym\n * @returns {String} the acronym\n */ function getAcronym(string) {\n    let acronym = \"\";\n    const wordsInString = string.split(\" \");\n    wordsInString.forEach((wordInString)=>{\n        const splitByHyphenWords = wordInString.split(\"-\");\n        splitByHyphenWords.forEach((splitByHyphenWord)=>{\n            acronym += splitByHyphenWord.substr(0, 1);\n        });\n    });\n    return acronym;\n}\n/**\n * Returns a score based on how spread apart the\n * characters from the stringToRank are within the testString.\n * A number close to rankings.MATCHES represents a loose match. A number close\n * to rankings.MATCHES + 1 represents a tighter match.\n * @param {String} testString - the string to test against\n * @param {String} stringToRank - the string to rank\n * @returns {Number} the number between rankings.MATCHES and\n * rankings.MATCHES + 1 for how well stringToRank matches testString\n */ function getClosenessRanking(testString, stringToRank) {\n    let matchingInOrderCharCount = 0;\n    function findMatchingCharacter(matchChar, string, index) {\n        for(let j = index, J = string.length; j < J; j++){\n            const stringChar = string[j];\n            if (stringChar === matchChar) {\n                matchingInOrderCharCount += 1;\n                return j + 1;\n            }\n        }\n        return -1;\n    }\n    let skipped = 0;\n    function getRanking(spread) {\n        const spreadPercentage = 1 / spread;\n        const inOrderPercentage = matchingInOrderCharCount / stringToRank.length;\n        const matchPercentage = (stringToRank.length - skipped) / stringToRank.length;\n        const ranking = rankings.MATCHES + inOrderPercentage * spreadPercentage * matchPercentage;\n        return ranking;\n    }\n    let firstIndex = 0;\n    let charNumber = 0;\n    let nextCharNumber = 0;\n    for(let i = 0, I = stringToRank.length; i < I; i++){\n        const matchChar = stringToRank[i];\n        nextCharNumber = findMatchingCharacter(matchChar, testString, charNumber);\n        const found = nextCharNumber > -1;\n        if (found) {\n            charNumber = nextCharNumber;\n            if (i === 0) {\n                firstIndex = charNumber;\n            }\n        } else if (skipped > 0 || stringToRank.length <= 3) {\n            // if search term is short, require finding all characters\n            return rankings.NO_MATCH;\n        } else {\n            skipped += 1;\n        }\n    }\n    const spread = charNumber - firstIndex;\n    return getRanking(spread);\n}\n/**\n * Sorts items that have a rank, index, and keyIndex\n * @param {Object} a - the first item to sort\n * @param {Object} b - the second item to sort\n * @return {Number} -1 if a should come first, 1 if b should come first, 0 if equal\n */ function sortRankedValues(a, b, baseSort) {\n    const aFirst = -1;\n    const bFirst = 1;\n    const { rank: aRank, keyIndex: aKeyIndex } = a;\n    const { rank: bRank, keyIndex: bKeyIndex } = b;\n    const same = aRank === bRank;\n    if (same) {\n        if (aKeyIndex === bKeyIndex) {\n            // use the base sort function as a tie-breaker\n            return baseSort(a, b);\n        } else {\n            return aKeyIndex < bKeyIndex ? aFirst : bFirst;\n        }\n    } else {\n        return aRank > bRank ? aFirst : bFirst;\n    }\n}\n/**\n * Prepares value for comparison by stringifying it, removing diacritics (if specified)\n * @param {String} value - the value to clean\n * @param {Object} options - {keepDiacritics: whether to remove diacritics}\n * @return {String} the prepared value\n */ function prepareValueForComparison(value, _ref4) {\n    let { keepDiacritics } = _ref4;\n    // value might not actually be a string at this point (we don't get to choose)\n    // so part of preparing the value for comparison is ensure that it is a string\n    value = `${value}`; // toString\n    if (!keepDiacritics) {\n        value = remove_accents__WEBPACK_IMPORTED_MODULE_0___default()(value);\n    }\n    return value;\n}\n/**\n * Gets value for key in item at arbitrarily nested keypath\n * @param {Object} item - the item\n * @param {Object|Function} key - the potentially nested keypath or property callback\n * @return {Array} - an array containing the value(s) at the nested keypath\n */ function getItemValues(item, key) {\n    if (typeof key === \"object\") {\n        key = key.key;\n    }\n    let value;\n    if (typeof key === \"function\") {\n        value = key(item);\n    } else if (item == null) {\n        value = null;\n    } else if (Object.hasOwnProperty.call(item, key)) {\n        value = item[key];\n    } else if (key.includes(\".\")) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n        return getNestedValues(key, item);\n    } else {\n        value = null;\n    }\n    // because `value` can also be undefined\n    if (value == null) {\n        return [];\n    }\n    if (Array.isArray(value)) {\n        return value;\n    }\n    return [\n        String(value)\n    ];\n}\n/**\n * Given path: \"foo.bar.baz\"\n * And item: {foo: {bar: {baz: 'buzz'}}}\n *   -> 'buzz'\n * @param path a dot-separated set of keys\n * @param item the item to get the value from\n */ function getNestedValues(path, item) {\n    const keys = path.split(\".\");\n    let values = [\n        item\n    ];\n    for(let i = 0, I = keys.length; i < I; i++){\n        const nestedKey = keys[i];\n        let nestedValues = [];\n        for(let j = 0, J = values.length; j < J; j++){\n            const nestedItem = values[j];\n            if (nestedItem == null) continue;\n            if (Object.hasOwnProperty.call(nestedItem, nestedKey)) {\n                const nestedValue = nestedItem[nestedKey];\n                if (nestedValue != null) {\n                    nestedValues.push(nestedValue);\n                }\n            } else if (nestedKey === \"*\") {\n                // ensure that values is an array\n                nestedValues = nestedValues.concat(nestedItem);\n            }\n        }\n        values = nestedValues;\n    }\n    if (Array.isArray(values[0])) {\n        // keep allowing the implicit wildcard for an array of strings at the end of\n        // the path; don't use `.flat()` because that's not available in node.js v10\n        const result = [];\n        return result.concat(...values);\n    }\n    // Based on our logic it should be an array of strings by now...\n    // assuming the user's path terminated in strings\n    return values;\n}\n/**\n * Gets all the values for the given keys in the given item and returns an array of those values\n * @param item - the item from which the values will be retrieved\n * @param keys - the keys to use to retrieve the values\n * @return objects with {itemValue, attributes}\n */ function getAllValuesToRank(item, keys) {\n    const allValues = [];\n    for(let j = 0, J = keys.length; j < J; j++){\n        const key = keys[j];\n        const attributes = getKeyAttributes(key);\n        const itemValues = getItemValues(item, key);\n        for(let i = 0, I = itemValues.length; i < I; i++){\n            allValues.push({\n                itemValue: itemValues[i],\n                attributes\n            });\n        }\n    }\n    return allValues;\n}\nconst defaultKeyAttributes = {\n    maxRanking: Infinity,\n    minRanking: -Infinity\n};\n/**\n * Gets all the attributes for the given key\n * @param key - the key from which the attributes will be retrieved\n * @return object containing the key's attributes\n */ function getKeyAttributes(key) {\n    if (typeof key === \"string\") {\n        return defaultKeyAttributes;\n    }\n    return {\n        ...defaultKeyAttributes,\n        ...key\n    };\n}\n/*\neslint\n  no-continue: \"off\",\n*/ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWF0Y2gtc29ydGVyL2Rpc3QvbWF0Y2gtc29ydGVyLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUEyQztBQUUzQzs7Ozs7Q0FLQyxHQUNELE1BQU1DLFdBQVc7SUFDZkMsc0JBQXNCO0lBQ3RCQyxPQUFPO0lBQ1BDLGFBQWE7SUFDYkMsa0JBQWtCO0lBQ2xCQyxVQUFVO0lBQ1ZDLFNBQVM7SUFDVEMsU0FBUztJQUNUQyxVQUFVO0FBQ1o7QUFDQSxNQUFNQyxvQkFBb0IsQ0FBQ0MsR0FBR0MsSUFBTUMsT0FBT0YsRUFBRUcsV0FBVyxFQUFFQyxhQUFhLENBQUNGLE9BQU9ELEVBQUVFLFdBQVc7QUFFNUY7Ozs7OztDQU1DLEdBQ0QsU0FBU0UsWUFBWUMsS0FBSyxFQUFFQyxLQUFLLEVBQUVDLE9BQU87SUFDeEMsSUFBSUEsWUFBWSxLQUFLLEdBQUc7UUFDdEJBLFVBQVUsQ0FBQztJQUNiO0lBQ0EsTUFBTSxFQUNKQyxJQUFJLEVBQ0pDLFlBQVlwQixTQUFTTyxPQUFPLEVBQzVCYyxXQUFXWixpQkFBaUIsRUFDNUJhLFNBQVNDLENBQUFBLGVBQWdCQSxhQUFhQyxJQUFJLENBQUMsQ0FBQ2QsR0FBR0MsSUFBTWMsaUJBQWlCZixHQUFHQyxHQUFHVSxVQUFVLEVBQ3ZGLEdBQUdIO0lBQ0osTUFBTUssZUFBZVAsTUFBTVUsTUFBTSxDQUFDQyxxQkFBcUIsRUFBRTtJQUN6RCxPQUFPTCxPQUFPQyxjQUFjSyxHQUFHLENBQUNDLENBQUFBO1FBQzlCLElBQUksRUFDRkMsSUFBSSxFQUNMLEdBQUdEO1FBQ0osT0FBT0M7SUFDVDtJQUNBLFNBQVNILG9CQUFvQkksT0FBTyxFQUFFRCxJQUFJLEVBQUVFLEtBQUs7UUFDL0MsTUFBTUMsY0FBY0Msa0JBQWtCSixNQUFNWCxNQUFNRixPQUFPQztRQUN6RCxNQUFNLEVBQ0ppQixJQUFJLEVBQ0pDLGVBQWVoQixTQUFTLEVBQ3pCLEdBQUdhO1FBQ0osSUFBSUUsUUFBUUMsY0FBYztZQUN4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Q3ZDLElBQUssSUFBSXJELElBQUksR0FBR3lDLElBQUk2QixXQUFXNUQsTUFBTSxFQUFFVixJQUFJeUMsR0FBR3pDLElBQUs7WUFDakRvRSxVQUFVNUUsSUFBSSxDQUFDO2dCQUNiUyxXQUFXcUUsVUFBVSxDQUFDdEUsRUFBRTtnQkFDeEJFO1lBQ0Y7UUFDRjtJQUNGO0lBQ0EsT0FBT2tFO0FBQ1Q7QUFDQSxNQUFNRyx1QkFBdUI7SUFDM0JqRSxZQUFZa0U7SUFDWm5FLFlBQVksQ0FBQ21FO0FBQ2Y7QUFDQTs7OztDQUlDLEdBQ0QsU0FBU0gsaUJBQWlCaEIsR0FBRztJQUMzQixJQUFJLE9BQU9BLFFBQVEsVUFBVTtRQUMzQixPQUFPa0I7SUFDVDtJQUNBLE9BQU87UUFDTCxHQUFHQSxvQkFBb0I7UUFDdkIsR0FBR2xCLEdBQUc7SUFDUjtBQUNGO0FBRUE7OztBQUdBLEdBRW9EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5jb21lLWV4cGVuc2UtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvbWF0Y2gtc29ydGVyL2Rpc3QvbWF0Y2gtc29ydGVyLmVzbS5qcz84NzgyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCByZW1vdmVBY2NlbnRzIGZyb20gJ3JlbW92ZS1hY2NlbnRzJztcblxuLyoqXG4gKiBAbmFtZSBtYXRjaC1zb3J0ZXJcbiAqIEBsaWNlbnNlIE1JVCBsaWNlbnNlLlxuICogQGNvcHlyaWdodCAoYykgMjAyMCBLZW50IEMuIERvZGRzXG4gKiBAYXV0aG9yIEtlbnQgQy4gRG9kZHMgPG1lQGtlbnRjZG9kZHMuY29tPiAoaHR0cHM6Ly9rZW50Y2RvZGRzLmNvbSlcbiAqL1xuY29uc3QgcmFua2luZ3MgPSB7XG4gIENBU0VfU0VOU0lUSVZFX0VRVUFMOiA3LFxuICBFUVVBTDogNixcbiAgU1RBUlRTX1dJVEg6IDUsXG4gIFdPUkRfU1RBUlRTX1dJVEg6IDQsXG4gIENPTlRBSU5TOiAzLFxuICBBQ1JPTllNOiAyLFxuICBNQVRDSEVTOiAxLFxuICBOT19NQVRDSDogMFxufTtcbmNvbnN0IGRlZmF1bHRCYXNlU29ydEZuID0gKGEsIGIpID0+IFN0cmluZyhhLnJhbmtlZFZhbHVlKS5sb2NhbGVDb21wYXJlKFN0cmluZyhiLnJhbmtlZFZhbHVlKSk7XG5cbi8qKlxuICogVGFrZXMgYW4gYXJyYXkgb2YgaXRlbXMgYW5kIGEgdmFsdWUgYW5kIHJldHVybnMgYSBuZXcgYXJyYXkgd2l0aCB0aGUgaXRlbXMgdGhhdCBtYXRjaCB0aGUgZ2l2ZW4gdmFsdWVcbiAqIEBwYXJhbSB7QXJyYXl9IGl0ZW1zIC0gdGhlIGl0ZW1zIHRvIHNvcnRcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byB1c2UgZm9yIHJhbmtpbmdcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gU29tZSBvcHRpb25zIHRvIGNvbmZpZ3VyZSB0aGUgc29ydGVyXG4gKiBAcmV0dXJuIHtBcnJheX0gLSB0aGUgbmV3IHNvcnRlZCBhcnJheVxuICovXG5mdW5jdGlvbiBtYXRjaFNvcnRlcihpdGVtcywgdmFsdWUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAga2V5cyxcbiAgICB0aHJlc2hvbGQgPSByYW5raW5ncy5NQVRDSEVTLFxuICAgIGJhc2VTb3J0ID0gZGVmYXVsdEJhc2VTb3J0Rm4sXG4gICAgc29ydGVyID0gbWF0Y2hlZEl0ZW1zID0+IG1hdGNoZWRJdGVtcy5zb3J0KChhLCBiKSA9PiBzb3J0UmFua2VkVmFsdWVzKGEsIGIsIGJhc2VTb3J0KSlcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IG1hdGNoZWRJdGVtcyA9IGl0ZW1zLnJlZHVjZShyZWR1Y2VJdGVtc1RvUmFua2VkLCBbXSk7XG4gIHJldHVybiBzb3J0ZXIobWF0Y2hlZEl0ZW1zKS5tYXAoX3JlZiA9PiB7XG4gICAgbGV0IHtcbiAgICAgIGl0ZW1cbiAgICB9ID0gX3JlZjtcbiAgICByZXR1cm4gaXRlbTtcbiAgfSk7XG4gIGZ1bmN0aW9uIHJlZHVjZUl0ZW1zVG9SYW5rZWQobWF0Y2hlcywgaXRlbSwgaW5kZXgpIHtcbiAgICBjb25zdCByYW5raW5nSW5mbyA9IGdldEhpZ2hlc3RSYW5raW5nKGl0ZW0sIGtleXMsIHZhbHVlLCBvcHRpb25zKTtcbiAgICBjb25zdCB7XG4gICAgICByYW5rLFxuICAgICAga2V5VGhyZXNob2xkID0gdGhyZXNob2xkXG4gICAgfSA9IHJhbmtpbmdJbmZvO1xuICAgIGlmIChyYW5rID49IGtleVRocmVzaG9sZCkge1xuICAgICAgbWF0Y2hlcy5wdXNoKHtcbiAgICAgICAgLi4ucmFua2luZ0luZm8sXG4gICAgICAgIGl0ZW0sXG4gICAgICAgIGluZGV4XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoZXM7XG4gIH1cbn1cbm1hdGNoU29ydGVyLnJhbmtpbmdzID0gcmFua2luZ3M7XG5cbi8qKlxuICogR2V0cyB0aGUgaGlnaGVzdCByYW5raW5nIGZvciB2YWx1ZSBmb3IgdGhlIGdpdmVuIGl0ZW0gYmFzZWQgb24gaXRzIHZhbHVlcyBmb3IgdGhlIGdpdmVuIGtleXNcbiAqIEBwYXJhbSB7Kn0gaXRlbSAtIHRoZSBpdGVtIHRvIHJhbmtcbiAqIEBwYXJhbSB7QXJyYXl9IGtleXMgLSB0aGUga2V5cyB0byBnZXQgdmFsdWVzIGZyb20gdGhlIGl0ZW0gZm9yIHRoZSByYW5raW5nXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgLSB0aGUgdmFsdWUgdG8gcmFuayBhZ2FpbnN0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgdG8gY29udHJvbCB0aGUgcmFua2luZ1xuICogQHJldHVybiB7e3Jhbms6IE51bWJlciwga2V5SW5kZXg6IE51bWJlciwga2V5VGhyZXNob2xkOiBOdW1iZXJ9fSAtIHRoZSBoaWdoZXN0IHJhbmtpbmdcbiAqL1xuZnVuY3Rpb24gZ2V0SGlnaGVzdFJhbmtpbmcoaXRlbSwga2V5cywgdmFsdWUsIG9wdGlvbnMpIHtcbiAgaWYgKCFrZXlzKSB7XG4gICAgLy8gaWYga2V5cyBpcyBub3Qgc3BlY2lmaWVkLCB0aGVuIHdlIGFzc3VtZSB0aGUgaXRlbSBnaXZlbiBpcyByZWFkeSB0byBiZSBtYXRjaGVkXG4gICAgY29uc3Qgc3RyaW5nSXRlbSA9IGl0ZW07XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIGVuZHMgdXAgYmVpbmcgZHVwbGljYXRlIG9mICdpdGVtJyBpbiBtYXRjaGVzIGJ1dCBjb25zaXN0ZW50XG4gICAgICByYW5rZWRWYWx1ZTogc3RyaW5nSXRlbSxcbiAgICAgIHJhbms6IGdldE1hdGNoUmFua2luZyhzdHJpbmdJdGVtLCB2YWx1ZSwgb3B0aW9ucyksXG4gICAgICBrZXlJbmRleDogLTEsXG4gICAgICBrZXlUaHJlc2hvbGQ6IG9wdGlvbnMudGhyZXNob2xkXG4gICAgfTtcbiAgfVxuICBjb25zdCB2YWx1ZXNUb1JhbmsgPSBnZXRBbGxWYWx1ZXNUb1JhbmsoaXRlbSwga2V5cyk7XG4gIHJldHVybiB2YWx1ZXNUb1JhbmsucmVkdWNlKChfcmVmMiwgX3JlZjMsIGkpID0+IHtcbiAgICBsZXQge1xuICAgICAgcmFuayxcbiAgICAgIHJhbmtlZFZhbHVlLFxuICAgICAga2V5SW5kZXgsXG4gICAgICBrZXlUaHJlc2hvbGRcbiAgICB9ID0gX3JlZjI7XG4gICAgbGV0IHtcbiAgICAgIGl0ZW1WYWx1ZSxcbiAgICAgIGF0dHJpYnV0ZXNcbiAgICB9ID0gX3JlZjM7XG4gICAgbGV0IG5ld1JhbmsgPSBnZXRNYXRjaFJhbmtpbmcoaXRlbVZhbHVlLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgbGV0IG5ld1JhbmtlZFZhbHVlID0gcmFua2VkVmFsdWU7XG4gICAgY29uc3Qge1xuICAgICAgbWluUmFua2luZyxcbiAgICAgIG1heFJhbmtpbmcsXG4gICAgICB0aHJlc2hvbGRcbiAgICB9ID0gYXR0cmlidXRlcztcbiAgICBpZiAobmV3UmFuayA8IG1pblJhbmtpbmcgJiYgbmV3UmFuayA+PSByYW5raW5ncy5NQVRDSEVTKSB7XG4gICAgICBuZXdSYW5rID0gbWluUmFua2luZztcbiAgICB9IGVsc2UgaWYgKG5ld1JhbmsgPiBtYXhSYW5raW5nKSB7XG4gICAgICBuZXdSYW5rID0gbWF4UmFua2luZztcbiAgICB9XG4gICAgaWYgKG5ld1JhbmsgPiByYW5rKSB7XG4gICAgICByYW5rID0gbmV3UmFuaztcbiAgICAgIGtleUluZGV4ID0gaTtcbiAgICAgIGtleVRocmVzaG9sZCA9IHRocmVzaG9sZDtcbiAgICAgIG5ld1JhbmtlZFZhbHVlID0gaXRlbVZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcmFua2VkVmFsdWU6IG5ld1JhbmtlZFZhbHVlLFxuICAgICAgcmFuayxcbiAgICAgIGtleUluZGV4LFxuICAgICAga2V5VGhyZXNob2xkXG4gICAgfTtcbiAgfSwge1xuICAgIHJhbmtlZFZhbHVlOiBpdGVtLFxuICAgIHJhbms6IHJhbmtpbmdzLk5PX01BVENILFxuICAgIGtleUluZGV4OiAtMSxcbiAgICBrZXlUaHJlc2hvbGQ6IG9wdGlvbnMudGhyZXNob2xkXG4gIH0pO1xufVxuXG4vKipcbiAqIEdpdmVzIGEgcmFua2luZ3Mgc2NvcmUgYmFzZWQgb24gaG93IHdlbGwgdGhlIHR3byBzdHJpbmdzIG1hdGNoLlxuICogQHBhcmFtIHtTdHJpbmd9IHRlc3RTdHJpbmcgLSB0aGUgc3RyaW5nIHRvIHRlc3QgYWdhaW5zdFxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZ1RvUmFuayAtIHRoZSBzdHJpbmcgdG8gcmFua1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIGZvciB0aGUgbWF0Y2ggKGxpa2Uga2VlcERpYWNyaXRpY3MgZm9yIGNvbXBhcmlzb24pXG4gKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgcmFua2luZyBmb3IgaG93IHdlbGwgc3RyaW5nVG9SYW5rIG1hdGNoZXMgdGVzdFN0cmluZ1xuICovXG5mdW5jdGlvbiBnZXRNYXRjaFJhbmtpbmcodGVzdFN0cmluZywgc3RyaW5nVG9SYW5rLCBvcHRpb25zKSB7XG4gIHRlc3RTdHJpbmcgPSBwcmVwYXJlVmFsdWVGb3JDb21wYXJpc29uKHRlc3RTdHJpbmcsIG9wdGlvbnMpO1xuICBzdHJpbmdUb1JhbmsgPSBwcmVwYXJlVmFsdWVGb3JDb21wYXJpc29uKHN0cmluZ1RvUmFuaywgb3B0aW9ucyk7XG5cbiAgLy8gdG9vIGxvbmdcbiAgaWYgKHN0cmluZ1RvUmFuay5sZW5ndGggPiB0ZXN0U3RyaW5nLmxlbmd0aCkge1xuICAgIHJldHVybiByYW5raW5ncy5OT19NQVRDSDtcbiAgfVxuXG4gIC8vIGNhc2Ugc2Vuc2l0aXZlIGVxdWFsc1xuICBpZiAodGVzdFN0cmluZyA9PT0gc3RyaW5nVG9SYW5rKSB7XG4gICAgcmV0dXJuIHJhbmtpbmdzLkNBU0VfU0VOU0lUSVZFX0VRVUFMO1xuICB9XG5cbiAgLy8gTG93ZXIgY2FzaW5nIGJlZm9yZSBmdXJ0aGVyIGNvbXBhcmlzb25cbiAgdGVzdFN0cmluZyA9IHRlc3RTdHJpbmcudG9Mb3dlckNhc2UoKTtcbiAgc3RyaW5nVG9SYW5rID0gc3RyaW5nVG9SYW5rLnRvTG93ZXJDYXNlKCk7XG5cbiAgLy8gY2FzZSBpbnNlbnNpdGl2ZSBlcXVhbHNcbiAgaWYgKHRlc3RTdHJpbmcgPT09IHN0cmluZ1RvUmFuaykge1xuICAgIHJldHVybiByYW5raW5ncy5FUVVBTDtcbiAgfVxuXG4gIC8vIHN0YXJ0cyB3aXRoXG4gIGlmICh0ZXN0U3RyaW5nLnN0YXJ0c1dpdGgoc3RyaW5nVG9SYW5rKSkge1xuICAgIHJldHVybiByYW5raW5ncy5TVEFSVFNfV0lUSDtcbiAgfVxuXG4gIC8vIHdvcmQgc3RhcnRzIHdpdGhcbiAgaWYgKHRlc3RTdHJpbmcuaW5jbHVkZXMoYCAke3N0cmluZ1RvUmFua31gKSkge1xuICAgIHJldHVybiByYW5raW5ncy5XT1JEX1NUQVJUU19XSVRIO1xuICB9XG5cbiAgLy8gY29udGFpbnNcbiAgaWYgKHRlc3RTdHJpbmcuaW5jbHVkZXMoc3RyaW5nVG9SYW5rKSkge1xuICAgIHJldHVybiByYW5raW5ncy5DT05UQUlOUztcbiAgfSBlbHNlIGlmIChzdHJpbmdUb1JhbmsubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gSWYgdGhlIG9ubHkgY2hhcmFjdGVyIGluIHRoZSBnaXZlbiBzdHJpbmdUb1JhbmtcbiAgICAvLyAgIGlzbid0IGV2ZW4gY29udGFpbmVkIGluIHRoZSB0ZXN0U3RyaW5nLCB0aGVuXG4gICAgLy8gICBpdCdzIGRlZmluaXRlbHkgbm90IGEgbWF0Y2guXG4gICAgcmV0dXJuIHJhbmtpbmdzLk5PX01BVENIO1xuICB9XG5cbiAgLy8gYWNyb255bVxuICBpZiAoZ2V0QWNyb255bSh0ZXN0U3RyaW5nKS5pbmNsdWRlcyhzdHJpbmdUb1JhbmspKSB7XG4gICAgcmV0dXJuIHJhbmtpbmdzLkFDUk9OWU07XG4gIH1cblxuICAvLyB3aWxsIHJldHVybiBhIG51bWJlciBiZXR3ZWVuIHJhbmtpbmdzLk1BVENIRVMgYW5kXG4gIC8vIHJhbmtpbmdzLk1BVENIRVMgKyAxIGRlcGVuZGluZyAgb24gaG93IGNsb3NlIG9mIGEgbWF0Y2ggaXQgaXMuXG4gIHJldHVybiBnZXRDbG9zZW5lc3NSYW5raW5nKHRlc3RTdHJpbmcsIHN0cmluZ1RvUmFuayk7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGFuIGFjcm9ueW0gZm9yIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgdGhlIHN0cmluZyBmb3Igd2hpY2ggdG8gcHJvZHVjZSB0aGUgYWNyb255bVxuICogQHJldHVybnMge1N0cmluZ30gdGhlIGFjcm9ueW1cbiAqL1xuZnVuY3Rpb24gZ2V0QWNyb255bShzdHJpbmcpIHtcbiAgbGV0IGFjcm9ueW0gPSAnJztcbiAgY29uc3Qgd29yZHNJblN0cmluZyA9IHN0cmluZy5zcGxpdCgnICcpO1xuICB3b3Jkc0luU3RyaW5nLmZvckVhY2god29yZEluU3RyaW5nID0+IHtcbiAgICBjb25zdCBzcGxpdEJ5SHlwaGVuV29yZHMgPSB3b3JkSW5TdHJpbmcuc3BsaXQoJy0nKTtcbiAgICBzcGxpdEJ5SHlwaGVuV29yZHMuZm9yRWFjaChzcGxpdEJ5SHlwaGVuV29yZCA9PiB7XG4gICAgICBhY3JvbnltICs9IHNwbGl0QnlIeXBoZW5Xb3JkLnN1YnN0cigwLCAxKTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBhY3JvbnltO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBzY29yZSBiYXNlZCBvbiBob3cgc3ByZWFkIGFwYXJ0IHRoZVxuICogY2hhcmFjdGVycyBmcm9tIHRoZSBzdHJpbmdUb1JhbmsgYXJlIHdpdGhpbiB0aGUgdGVzdFN0cmluZy5cbiAqIEEgbnVtYmVyIGNsb3NlIHRvIHJhbmtpbmdzLk1BVENIRVMgcmVwcmVzZW50cyBhIGxvb3NlIG1hdGNoLiBBIG51bWJlciBjbG9zZVxuICogdG8gcmFua2luZ3MuTUFUQ0hFUyArIDEgcmVwcmVzZW50cyBhIHRpZ2h0ZXIgbWF0Y2guXG4gKiBAcGFyYW0ge1N0cmluZ30gdGVzdFN0cmluZyAtIHRoZSBzdHJpbmcgdG8gdGVzdCBhZ2FpbnN0XG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nVG9SYW5rIC0gdGhlIHN0cmluZyB0byByYW5rXG4gKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgbnVtYmVyIGJldHdlZW4gcmFua2luZ3MuTUFUQ0hFUyBhbmRcbiAqIHJhbmtpbmdzLk1BVENIRVMgKyAxIGZvciBob3cgd2VsbCBzdHJpbmdUb1JhbmsgbWF0Y2hlcyB0ZXN0U3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGdldENsb3NlbmVzc1JhbmtpbmcodGVzdFN0cmluZywgc3RyaW5nVG9SYW5rKSB7XG4gIGxldCBtYXRjaGluZ0luT3JkZXJDaGFyQ291bnQgPSAwO1xuICBmdW5jdGlvbiBmaW5kTWF0Y2hpbmdDaGFyYWN0ZXIobWF0Y2hDaGFyLCBzdHJpbmcsIGluZGV4KSB7XG4gICAgZm9yIChsZXQgaiA9IGluZGV4LCBKID0gc3RyaW5nLmxlbmd0aDsgaiA8IEo7IGorKykge1xuICAgICAgY29uc3Qgc3RyaW5nQ2hhciA9IHN0cmluZ1tqXTtcbiAgICAgIGlmIChzdHJpbmdDaGFyID09PSBtYXRjaENoYXIpIHtcbiAgICAgICAgbWF0Y2hpbmdJbk9yZGVyQ2hhckNvdW50ICs9IDE7XG4gICAgICAgIHJldHVybiBqICsgMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGxldCBza2lwcGVkID0gMDtcbiAgZnVuY3Rpb24gZ2V0UmFua2luZyhzcHJlYWQpIHtcbiAgICBjb25zdCBzcHJlYWRQZXJjZW50YWdlID0gMSAvIHNwcmVhZDtcbiAgICBjb25zdCBpbk9yZGVyUGVyY2VudGFnZSA9IG1hdGNoaW5nSW5PcmRlckNoYXJDb3VudCAvIHN0cmluZ1RvUmFuay5sZW5ndGg7XG4gICAgY29uc3QgbWF0Y2hQZXJjZW50YWdlID0gKHN0cmluZ1RvUmFuay5sZW5ndGggLSBza2lwcGVkKSAvIHN0cmluZ1RvUmFuay5sZW5ndGg7XG4gICAgY29uc3QgcmFua2luZyA9IHJhbmtpbmdzLk1BVENIRVMgKyBpbk9yZGVyUGVyY2VudGFnZSAqIHNwcmVhZFBlcmNlbnRhZ2UgKiBtYXRjaFBlcmNlbnRhZ2U7XG4gICAgcmV0dXJuIHJhbmtpbmc7XG4gIH1cbiAgbGV0IGZpcnN0SW5kZXggPSAwO1xuICBsZXQgY2hhck51bWJlciA9IDA7XG4gIGxldCBuZXh0Q2hhck51bWJlciA9IDA7XG4gIGZvciAobGV0IGkgPSAwLCBJID0gc3RyaW5nVG9SYW5rLmxlbmd0aDsgaSA8IEk7IGkrKykge1xuICAgIGNvbnN0IG1hdGNoQ2hhciA9IHN0cmluZ1RvUmFua1tpXTtcbiAgICBuZXh0Q2hhck51bWJlciA9IGZpbmRNYXRjaGluZ0NoYXJhY3RlcihtYXRjaENoYXIsIHRlc3RTdHJpbmcsIGNoYXJOdW1iZXIpO1xuICAgIGNvbnN0IGZvdW5kID0gbmV4dENoYXJOdW1iZXIgPiAtMTtcbiAgICBpZiAoZm91bmQpIHtcbiAgICAgIGNoYXJOdW1iZXIgPSBuZXh0Q2hhck51bWJlcjtcbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIGZpcnN0SW5kZXggPSBjaGFyTnVtYmVyO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2tpcHBlZCA+IDAgfHwgc3RyaW5nVG9SYW5rLmxlbmd0aCA8PSAzKSB7XG4gICAgICAvLyBpZiBzZWFyY2ggdGVybSBpcyBzaG9ydCwgcmVxdWlyZSBmaW5kaW5nIGFsbCBjaGFyYWN0ZXJzXG4gICAgICByZXR1cm4gcmFua2luZ3MuTk9fTUFUQ0g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNraXBwZWQgKz0gMTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgc3ByZWFkID0gY2hhck51bWJlciAtIGZpcnN0SW5kZXg7XG4gIHJldHVybiBnZXRSYW5raW5nKHNwcmVhZCk7XG59XG5cbi8qKlxuICogU29ydHMgaXRlbXMgdGhhdCBoYXZlIGEgcmFuaywgaW5kZXgsIGFuZCBrZXlJbmRleFxuICogQHBhcmFtIHtPYmplY3R9IGEgLSB0aGUgZmlyc3QgaXRlbSB0byBzb3J0XG4gKiBAcGFyYW0ge09iamVjdH0gYiAtIHRoZSBzZWNvbmQgaXRlbSB0byBzb3J0XG4gKiBAcmV0dXJuIHtOdW1iZXJ9IC0xIGlmIGEgc2hvdWxkIGNvbWUgZmlyc3QsIDEgaWYgYiBzaG91bGQgY29tZSBmaXJzdCwgMCBpZiBlcXVhbFxuICovXG5mdW5jdGlvbiBzb3J0UmFua2VkVmFsdWVzKGEsIGIsIGJhc2VTb3J0KSB7XG4gIGNvbnN0IGFGaXJzdCA9IC0xO1xuICBjb25zdCBiRmlyc3QgPSAxO1xuICBjb25zdCB7XG4gICAgcmFuazogYVJhbmssXG4gICAga2V5SW5kZXg6IGFLZXlJbmRleFxuICB9ID0gYTtcbiAgY29uc3Qge1xuICAgIHJhbms6IGJSYW5rLFxuICAgIGtleUluZGV4OiBiS2V5SW5kZXhcbiAgfSA9IGI7XG4gIGNvbnN0IHNhbWUgPSBhUmFuayA9PT0gYlJhbms7XG4gIGlmIChzYW1lKSB7XG4gICAgaWYgKGFLZXlJbmRleCA9PT0gYktleUluZGV4KSB7XG4gICAgICAvLyB1c2UgdGhlIGJhc2Ugc29ydCBmdW5jdGlvbiBhcyBhIHRpZS1icmVha2VyXG4gICAgICByZXR1cm4gYmFzZVNvcnQoYSwgYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhS2V5SW5kZXggPCBiS2V5SW5kZXggPyBhRmlyc3QgOiBiRmlyc3Q7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBhUmFuayA+IGJSYW5rID8gYUZpcnN0IDogYkZpcnN0O1xuICB9XG59XG5cbi8qKlxuICogUHJlcGFyZXMgdmFsdWUgZm9yIGNvbXBhcmlzb24gYnkgc3RyaW5naWZ5aW5nIGl0LCByZW1vdmluZyBkaWFjcml0aWNzIChpZiBzcGVjaWZpZWQpXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgLSB0aGUgdmFsdWUgdG8gY2xlYW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0ge2tlZXBEaWFjcml0aWNzOiB3aGV0aGVyIHRvIHJlbW92ZSBkaWFjcml0aWNzfVxuICogQHJldHVybiB7U3RyaW5nfSB0aGUgcHJlcGFyZWQgdmFsdWVcbiAqL1xuZnVuY3Rpb24gcHJlcGFyZVZhbHVlRm9yQ29tcGFyaXNvbih2YWx1ZSwgX3JlZjQpIHtcbiAgbGV0IHtcbiAgICBrZWVwRGlhY3JpdGljc1xuICB9ID0gX3JlZjQ7XG4gIC8vIHZhbHVlIG1pZ2h0IG5vdCBhY3R1YWxseSBiZSBhIHN0cmluZyBhdCB0aGlzIHBvaW50ICh3ZSBkb24ndCBnZXQgdG8gY2hvb3NlKVxuICAvLyBzbyBwYXJ0IG9mIHByZXBhcmluZyB0aGUgdmFsdWUgZm9yIGNvbXBhcmlzb24gaXMgZW5zdXJlIHRoYXQgaXQgaXMgYSBzdHJpbmdcbiAgdmFsdWUgPSBgJHt2YWx1ZX1gOyAvLyB0b1N0cmluZ1xuICBpZiAoIWtlZXBEaWFjcml0aWNzKSB7XG4gICAgdmFsdWUgPSByZW1vdmVBY2NlbnRzKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogR2V0cyB2YWx1ZSBmb3Iga2V5IGluIGl0ZW0gYXQgYXJiaXRyYXJpbHkgbmVzdGVkIGtleXBhdGhcbiAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIC0gdGhlIGl0ZW1cbiAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSBrZXkgLSB0aGUgcG90ZW50aWFsbHkgbmVzdGVkIGtleXBhdGggb3IgcHJvcGVydHkgY2FsbGJhY2tcbiAqIEByZXR1cm4ge0FycmF5fSAtIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIHZhbHVlKHMpIGF0IHRoZSBuZXN0ZWQga2V5cGF0aFxuICovXG5mdW5jdGlvbiBnZXRJdGVtVmFsdWVzKGl0ZW0sIGtleSkge1xuICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICBrZXkgPSBrZXkua2V5O1xuICB9XG4gIGxldCB2YWx1ZTtcbiAgaWYgKHR5cGVvZiBrZXkgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YWx1ZSA9IGtleShpdGVtKTtcbiAgfSBlbHNlIGlmIChpdGVtID09IG51bGwpIHtcbiAgICB2YWx1ZSA9IG51bGw7XG4gIH0gZWxzZSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoaXRlbSwga2V5KSkge1xuICAgIHZhbHVlID0gaXRlbVtrZXldO1xuICB9IGVsc2UgaWYgKGtleS5pbmNsdWRlcygnLicpKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtY2FsbFxuICAgIHJldHVybiBnZXROZXN0ZWRWYWx1ZXMoa2V5LCBpdGVtKTtcbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IG51bGw7XG4gIH1cblxuICAvLyBiZWNhdXNlIGB2YWx1ZWAgY2FuIGFsc28gYmUgdW5kZWZpbmVkXG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gW1N0cmluZyh2YWx1ZSldO1xufVxuXG4vKipcbiAqIEdpdmVuIHBhdGg6IFwiZm9vLmJhci5iYXpcIlxuICogQW5kIGl0ZW06IHtmb286IHtiYXI6IHtiYXo6ICdidXp6J319fVxuICogICAtPiAnYnV6eidcbiAqIEBwYXJhbSBwYXRoIGEgZG90LXNlcGFyYXRlZCBzZXQgb2Yga2V5c1xuICogQHBhcmFtIGl0ZW0gdGhlIGl0ZW0gdG8gZ2V0IHRoZSB2YWx1ZSBmcm9tXG4gKi9cbmZ1bmN0aW9uIGdldE5lc3RlZFZhbHVlcyhwYXRoLCBpdGVtKSB7XG4gIGNvbnN0IGtleXMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIGxldCB2YWx1ZXMgPSBbaXRlbV07XG4gIGZvciAobGV0IGkgPSAwLCBJID0ga2V5cy5sZW5ndGg7IGkgPCBJOyBpKyspIHtcbiAgICBjb25zdCBuZXN0ZWRLZXkgPSBrZXlzW2ldO1xuICAgIGxldCBuZXN0ZWRWYWx1ZXMgPSBbXTtcbiAgICBmb3IgKGxldCBqID0gMCwgSiA9IHZhbHVlcy5sZW5ndGg7IGogPCBKOyBqKyspIHtcbiAgICAgIGNvbnN0IG5lc3RlZEl0ZW0gPSB2YWx1ZXNbal07XG4gICAgICBpZiAobmVzdGVkSXRlbSA9PSBudWxsKSBjb250aW51ZTtcbiAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChuZXN0ZWRJdGVtLCBuZXN0ZWRLZXkpKSB7XG4gICAgICAgIGNvbnN0IG5lc3RlZFZhbHVlID0gbmVzdGVkSXRlbVtuZXN0ZWRLZXldO1xuICAgICAgICBpZiAobmVzdGVkVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgIG5lc3RlZFZhbHVlcy5wdXNoKG5lc3RlZFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChuZXN0ZWRLZXkgPT09ICcqJykge1xuICAgICAgICAvLyBlbnN1cmUgdGhhdCB2YWx1ZXMgaXMgYW4gYXJyYXlcbiAgICAgICAgbmVzdGVkVmFsdWVzID0gbmVzdGVkVmFsdWVzLmNvbmNhdChuZXN0ZWRJdGVtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFsdWVzID0gbmVzdGVkVmFsdWVzO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlc1swXSkpIHtcbiAgICAvLyBrZWVwIGFsbG93aW5nIHRoZSBpbXBsaWNpdCB3aWxkY2FyZCBmb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyBhdCB0aGUgZW5kIG9mXG4gICAgLy8gdGhlIHBhdGg7IGRvbid0IHVzZSBgLmZsYXQoKWAgYmVjYXVzZSB0aGF0J3Mgbm90IGF2YWlsYWJsZSBpbiBub2RlLmpzIHYxMFxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIHJldHVybiByZXN1bHQuY29uY2F0KC4uLnZhbHVlcyk7XG4gIH1cbiAgLy8gQmFzZWQgb24gb3VyIGxvZ2ljIGl0IHNob3VsZCBiZSBhbiBhcnJheSBvZiBzdHJpbmdzIGJ5IG5vdy4uLlxuICAvLyBhc3N1bWluZyB0aGUgdXNlcidzIHBhdGggdGVybWluYXRlZCBpbiBzdHJpbmdzXG4gIHJldHVybiB2YWx1ZXM7XG59XG5cbi8qKlxuICogR2V0cyBhbGwgdGhlIHZhbHVlcyBmb3IgdGhlIGdpdmVuIGtleXMgaW4gdGhlIGdpdmVuIGl0ZW0gYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgdGhvc2UgdmFsdWVzXG4gKiBAcGFyYW0gaXRlbSAtIHRoZSBpdGVtIGZyb20gd2hpY2ggdGhlIHZhbHVlcyB3aWxsIGJlIHJldHJpZXZlZFxuICogQHBhcmFtIGtleXMgLSB0aGUga2V5cyB0byB1c2UgdG8gcmV0cmlldmUgdGhlIHZhbHVlc1xuICogQHJldHVybiBvYmplY3RzIHdpdGgge2l0ZW1WYWx1ZSwgYXR0cmlidXRlc31cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsVmFsdWVzVG9SYW5rKGl0ZW0sIGtleXMpIHtcbiAgY29uc3QgYWxsVmFsdWVzID0gW107XG4gIGZvciAobGV0IGogPSAwLCBKID0ga2V5cy5sZW5ndGg7IGogPCBKOyBqKyspIHtcbiAgICBjb25zdCBrZXkgPSBrZXlzW2pdO1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBnZXRLZXlBdHRyaWJ1dGVzKGtleSk7XG4gICAgY29uc3QgaXRlbVZhbHVlcyA9IGdldEl0ZW1WYWx1ZXMoaXRlbSwga2V5KTtcbiAgICBmb3IgKGxldCBpID0gMCwgSSA9IGl0ZW1WYWx1ZXMubGVuZ3RoOyBpIDwgSTsgaSsrKSB7XG4gICAgICBhbGxWYWx1ZXMucHVzaCh7XG4gICAgICAgIGl0ZW1WYWx1ZTogaXRlbVZhbHVlc1tpXSxcbiAgICAgICAgYXR0cmlidXRlc1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhbGxWYWx1ZXM7XG59XG5jb25zdCBkZWZhdWx0S2V5QXR0cmlidXRlcyA9IHtcbiAgbWF4UmFua2luZzogSW5maW5pdHksXG4gIG1pblJhbmtpbmc6IC1JbmZpbml0eVxufTtcbi8qKlxuICogR2V0cyBhbGwgdGhlIGF0dHJpYnV0ZXMgZm9yIHRoZSBnaXZlbiBrZXlcbiAqIEBwYXJhbSBrZXkgLSB0aGUga2V5IGZyb20gd2hpY2ggdGhlIGF0dHJpYnV0ZXMgd2lsbCBiZSByZXRyaWV2ZWRcbiAqIEByZXR1cm4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGtleSdzIGF0dHJpYnV0ZXNcbiAqL1xuZnVuY3Rpb24gZ2V0S2V5QXR0cmlidXRlcyhrZXkpIHtcbiAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRLZXlBdHRyaWJ1dGVzO1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4uZGVmYXVsdEtleUF0dHJpYnV0ZXMsXG4gICAgLi4ua2V5XG4gIH07XG59XG5cbi8qXG5lc2xpbnRcbiAgbm8tY29udGludWU6IFwib2ZmXCIsXG4qL1xuXG5leHBvcnQgeyBkZWZhdWx0QmFzZVNvcnRGbiwgbWF0Y2hTb3J0ZXIsIHJhbmtpbmdzIH07XG4iXSwibmFtZXMiOlsicmVtb3ZlQWNjZW50cyIsInJhbmtpbmdzIiwiQ0FTRV9TRU5TSVRJVkVfRVFVQUwiLCJFUVVBTCIsIlNUQVJUU19XSVRIIiwiV09SRF9TVEFSVFNfV0lUSCIsIkNPTlRBSU5TIiwiQUNST05ZTSIsIk1BVENIRVMiLCJOT19NQVRDSCIsImRlZmF1bHRCYXNlU29ydEZuIiwiYSIsImIiLCJTdHJpbmciLCJyYW5rZWRWYWx1ZSIsImxvY2FsZUNvbXBhcmUiLCJtYXRjaFNvcnRlciIsIml0ZW1zIiwidmFsdWUiLCJvcHRpb25zIiwia2V5cyIsInRocmVzaG9sZCIsImJhc2VTb3J0Iiwic29ydGVyIiwibWF0Y2hlZEl0ZW1zIiwic29ydCIsInNvcnRSYW5rZWRWYWx1ZXMiLCJyZWR1Y2UiLCJyZWR1Y2VJdGVtc1RvUmFua2VkIiwibWFwIiwiX3JlZiIsIml0ZW0iLCJtYXRjaGVzIiwiaW5kZXgiLCJyYW5raW5nSW5mbyIsImdldEhpZ2hlc3RSYW5raW5nIiwicmFuayIsImtleVRocmVzaG9sZCIsInB1c2giLCJzdHJpbmdJdGVtIiwiZ2V0TWF0Y2hSYW5raW5nIiwia2V5SW5kZXgiLCJ2YWx1ZXNUb1JhbmsiLCJnZXRBbGxWYWx1ZXNUb1JhbmsiLCJfcmVmMiIsIl9yZWYzIiwiaSIsIml0ZW1WYWx1ZSIsImF0dHJpYnV0ZXMiLCJuZXdSYW5rIiwibmV3UmFua2VkVmFsdWUiLCJtaW5SYW5raW5nIiwibWF4UmFua2luZyIsInRlc3RTdHJpbmciLCJzdHJpbmdUb1JhbmsiLCJwcmVwYXJlVmFsdWVGb3JDb21wYXJpc29uIiwibGVuZ3RoIiwidG9Mb3dlckNhc2UiLCJzdGFydHNXaXRoIiwiaW5jbHVkZXMiLCJnZXRBY3JvbnltIiwiZ2V0Q2xvc2VuZXNzUmFua2luZyIsInN0cmluZyIsImFjcm9ueW0iLCJ3b3Jkc0luU3RyaW5nIiwic3BsaXQiLCJmb3JFYWNoIiwid29yZEluU3RyaW5nIiwic3BsaXRCeUh5cGhlbldvcmRzIiwic3BsaXRCeUh5cGhlbldvcmQiLCJzdWJzdHIiLCJtYXRjaGluZ0luT3JkZXJDaGFyQ291bnQiLCJmaW5kTWF0Y2hpbmdDaGFyYWN0ZXIiLCJtYXRjaENoYXIiLCJqIiwiSiIsInN0cmluZ0NoYXIiLCJza2lwcGVkIiwiZ2V0UmFua2luZyIsInNwcmVhZCIsInNwcmVhZFBlcmNlbnRhZ2UiLCJpbk9yZGVyUGVyY2VudGFnZSIsIm1hdGNoUGVyY2VudGFnZSIsInJhbmtpbmciLCJmaXJzdEluZGV4IiwiY2hhck51bWJlciIsIm5leHRDaGFyTnVtYmVyIiwiSSIsImZvdW5kIiwiYUZpcnN0IiwiYkZpcnN0IiwiYVJhbmsiLCJhS2V5SW5kZXgiLCJiUmFuayIsImJLZXlJbmRleCIsInNhbWUiLCJfcmVmNCIsImtlZXBEaWFjcml0aWNzIiwiZ2V0SXRlbVZhbHVlcyIsImtleSIsIk9iamVjdCIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImdldE5lc3RlZFZhbHVlcyIsIkFycmF5IiwiaXNBcnJheSIsInBhdGgiLCJ2YWx1ZXMiLCJuZXN0ZWRLZXkiLCJuZXN0ZWRWYWx1ZXMiLCJuZXN0ZWRJdGVtIiwibmVzdGVkVmFsdWUiLCJjb25jYXQiLCJyZXN1bHQiLCJhbGxWYWx1ZXMiLCJnZXRLZXlBdHRyaWJ1dGVzIiwiaXRlbVZhbHVlcyIsImRlZmF1bHRLZXlBdHRyaWJ1dGVzIiwiSW5maW5pdHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/match-sorter/dist/match-sorter.esm.js\n");

/***/ })

};
;